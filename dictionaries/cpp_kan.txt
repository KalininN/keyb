#else
#endif
#if ( _WIN32 || __WIN32__ )
#ifdef LOCAL
#ifdef WIN32
#include <algorithm>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <fstream>
#include <functional>
#include <iostream>
#include <iterator>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>
(a.x == b.x && a.id == b.id && a.y < b.y);
*ans = *cur;
*wh = x;
*x = _x;
A--;
ALL = km - 1;
B--;
C -= B;
D = dist;
FILE *dict = fopen("cdict.txt", "r");
FILE *ssin, *ssout;
FILE* f = fopen("garbled_email_dictionary.txt", "r");
IT = 0;
IT++;
L1[1] = l1 % len;
L1[2] = l1 - r1 + R1[2];
L1[3] = 0;
L2[1] = l2 % len;
L2[2] = l2 - r2 + R2[2];
L2[3] = 0;
MINF = 1LL << 40;
MINF >>= 1;
N++;
Owon = Owon || cntO == 4;
PreCalc();
R1[1] = r1 - l1 + L1[1];
R1[2] = r1 % len;
R2[1] = r2 - l2 + L2[1];
R2[2] = r2 % len;
S--, T--;
T *= delta;
T *ans = NULL;
T *l, *r;
T ans(1);
T ppow(T a, int n)
T t = a;
T x, y;
T--;
TIMESTAMP(end);
Worker s[maxn];
X = abs(X);
X = x;
Xwon = Xwon || cntX == 4;
a %= n;
a += wa;
a /= 10;
a /= 2;
a = (a + b) % MOD;
a = (lower_bound(v.begin(), v.end(), a, cmph) - v.begin());
a = _a;
a = a % n;
a = comp[a];
a = find(a);
a = merge(l, merge(m, r));
a = min(a, b);
a = next(a, n);
a = norm(a);
a = p[(*root[a])[0]];
a = up[a][k];
a >>= 1;
a--, b--;
a--;
a->with0.addd(it->first + b->with0.add, it->second);
a->without0.addd(it->first + b->without0.add, it->second);
a.push_back(make_pair(x, i));
a.resize(0);
a.wh.erase(a.wh.begin() + i);
a.wh[i - 1].second += a.wh[i].second;
a1[i] = a;
a['q'] = 'z';
a['z'] = 'q';
a[0] = 2;
a[0][0] = tmp[0][0];
a[0][1] = tmp[0][1];
a[0][n] = 1;
a[1][0] = tmp[1][0];
a[1][1] = tmp[1][1];
a[curx][cury] += p[i][j];
a[i + n].second = i;
a[i + n].t = -1;
a[i + n].x = B;
a[i] = code(strlen(s));
a[i] = strlen(s) - 1;
a[i] = x;
a[i]--, b[i]--;
a[i]--;
a[i].id = i;
a[i].second = i;
a[i].t = 1;
a[i].x = A;
a[i][b] = a[i][b] - mn * a[y][b];
a[i][i] = 1;
a[i][j] *= -1;
a[i][n + i] = 1;
a[j][i] = 0;
a[m + 1][n + m + 1] -= mn * a[i][n + m + 1];
a[m + 1][n + m] = -1;
a[m++] = x / 2;
a[n] = 1;
a[n] = a[n - 1] * k + 2;
a[n] = inf;
a[n] = make_pair(-1, -1);
a[res][b] = a[res][b] - mn * a[y][b];
a[t] = (a[t - 1] * a[t - 1]) % mod;
a[x >> 5] |= ((uint)1 << (x & 31));
a[x] = 0;
a[x] = y;
a[x][y] = '#';
a[x][y] = '.';
a[x][y][0][0] = a[x][y - 1][0][0];
a[x][y][0][1] = (a[x][y][0][1] + b[x][y][0][1]) % MOD;
a[x][y][0][1] = a[x + 1][y][0][1];
a[x][y][1][0] = (a[x][y][1][0] + b[x][y][1][0] + MOD) % MOD;
a[x][y][1][0] = a[x][y - 1][1][0];
a[x][y][1][1] = a[x][y + 1][1][1];
a[y][b] /= del;
aarr1[i] = min(aarr1[i], aarr1[i + 1]);
aarr2[i] = min(aarr2[i], aarr2[i - 1]);
add = pt(0, 0);
add(*prev, *next);
add(*prev, *wh);
add(*prev, x);
add(*wh, *next);
add(-1);
add(0, i);
add(1);
add(1, 0, treesize - 1, l, r, b);
add(1, 0, treesize - 1, len[f[cur].t].back());
add(1, i);
add(b[i], ans[i]);
add(cur * 2 + 1, cm + 1, cr, l, r, t);
add(cur * 2 + 1, cm + 1, cr, x);
add(cur * 2, cl, cm, l, r, t);
add(cur * 2, cl, cm, x);
add(cur, wh[gr[cur][i]], cc[cur][i]);
add(cur->link[wh].second, s, curc + 1, len);
add(curx, curx + x);
add(i + 1);
add(i);
add(i, j);
add(make(n), 1);
add(mc[i]);
add(p);
add(root, i, 0, len);
add(root[i], a[i]);
add(w[i * 2 - 1]);
add(w[i * 2 - 2]);
add(x + dx[i], y + dy[i], d[x][y], p[x][y]);
add(x, *wh);
add(x[i]);
add++;
add[(j + i) % n]++;
add[(j + i) % n]--;
add[cur * 2 + 1] += add[cur];
add[cur * 2] += add[cur];
add[cur] = 0;
add[cur]++;
add_one(tree[cur * 2 + 1].f0, 0, len, tree[cur].push);
add_one(tree[cur * 2 + 1].f1, 1, len + 1, tree[cur].push);
add_one(tree[cur * 2].f0, 0, len, tree[cur].push);
add_one(tree[cur * 2].f1, 1, len + 1, tree[cur].push);
add_one(tree[cur].f0, 0, cr - cl + 1, t);
add_one(tree[cur].f1, 1, cr - cl + 2, t);
addd = 0;
addd = 1;
addingm = 0;
addingm = 1;
addingnm = ((ll)kvv[0]) * kvv[1];
addingnm = ((ll)n) * (n - 1) / 2 - m;
addmod(all, it->second);
addmod(answer, all * it->second);
addmod(which[gr[cur][i]][my->first], my->second);
addpos(pos(wh(i, j, k), i, j, k, dir), pos(0, 0, 0, 0, 0));
adds(answer);
adds(getans(0, 0, n));
adds(getans(0, a[r], r + 1));
adds(getans(a[l], 0, n - l));
adds(getans(a[l], a[r], r - l + 1));
addu = 0;
addu = 1;
adj.resize(0);
aft[n - 1] = n - 1;
alive[i] = true;
alive[whdeath] = false;
alive[whmerge2] = false;
allcheaters.insert(ids[i] + all);
allv1 = allv1 + v1[t2][0];
allv2 = allv2 + v2[t2][0];
ans *= (n - i + 1);
ans += (a & 1);
ans += kv[pr][k - (i + 1)] * kv[cur][i];
ans += last - i;
ans += now[l];
ans += sqrt(1.0 * e[i].l);
ans += sum[l >> S2];
ans += tmp % b;
ans += v[0][j + 300][ll];
ans -= (getmin() / 2.0);
ans /= (i - have);
ans = ((ans - (ll)get(b - a) * c) % MOD + MOD) % MOD;
ans = (ans * calc(cur->next[i])) % MOD;
ans = (ans * cur) % MOD;
ans = (ans * kv) % MOD;
ans = (ans * t) % MOD;
ans = (ans * t) % mod;
ans = (ans + (ll)get(sob[i].x - last.first) * cnt) % MOD;
ans = 0;
ans = ans % MOD;
ans = ans * curf;
ans = ans * f[i - last];
ans = ans * t;
ans = ans + near[j][i];
ans = ans + t;
ans = ans / 2;
ans = c1 + rr1;
ans = gr[a][c] + gr[a][d] + gr[b][c] + gr[b][d];
ans = kvrev + 1 - nowup + nowdown + mines.back();
ans = kvrev - 1 - nowup + nowdown + mines.back();
ans = max(ans, min(a, min(b, c)) + min(mr1, mr2));
ans = max(ans, min(a, mr2 + min(b, c)));
ans = max(ans, min(b, mr1 + min(a, c)));
ans = merge(ans, son);
ans = min(ans, curans + (n - i));
ans = mul(ans, t);
ans = mul(ans, t, mod);
ans = mymerge(ans, t);
ans = n;
ans = new tmap;
ans = x;
ans++;
ans->l = null;
ans->r = null;
ans->size = 1;
ans->sum = x;
ans->with0.addd(0, kv);
ans->without0.addd(0, 1);
ans->without0.data.erase(0 - ans->without0.add);
ans->x = x;
ans.push_back(make_pair(0, r[2]));
ans.push_back(make_pair(r[1], 0));
ans.push_back(make_pair(r[2], r[1]));
ans.resize(0);
ans.st2 -= kdiv2;
ans.st2--;
ans.wh.push_back(make_pair(a[n - 1], n - last));
ans.x = 0;
ans.x = a.x * b;
ans.x = a.x + b.x;
ans.x = a.x - b.x;
ans.x = a.x;
ans.x = b.x;
ans.x = c.x;
ans.x = -a.x;
ans.y = a.y * b;
ans.y = a.y + b.y;
ans.y = a.y - b.y;
ans.y = a.y;
ans.y = b.y;
ans.y = c.y;
ans.y = -a.y;
ans0[0] = 1;
ans1 = (h / b + k1 - 1) / k1;
ans1 = 0;
ans1 = fst;
ans1 = log1;
ans1 = mask1 ^ t;
ans1[1] = 1;
ans1[i][c1] = inf;
ans2 = (w / a + k2 - 1) / k2;
ans2 = 0;
ans2 = log2;
ans2 = mask2 ^ t;
ans2 = snd;
ans2[i + 1] = ans2[i];
ans2[i + 2] = ans2[i] + 1;
ans2[i + 3] = ans2[i];
ans3 = trd;
ans3[i + 1] = ans3[i];
ans3[i + 2] = ans3[i];
ans3[i + 3] = ans3[i] + 1;
ans[0] = 0;
ans[0] = 1;
ans[0] = 2;
ans[0] = b[bo];
ans[0][0] = (getbest(t[0], 0) >= p);
ans[0][0] = 0;
ans[0][0] = 1;
ans[0][0][0] = 0;
ans[0][0][0] = 1;
ans[0][0][1] = 0;
ans[0][5] = 0;
ans[0][i] = ans[0][i - 1] / 2;
ans[0][i] = mul(ans[0][i - 1], i);
ans[1] = 1;
ans[1] = 2;
ans[1][1] = 1;
ans[c] = 0;
ans[cur + 1] = i + 1;
ans[cur.x][cur.y] = '?';
ans[cur] = b[bo];
ans[cur] = curh;
ans[cur] = l[i].id;
ans[cur] = max(1, getans(1, 0, treesize - 1));
ans[cur] = place;
ans[cur][0] = 0;
ans[cur][mask] = 0;
ans[cur][mask] = max(ans[cur][mask], curans + es[cur][i].c);
ans[currid - curlid] += (next) / (2 * l);
ans[curx][cury] = curt;
ans[d] -= ans[i * d];
ans[d] = (ll)(n / d) * (m / d);
ans[gr[cur][i].second] = t;
ans[i + 1] = A * x * x + B * x + C + o[bo].y0;
ans[i + 1] = curans;
ans[i + 1] = max(ans[i + 1], ans[i]);
ans[i + 1][b][j] = (ans[i + 1][b][j] + ans[i][b][f]) % MOD;
ans[i + 2] = t;
ans[i + 3] = t;
ans[i] %= 100;
ans[i] = 1;
ans[i] = ans[i - 1];
ans[i] = b[bo];
ans[i] = good.top() + 1;
ans[i] = inf;
ans[i] = j;
ans[i] = ma[cury][n];
ans[i] = pc[i].real() / MAX + eps + t;
ans[i] = q[bo].a * a[i] + q[bo].b;
ans[i] = solveprime(a, p[i]);
ans[i] = up(ans[i], a, p[i], j);
ans[i][0] = ans[i - 1][0] + (getbest(t[i], 0) >= p);
ans[i][0] = ans[i - 1][0] / 2;
ans[i][ch] = ans[i - 1][ch] + 1;
ans[i][j] = 0;
ans[i][j] = ans[i][j + 1] + 1;
ans[i][j][0] = inf;
ans[i][j][1] = inf;
ans[i][n] = 1;
ans[i][s[i]] = min(ans[i][s[i]], ans[i - 1][ch]);
ans[init] = make_pair(1, 0);
ans[j] = max(ans[j], ans[i] + 1);
ans[j] = max(ans[j], ans[i] + job[j].c);
ans[l - 1] = 0;
ans[l][r] = -inf;
ans[l][r] = max(ans[l][r], curans);
ans[l][r][whmax] = infll;
ans[l][r][whmax] = min(ans[l][r][whmax], curans);
ans[mask | (1 << wh)].first += ans[mask].first / n;
ans[mask] = ans[mask ^ lastmask] + 1;
ans[mask] = countans(mask ^ XOR);
ans[mask] = t;
ans[minp.id] = cur;
ans[n - 1] = b[bo];
ans[n - 1][n] = 0;
ans[next[0][E]][next[0][i]] = 2;
ans[ni][nj] = min(ans[ni][nj], time);
ans[norm(a)][norm(b)][c] = zn;
ans[p[i].id] = p[i].y - get(root, 0, maxw, p[i].x);
ans[p[i].id] = p[i].y - y[p[i].newx];
ans[p[i]] = i;
ans[r[i].id].x = curw;
ans[r[i].id].y = curl;
ans[t + i] = ans[t] + can[i][j];
ans[t[i].id] = 1;
ans[t][j + 1] = min(ans[t][j + 1], curans);
ans[time][0] = ans[time][1];
ans[time][1] = ans[time][0] + 1;
ans[x][y][xr][yr] += getsum(x, y, xr, yr);
ans[x][y][xr][yr] = inf;
ansa = a;
ansa[1] = 2;
ansa[cx] = max(ansa[cx], curansb + (ll)a[cx]);
ansb *= kv;
ansb = b;
ansb[cy] = max(ansb[cy], curansa + (ll)b[cy]);
ansc = c;
ansd = d;
ansdown[l] = max(ansdown[l], ans[l][r]);
ansfound = cycled = forked = cornered = false;
ansfound = true;
ansh *= kv;
ansk[1] = 2;
ansl = 0;
ansl = l;
ansl[0][0] = 0;
ansl[0][1] = 0;
ansl[0][a[0]] = 0;
ansl[i][a[i]] = i;
ansl[i][c] = ansl[i - 1][elxor ^ a[i] ^ c];
ansp = 0;
ansp = wh;
ansq = -1;
ansq = i * 32 + j;
ansr = 0;
ansr = r;
ansr[i][a[i]] = i;
ansr[i][c] = ansr[i + 1][elxor ^ a[i] ^ c];
ansr[n - 1][0] = 0;
ansr[n - 1][1] = 0;
ansr[n - 1][a[n - 1]] = n - 1;
ansup[r] = max(ansup[r], ans[l][r]);
answer += (sum[min((ll)n, cursz + cur)] - sum[cur]) * curk;
answer += 2 * abs((wh1->second - wh2->second) * v);
answer += 2 * ans[d] * d;
answer += a;
answer += a[i] * i - sum;
answer += ans[mask].first / n * (cur - i);
answer += best.top();
answer += calc(gr[edges[i].first], gr[edges[i].second]);
answer += connect_e[i].ans;
answer += cur * (cur - 1) / 2;
answer += curadd;
answer += curflow;
answer += curk;
answer += d[all - 1] * maxf[all - 1];
answer += flow;
answer += get(wht, n - curkv, cur);
answer += getans(nextv, curv, go(nextv, gr[nextv][nexte]));
answer += goods[p[i]].second;
answer += kv * (kv - 1) / 2;
answer += kv[cur][wht];
answer += kv[i][a[i]] - kv[min(n, i + k + 1)][a[i]];
answer += m - lastx;
answer += max(maxb - minb + 1, (ll)0);
answer += maxy + 1;
answer += now.first;
answer += poss[cur];
answer += q.top().first;
answer += solve(q1, kq1);
answer += solve(q2, kq2);
answer += solve(q3, kq3);
answer += solve(q4, kq4);
answer += son->with0.get(-c[cur][i]);
answer += step * (l + pr) / 2;
answer -= d[n - 1];
answer = ((ll) - 1e9) * ((ll)1e9);
answer = (answer * 2) % MOD;
answer = (answer + curans) % MOD;
answer = (answer + small * samem1 + small * big) % MOD;
answer = (answer - curans + MOD) % MOD;
answer = -1;
answer = -inf;
answer = 0;
answer = 1;
answer = abs(a.x - b.x);
answer = abs(answer);
answer = ans;
answer = answer + (ll)n * (n - 1) * (n - 2) / 6 ;
answer = cnv[whcnv].x * x + cnv[whcnv].y * y;
answer = curans + 1;
answer = getans(0, 0, n);
answer = inf;
answer = inters;
answer = km;
answer = kv;
answer = m * 1e9 + 100500;
answer = make_pair(p[i], p[j]);
answer = max(answer, (ll)maxtop[j][k] * maxdown[j][k]);
answer = max(answer, ans);
answer = max(answer, ans[c]);
answer = max(answer, ans[i][j]);
answer = max(answer, cnv[whcnv].x * x + cnv[whcnv].y * y);
answer = max(answer, conv[i]->get(x, y));
answer = max(answer, curans);
answer = max(answer, curmax);
answer = max(answer, hx[c]);
answer = max(answer, kv[a[i]]);
answer = max(answer, lastd + 1);
answer = max(answer, maxd[cur] + maxd[gr[cur][i]] + 1);
answer = max(answer, mind[cur][4]);
answer = max(answer, profit);
answer = max(answer, root[a]->get(c, a));
answer = max(answer, root[b]->get(c, b));
answer = max(answer, x * y);
answer = min(answer, ans);
answer = min(answer, curans);
answer = min(answer, kvrev);
answer = min(answer, max(ans[i][j], H) + dist[i][j]);
answer = min(answer, w[pr]);
answer = n + 2;
answer = n;
answer = s.pop();
answer = sum + 2 * answer;
answer = sum[r] - sum[l];
answer ^= edges[gr[cur][i].e];
answer ^= lenx[i];
answer ^= leny[i];
answer++;
answer--;
answer.push_back(answer[0]);
answer.push_back(i);
answer.push_back(tans(n, -1));
answer.resize(0);
answer1 += cursum;
answer[0] = 10;
answer[0] = true;
answer[gr[cur][i].id] = make_pair(cur, gr[cur][i].v);
answer[id] = make_pair(re[id].second, re[id].first);
answer[id] = re[id];
answer[kans++] = '+';
answer[kans++] = '-';
answer[kans++] = cur;
answer[kans++] = sidetochar[i];
answer[q[cur].id] = i + 1;
answer[wh].push_back(i + 1);
answer[wh].push_back(p[i].id);
answerall[IT + 1][m] = answer;
answerw = mins * sumq;
answerwhi = i;
answerx = curx;
answery = cury;
answh = 0;
answh = wh;
ansx = -1;
ansx = a.id;
ansy = -1;
ansy = b.id;
arrsum[t][dir][id] = tsum(curs, id);
as[i] = a;
as[n + 1] = '0';
as[n] = '0';
assert(!used);
assert((!Owon) || (!Xwon));
assert((int)answer.size() == m);
assert(a >= 0 && b >= 0);
assert(abs(det) > eps);
assert(ans <= len);
assert(ans[k - 1] >= 1);
assert(ansx != -1);
assert(b != NULL);
assert(builds[i].size() == comps[i].size());
assert(can(costs[l]));
assert(cnt + 1 < maxn);
assert(cnt < treesize - 100);
assert(cnt == kv[i]);
assert(cur != NULL && cur != null);
assert(cur != NULL);
assert(cur == n * n - n / 2);
assert(cur->p != NULL && cur->p != null);
assert(cur->p != NULL);
assert(cur->p == pr);
assert(cur->p->p != NULL);
assert(curk == 0);
assert(curw <= w);
assert(f(a) == 0);
assert(false);
assert(freopen("avl.in", "r", stdin));
assert(freopen("avl.out", "w", stdout));
assert(freopen("balls.in", "r", stdin));
assert(freopen("balls.out", "w", stdout));
assert(freopen("bit.in", "r", stdin));
assert(freopen("bit.out", "w", stdout));
assert(freopen("bit2.in", "r", stdin));
assert(freopen("bit2.out", "w", stdout));
assert(freopen("chinese.in", "r", stdin));
assert(freopen("chinese.out", "w", stdout));
assert(freopen("connect.in", "r", stdin));
assert(freopen("connect.out", "w", stdout));
assert(freopen("convex.in", "r", stdin));
assert(freopen("convex.out", "w", stdout));
assert(freopen("convexoid.in", "r", stdin));
assert(freopen("convexoid.out", "w", stdout));
assert(freopen("disconnected.in", "r", stdin));
assert(freopen("disconnected.out", "w", stdout));
assert(freopen("drawing.in", "r", stdin));
assert(freopen("drawing.out", "w", stdout));
assert(freopen("exp.in", "r", stdin));
assert(freopen("exp.out", "w", stdout));
assert(freopen("flow2.in", "r", stdin));
assert(freopen("flow2.out", "w", stdout));
assert(freopen("globalcut.in", "r", stdin));
assert(freopen("globalcut.out", "w", stdout));
assert(freopen("hex.in", "r", stdin));
assert(freopen("hex.out", "w", stdout));
assert(freopen("inverse.in", "r", stdin));
assert(freopen("inverse.out", "w", stdout));
assert(freopen("jungle.in", "r", stdin));
assert(freopen("jungle.out", "w", stdout));
assert(freopen("linkcut.in", "r", stdin));
assert(freopen("linkcut.out", "w", stdout));
assert(freopen("mail.in", "r", stdin));
assert(freopen("mail.out", "w", stdout));
assert(freopen("matan.in", "r", stdin));
assert(freopen("matan.out", "w", stdout));
assert(freopen("mostfar.in", "r", stdin));
assert(freopen("mostfar.out", "w", stdout));
assert(freopen("nearest.in", "r", stdin));
assert(freopen("nearest.out", "w", stdout));
assert(freopen("party.in", "r", stdin));
assert(freopen("party.out", "w", stdout));
assert(freopen("product.in", "r", stdin));
assert(freopen("product.out", "w", stdout));
assert(freopen("quadratic.in", "r", stdin));
assert(freopen("quadratic.out", "w", stdout));
assert(freopen("rendezvous.in", "r", stdin));
assert(freopen("rendezvous.out", "w", stdout));
assert(freopen("reverse.in", "r", stdin));
assert(freopen("reverse.out", "w", stdout));
assert(freopen("robots.in", "r", stdin));
assert(freopen("robots.out", "w", stdout));
assert(freopen("rollback.in", "r", stdin));
assert(freopen("rollback.out", "w", stdout));
assert(freopen("simplex.in", "r", stdin));
assert(freopen("simplex.out", "w", stdout));
assert(freopen("smoking.in", "r", stdin));
assert(freopen("smoking.out", "w", stdout));
assert(freopen("sqrt.in", "r", stdin));
assert(freopen("sqrt.out", "w", stdout));
assert(get(a, b, c));
assert(get1(cur));
assert(go(0, -1) == 0);
assert(go(i));
assert(gr[cur].size() == fl[cur].size());
assert(i < n);
assert(id < b->size);
assert(it != segments.end());
assert(kv2 > 0);
assert(last[best] >= place);
assert(maxj == nx[i]);
assert(minh != 4 * n);
assert(n <= 200000);
assert(oure != -1);
assert(p[i].y <= p[i + 1].y);
assert(pr != -1);
assert(prpr != -1);
assert(q.empty());
assert(scanf("%*c%c", &command) == 1);
assert(scanf("%Lf%Lf", &p[i].x, &p[i].y) == 2);
assert(scanf("%c%d%d\n", &c, &a, &b) == 3);
assert(scanf("%d", &NT) == 1);
assert(scanf("%d", &a) == 1);
assert(scanf("%d", &a[i]) == 1);
assert(scanf("%d", &k) == 1);
assert(scanf("%d", &kv) == 1);
assert(scanf("%d", &m) == 1);
assert(scanf("%d", &m));
assert(scanf("%d", &n) == 1);
assert(scanf("%d%d", &a, &b) == 2);
assert(scanf("%d%d", &n, &m) == 2);
assert(scanf("%d%d", &n, &m));
assert(scanf("%d%d", &p.x, &p.y) == 2);
assert(scanf("%d%d", &x, &y) == 2);
assert(scanf("%d%d", &xc, &yc) == 2);
assert(scanf("%d%d", &y[i], &x[i]) == 2);
assert(scanf("%d%d%d", &a, &b, &c) == 3);
assert(scanf("%d%d%d", &t, &l, &r) == 3);
assert(scanf("%d%d%d%d", &a, &b, &n, &m) == 4);
assert(scanf("%d\n", &k) == 1);
assert(scanf("%s", s) == 1);
assert(scanf("%s%d%d", command, &x, &y) == 3);
assert(scanf(LLD LLD, &p.x, &p.y) == 2);
assert(scanf(LLD LLD, &p[i].x, &p[i].y) == 2);
assert(simplex(n + m + 1, m, n + m + 1, m + 1));
assert(size > 0);
assert(tree[ct][1].sum == sumwas);
assert(wh != -1);
assert(which[cur].size() == 1);
assert(whme != -1);
assert(x + z == h32);
assert(y1[i] == y2[i]);
b += a;
b += wb;
b = (lower_bound(v.begin(), v.end(), b, cmph) - v.begin());
b = _b;
b = b / a;
b = comp[b];
b = find(b);
b = fl[cur][i];
b = i;
b = next(next(b, n), n);
b = norm(b);
b = p[(*root[b])[0]];
b = up[b][k];
b >>= 1;
b--;
b1[i] = b;
b[0] = 0;
b[i] = code(strlen(s));
b[i].id = i;
b[i].point += t[i][j] * kv[j];
b[i].point = 0;
b[i].prob += t[i][j];
b[i].prob = 0;
b[next[i]] = 1;
back = NULL;
back = back->next;
back = new tel(back, x);
bad();
bad.pop();
bad[i][j] = true;
bas[i] = n + i;
bas[y] = x;
begin = i + 1;
begin = i;
begin++;
best = cur;
best = q.top().second;
best.pop();
best.push(sum[i + 1] - cur.top());
bestans = curans;
bestanswer = 1e9;
bestanswer = curanswer;
bestanswer = maxf - minf;
bestmatch = 0;
bestmatch = cntmatch(cube);
bestmatchans = "";
bestmatchans = string(answer, answer + kans);
bestmatchcube = cube;
bestmatchcube = got;
bestsq = sq;
bfs();
bitset<32> ans[maxn], was[maxn];
bitset<maxn> isl[maxn];
bitset<maxsize> can[maxn][maxn];
bl = minpl / BSZ;
bmax[bl] = max(bmax[bl], sz[cur]);
bmax[bl] = -1;
bmax[minbl] = max(bmax[minbl], sz[cur]);
bmax[minbl] = -1;
bmin[bl] = k + 1;
bmin[bl] = min(bmin[bl], sz[cur]);
bmin[minbl] = k + 1;
bmin[minbl] = min(bmin[minbl], sz[cur]);
bo = (bo + 1) % (10 * maxn * maxn);
bo = 0;
bo = 2.5 * maxn;
bo++;
bool Owon = false;
bool Xwon = false;
bool alive[maxn];
bool ans = false;
bool ans = gauss(n, 2 * n);
bool ans[maxn];
bool ans[maxn][maxn][2];
bool ansfound, cycled, cornered, forked;
bool answer = true;
bool answer[maxn];
bool atob(pnode l, pnode r)
bool bad(tp a, tp b)
bool bad[maxn][maxn];
bool calc(int l, int r)
bool calc(int l, int r);
bool can = true;
bool can(int a, int b)
bool can(int kv)
bool can(int m)
bool can(int mask)
bool can(int q)
bool can(ld time)
bool can(ll maxt)
bool can(ll t)
bool can0 = true;
bool can1 = true;
bool can[maxmask];
bool can[maxn];
bool can[maxn][maxk];
bool can[maxn][maxn];
bool can[maxt];
bool cand = j > 0;
bool canh = true;
bool canl = i > 0;
bool canmask[maxk];
bool cann(int mask, int id)
bool canr = i < xs.size() - 1;
bool canu = j < ys.size() - 1;
bool canv = true;
bool check(double xc, double yc)
bool check(pt a, int i)
bool check2(pt a, pt b)
bool cmp(tp a, tp b)
bool cmph(int a, int b)
bool colored[maxn][maxn];
bool cut = false;
bool doall()
bool dobest(int a, int b)
bool exist[maxk];
bool find = false;
bool forward;
bool found = true;
bool found;
bool gauss(int a[][maxn], int n, int m)
bool gauss(int n, int m)
bool go(int cur)
bool go(int cur, int curans)
bool go(int cur, int pr)
bool go(int l, int r, int nl, int nr)
bool go(int x, int y, int sx, int sy)
bool go(int x, int y, int sx, int sy);
bool go(ll b, ll a)
bool good = false;
bool good = regood.back();
bool good(int f, int s)
bool good(pt a, pt b, pt c, pt d)
bool good[maxn];
bool inq[maxk];
bool inq[maxv];
bool intersection = false;
bool is0, is1, is2;
bool isempty = false;
bool isend;
bool isme = false;
bool like[maxn];
bool live[maxn], was[maxn];
bool minus = false;
bool move(int x, int y, int sx, int sy)
bool need[maxn];
bool not_val(ll p, int x, int y, int z)
bool now[maxn];
bool npr[1000000];
bool ok = false;
bool ok = true;
bool ok;
bool operator<(te a, te b)
bool operator<(st a, st b)
bool operator==(ptd a, ptd b)
bool q[maxn];
bool res = false;
bool res = go(a, b % a);
bool result = gauss(ma, n, n + 1);
bool result = true;
bool reverse;
bool rotated;
bool same = true;
bool set;
bool setnear(int x, int y, bool t)
bool sett[maxn];
bool take[maxn];
bool used = false;
bool used[20];
bool used[maxn];
bool was = 0;
bool was = false;
bool was2 = false;
bool was;
bool was[2 * maxn * maxn];
bool was[20];
bool was[maxn * maxn];
bool was[maxn], used[maxn];
bool was[maxn];
bool was[maxn][maxn], used[maxn][maxn];
bool was[maxn][maxn], was2[maxn][maxn];
bool was[maxn][maxn];
bool was[maxn][maxn][maxn];
bool wascalc[maxn][maxn], memcalc[maxn][maxn];
bool wascur = false;
bool wasgo[maxn][maxn][maxn], memgo[maxn][maxn][maxn];
bord[i] = i + 1;
bounds.push_back(tb(pt(x1, y1), pt(x1, y2)));
bounds.push_back(tb(pt(x1, y1), pt(x2, y2)));
bounds.push_back(tb(pt(x1, y2), pt(x2, y2)));
bounds.push_back(tb(pt(x2, y1), pt(x1, y1)));
bounds.push_back(tb(pt(x2, y1), pt(x1, y2)));
bounds.push_back(tb(pt(x2, y2), pt(x2, y1)));
break;
bs[i] = b;
bs[m + 1] = '0';
bs[m] = '0';
bsqrt = b + 1;
buf[len] = 0;
build(i / KB);
build[i].id = i;
builds[i].push_back(i);
builds[whmerge1].push_back(builds[whmerge2][i]);
c += wc;
c /= gcd;
c = -(n.x * p1.x + n.y * p1.y);
c1 = es[cur][i].a;
c1 = p[c1];
c2 = es[cur][i].b;
c2 = p[c2];
c[a].push_back(t);
c[a].push_back(w);
c[b].push_back(t);
c[b].push_back(w);
c[cur] = curc;
calc(l, r);
calc(root);
calc2(log1);
calcans(realo[x], realo[x2]);
calct(0, -1);
calct(gr[cur][i], cur);
can = can && (canv || canh);
can = false;
can[0] = inf;
can[0] = true;
can[cur].push_back(cnt);
can[i] = false;
can[i][0] = true;
can[i][j] = can[i][j] && (abs(sq1) + abs(sq2) == sqall);
can[i][lvl] = true;
can[j] = false;
can[j][i] = can[i][j];
can[k + cup + 1] |= (t >> kvup);
can[k + cup] |= ((t & mod) << (32 - kvup));
can[k + cup] |= t;
can[nextm] = true;
canall[0] = 1;
canall[k + cup + 1] |= (t >> kvup);
canall[k + cup] |= ((t & mod) << (32 - kvup));
canall[k + cup] |= t;
canans[0] |= t;
canans[k - cup - 1] |= ((t & mod) << (32 - kvdown));
canans[k - cup] |= (t >> kvdown);
canans[k - cup] |= t;
canmask[mask] = can(mask);
cc[a].push_back(c);
cc[b].push_back(c);
center.x = center.x / (answer.size() - 1);
center.y = center.y / (answer.size() - 1);
cerr << "Case #" << T << endl;
cerr << "This is log file" << endl;
cerr << "cant" << endl;
cerr << "created" << endl;
cerr << "df" << endl;
cerr << "end: " << (double)clock() / CLOCKS_PER_SEC << endl;
cerr << "forks.size=" << forks.size() << endl;
cerr << "get answer " << endl;
cerr << "m now " << m << endl;
cerr << "mid: " << (double)clock() / CLOCKS_PER_SEC << endl;
cerr << "mid: " << cntnodes << " nodes " << endl;
cerr << "move " << i << endl;
cerr << "now " << x << " max " << maxlvl << endl;
cerr << "sdf" << endl;
cerr << "total " << cntnodes << " nodes " << endl;
cerr << RAND_MAX << endl;
cerr << T << endl;
cerr << ansv << ' ' << ansh << ' ' << ansb << endl;
cerr << answer << endl;
cerr << cnt << endl;
cerr << endl;
cerr << fixed << -answer << endl;
cerr << fixed << sqrt(mind) << endl;
cerr << getdist(answerx, answery) << endl;
cerr << s << "null" << endl;
cerr.flush();
cerr.precision(5);
ch[last++] = ts(x, y);
ch[t[i] - 'a'].push_back(i);
change(a, b);
char a1[maxlen], a2[maxlen], a3[maxlen], a4[maxlen];
char a[256];
char a[maxn], b[maxn];
char a[maxn];
char a[maxn][maxn];
char ans[1 << 26];
char ans[maxn][maxn];
char answer[2006];
char as[MAX], bs[MAX];
char buf[1000];
char buf[100];
char c = s[0];
char c = s[i + 1];
char c1, c2;
char c;
char ch;
char command;
char command[10];
char cur = inp[curch];
char dir;
char dir[3];
char getsymb()
char inp[50];
char m[20];
char maxc = 'a';
char name[maxn];
char p[100][100];
char p[10][10];
char p[20][maxn];
char p[maxn][maxm];
char p[maxn][maxn];
char pl[maxn][maxn];
char rot(char c)
char s[100005];
char s[105];
char s[200005];
char s[200];
char s[2][maxn];
char s[3000][10];
char s[40];
char s[4];
char s[50];
char s[MAXN];
char s[maxk];
char s[maxn * 2];
char s[maxn], t[maxn];
char s[maxn];
char s[maxn][20];
char s[maxn][maxn];
char side1[maxn][5], side2[maxn][5];
char side;
char t;
char t[20];
check(*itprev, *itnext);
check(*itprev, s[-p[i].id]);
check();
check(a, b);
check(arrsum[0][dir][i], arrsum[1][dir][n - 1 - j]);
check(arrsum[0][dir][n - 1 - i], arrsum[1][dir][j]);
check(begin, i - 1);
check(cur->link[wh].second, s, curc + 1, len);
check(cur.first, cur.second);
check(cx - 1, cy - 1, need);
check(cx - 1, cy, -need + 1);
check(cx, cy - 1, need * 2 - 1);
check(cx, cy - 1, need * 2);
check(cx, cy - 1, need);
check(cx, cy, -(need * 2 - 1));
check(cx, cy, -(need * 2 - 2));
check(cx, cy, -need + 1);
check(i);
check(root, i, -1, 5, 0, i);
check(st[sts - 1] + 1, i - 1);
check(st[sts - 1], i);
check(sum - l, y[1].size() - i + 1, l);
check(sum - r, y[1].size() - i + 1, r);
check_bounds(x, y);
check_cycles(x, y);
cin >> MOD >> l >> r >> k;
cin >> NT;
cin >> Y >> B;
cin >> a >> b >> mod;
cin >> a >> b;
cin >> a >> m;
cin >> a;
cin >> a[i][j];
cin >> a[i][n + m + 1];
cin >> b;
cin >> c;
cin >> command >> a >> b;
cin >> command;
cin >> h21 >> h31 >> h41 >> h32 >> h42 >> h43;
cin >> job[i].s >> job[i].t >> job[i].c;
cin >> l1 >> r1 >> l2 >> r2;
cin >> m0 >> m1 >> m2;
cin >> n >> a >> d;
cin >> n >> k >> h;
cin >> n >> k;
cin >> n >> l >> k;
cin >> n >> l >> r;
cin >> n >> l >> v1 >> v2;
cin >> n >> m >> k;
cin >> n >> m >> w >> b >> g;
cin >> n >> m;
cin >> n >> p;
cin >> n >> t;
cin >> n >> u >> r;
cin >> n >> wking >> wrook1 >> wrook2 >> bking;
cin >> n;
cin >> p[i + 1][j + 1];
cin >> s >> a >> b >> c;
cin >> s >> t;
cin >> s;
cin >> t >> v;
cin >> t;
cin >> v1 >> v2 >> v;
cin >> ver >> side >> x;
cin >> ver >> side;
cin >> w >> h;
cin >> x1 >> x2 >> a >> b;
cin >> x;
cin >> x[i] >> y[i] >> r[i];
cnk[0] = 1;
cnk[i] = divmod((cnk[i - 1] * (i + k)) % MOD, (ll)i);
cnt -= last.second;
cnt = (s[wh][i] == s[wh][i + len] ? cnt + 1 : 0);
cnt = 0;
cnt++;
cnt1[a[k - 1]]++;
cnt2[a[2 * k - 1]]++;
cnt2[a[2 * k - 2]]++;
cnt2[a[k - 1]]--;
cntO = 0;
cntO++;
cntX = 0;
cntX++;
cnt[i][j] = timer;
cnt[j][i] = timer;
cntgo = 0;
cntgo++;
cntnodes++;
cntvertex++;
cnv.push_back(cnv[0]);
cnv.push_back(p[0]);
cnv.push_back(p[i]);
cnv.resize(0);
color(i, j);
comp *a = new comp[n / 2];
comp *b = new comp[n / 2];
comp *ra = new comp[n / 2];
comp *rb = new comp[n / 2];
comp W = comp(cos(2 * M_PI / MAX), sin(2 * M_PI / MAX));
comp a[MAX], b[MAX], c[MAX];
comp pa[MAX], pb[MAX], pc[MAX];
comp w1[MAX], w2[MAX];
comp[i].id = -1;
comp[i].id = i;
comp[i].v = 0;
comp[next] = curcomp;
compress(root);
comps[i].push_back(i);
comps[whmerge1].push_back(comps[whmerge2][i]);
conf = f[i];
const double eps = 0.5;
const double eps = 1e - 6;
const double eps = 1e - 7;
const double eps = 1e - 8;
const double eps = 1e - 9;
const double inf = 1e12;
const double inf = 1e15;
const double inf = 1e9;
const double ln2 = log(2);
const double ln3 = log(3);
const int ALL = (1 << BST2) - 1;
const int BS = 1300;
const int BST2 = 5;
const int BSZ = 1 << S2;
const int BSZ = 32;
const int BSZ = sqrt(maxn);
const int CLOSE = -1;
const int CLOSE = 1;
const int DOWN = 1;
const int DOWN = 3;
const int E = 'e' - 'a';
const int LEFT = 2;
const int M32 = (1 << 5) - 1;
const int MASK = BSZ - 1;
const int MAX = 1 << 18;
const int MAX = 1 << 19;
const int MAX = 18;
const int MAXLOG = 17;
const int MAXN = 4100;
const int MAXTIME = 86400;
const int MAX_IT = 1e5;
const int MAX_TIME = 1.5e9;
const int MOD = (1 << 30);
const int MOD = 1000000000;
const int MOD = 1000000007;
const int MOD = 1000000009;
const int MOD = 1000002013;
const int MOD = 1024523;
const int MOD = 11192869;
const int MOD = 777777777;
const int OPEN = 0;
const int OPEN = 1;
const int PRODUCT = 0;
const int QUERY = 1;
const int RIGHT = 0;
const int S2 = 5;
const int SIDE_B = 0;
const int SIDE_D = 4;
const int SIDE_F = 5;
const int SIDE_L = 1;
const int SIDE_R = 3;
const int SIDE_U = 2;
const int UP = 0;
const int UP = 1;
const int XOR = (1 << 26) - 1;
const int allisgood = 2;
const int arrsz = maxn + 5;
const int begin = 0;
const int elxor = (0 ^ 1 ^ 2);
const int every = (1 << 10) - 1;
const int hst = 239017;
const int hst1 = 17239;
const int hst2 = 239017;
const int inf = 1000000000;
const int inf = 1e4;
const int inf = 1e9 + 100;
const int inf = 1e9 + 5;
const int inf = 1e9 + 9;
const int inf = 1e9;
const int inf = 2e9 + 9;
const int inf = 2e9;
const int leftside = 6;
const int max_bound = 2e7;
const int maxa = 40005;
const int maxc = 100005;
const int maxdir = 10005;
const int maxe = 100005;
const int maxel = 200;
const int maxgoal = 11;
const int maxk = (1 << maxn) + 5;
const int maxk = 1 << maxn;
const int maxk = 100005;
const int maxk = 105;
const int maxk = 150;
const int maxk = 16;
const int maxk = 17;
const int maxk = 22;
const int maxk = 5010;
const int maxk = 505;
const int maxk = 62;
const int maxkey = 45;
const int maxkg = 2.1 * maxn;
const int maxkv = 22000;
const int maxlen = 4e5;
const int maxm = 1000005;
const int maxm = 100005;
const int maxm = 1e4 + 4;
const int maxm = 200005;
const int maxm = 250005;
const int maxm = 300;
const int maxm = maxn * maxn;
const int maxmask = (1 << 21);
const int maxmask = 1 << 24;
const int maxmem =
const int maxn = 1 << 17;
const int maxn = 1000005;
const int maxn = 1000006;
const int maxn = 100005;
const int maxn = 10005;
const int maxn = 1005;
const int maxn = 100;
const int maxn = 102;
const int maxn = 105;
const int maxn = 12;
const int maxn = 130005;
const int maxn = 1505;
const int maxn = 152;
const int maxn = 155;
const int maxn = 16005;
const int maxn = 1606;
const int maxn = 1e5 + 5;
const int maxn = 1e6 + 6;
const int maxn = 2 * 505;
const int maxn = 2000005;
const int maxn = 200005;
const int maxn = 20005;
const int maxn = 2000;
const int maxn = 2005;
const int maxn = 2006;
const int maxn = 205;
const int maxn = 20;
const int maxn = 210;
const int maxn = 21;
const int maxn = 2505;
const int maxn = 25;
const int maxn = 2e3 + 4;
const int maxn = 2e5 + 5;
const int maxn = 2e6 + 6;
const int maxn = 300005;
const int maxn = 30005;
const int maxn = 3005;
const int maxn = 300;
const int maxn = 305;
const int maxn = 32;
const int maxn = 37;
const int maxn = 400005;
const int maxn = 40005;
const int maxn = 4004;
const int maxn = 4005;
const int maxn = 405;
const int maxn = 40;
const int maxn = 500005;
const int maxn = 50005;
const int maxn = 5000;
const int maxn = 5005;
const int maxn = 505;
const int maxn = 55;
const int maxn = 6005;
const int maxn = 605;
const int maxn = 65;
const int maxn = 70005;
const int maxn = 72;
const int maxn = treesize * 2 + 5;
const int maxn = treesize;
const int maxnsmall = 5005;
const int maxs = 3005;
const int maxsize = 15;
const int maxss = 27000005;
const int maxst = 20;
const int maxsum = 200;
const int maxt = (maxn + 31) / 32;
const int maxt = 100005;
const int maxt = 505;
const int maxt = 63;
const int maxv = 1005;
const int maxx = 1 << 20;
const int maxx = 1e5 + 5;
const int maxx = 1e6 + 6;
const int maxx = 60000;
const int rightturn = 8;
const int sz = 8;
const int treesize = (1 << 17);
const int treesize = 1 << 17;
const int treesize = 1 << 18;
const int treesize = 1 << 19;
const int treesize = 1e7;
const int treesize = 2e6;
const int treesz = 1 << 17;
const int tryleft = 3;
const ld eps = 1e - 10;
const ld eps = 1e - 5;
const ld eps = 1e - 7;
const ld eps = 1e - 8;
const ld eps = 1e - 9;
const ld inf = 3e18;
const ld max_bound = 1e8;
const ld max_x = 1e16;
const ll MAX = 1 << 17;
const ll MOD = 1000000007LL;
const ll W = (ll)powmod(root, (mod - 1) / MAX, mod) % mod;
const ll inf = (1ULL << 63) - 1;
const ll inf = 1e15;
const ll inf = 1e18;
const ll inf = 1e9;
const ll inf = 2e10;
const ll inf = 2e9;
const ll infll = 1e18;
const ll linf = 1000000000000000000LL;
const ll llinf = 1e18;
const ll llinf = 6e18;
const ll maxk = 17;
const ll maxw = (1LL << 41) - 1;
const ll mod = 1000000007;
const ll mod = 786433;
const ll root = 10;
const ll wh2 = ((ll)50626) * 50626;
const string ideal = "....GGGG............abcd";
cont b[maxn];
continue;
conv[cur]->add(&p, 1);
conv[cur]->add(conv[i]->p, cursz);
conv[cur]->rebuild();
conv[i]->n = 0;
convex *conv[20];
convex(int kv)
copy(a, a + l - 1, b, b + l - 1);
copy(r[i], r[i] + count[i] - 1, l[i], l[i] + count[i] - 1);
cornered = true;
cornld[i][j + 1] = max(cornld[i][j + 1], cornld[i][j]);
cornld[i][j] = -inf;
cornld[l][i + 1] = max(cornld[l][i + 1], curans);
cornlu[i + 1][j] = max(cornlu[i + 1][j], cornlu[i][j]);
cornlu[i][j + 1] = max(cornlu[i][j + 1], cornlu[i][j]);
cornlu[i][j] = -inf;
cornlu[r][i + 1] = max(cornlu[r][i + 1], curans);
cornrd[i][j] = -inf;
cornrd[l][i] = max(cornrd[l][i], curans);
cornru[i + 1][j] = max(cornru[i + 1][j], cornru[i][j]);
cornru[i][j] = -inf;
cornru[r][i] = max(cornru[r][i], curans);
correct(grc[cur][i].id);
cost = -1;
cost = 0;
cost++;
cost[a].push_back(c);
cost[b].push_back(c);
cost[s[0] - 'a'] = c;
costs[i] = c;
count1 += cnt1[i];
count2 += cnt2[i];
count_it = (count_it + 1) & every;
cout << "-1" << endl;
cout << "/" << dir[i];
cout << "/" << endl;
cout << "1\n" << (i * i) << endl;
cout << "Bounded" << endl;
cout << "DRAW\n";
cout << "FIRST\n";
cout << "First" << endl;
cout << "NO SOLUTION" << endl;
cout << "NO" << endl;
cout << "NO\n";
cout << "No solution" << endl;
cout << "Not found!!!!!!" << endl;
cout << "SECOND\n";
cout << "Second" << endl;
cout << "Unbounded" << endl;
cout << "YES" << endl;
cout << "YES\n";
cout << "\
cout << "df" << endl;
cout << "fn " << fn << endl;
cout << "k " << k << endl;
cout << "no solution" << endl;
cout << "no" << endl;
cout << "now " << cube << endl;
cout << "sakjoghik\n";
cout << "total " << cntgo << " calls " << endl;
cout << "with0: " << endl;
cout << "without0: " << endl;
cout << (-2) / 4 << ' ' << (-2) % 4 << endl;
cout << ((uint)(1 << 30) >> b) - 1 << endl;
cout << (2 * n - 1) * p << endl;
cout << (a + b - 1) / b << ' ' << a - b + 1 << endl;
cout << (ansk[n] * powmod(MAX, mod - 2, mod)) % mod << endl;
cout << (answer + 1) % MOD << endl;
cout << (answer == 0 ? -1 : answer) << endl;
cout << (answer >= 0 ? answer : "IMPOSSIBLE") << endl;
cout << (answer[n] ? "YES" : "NO") << endl;
cout << (can ? "YES" : "NO") << endl;
cout << (can ? "Yes" : "No") << endl;
cout << (double)answer * 6 / n / (n - 1) / (n - 2) << endl;
cout << (k * it->second - i) << endl;
cout << (kv == 0 ? "Yes" : "No") << endl;
cout << (ld)answer / 12 << endl;
cout << (mina == inf ? -1 : mina) << endl;
cout << (result ? "YES" : "NO") << endl;
cout << (sum * sum2) % mod << endl;
cout << -1 << endl;
cout << 0 << ' ' << 0 << endl;
cout << 0 << endl;
cout << 1 << endl << 0 << ' ' << r[1] << endl;
cout << 1 << endl;
cout << 2 * (n - 1) - answer + 1 << endl;
cout << 2 * (n - 1) - answer + 2 << endl;
cout << 5 << endl;
cout << IT << endl;
cout << M_PI * r[0] * r[0] << endl;
cout << a - b + d << endl;
cout << a << ' ' << b << ' ' << s << endl;
cout << a.id << ' ' << b.id << endl;
cout << a.with0;
cout << a.without0 << endl;
cout << a[ansp] << ' ' << ansq << endl;
cout << acur << endl;
cout << ans + maxans << endl;
cout << ans - 1 << endl;
cout << ans << endl;
cout << ans << endl; ;
cout << ans2 + min(mr12, mr22) << endl;
cout << ans2 << ' ' << mr12 << ' ' << mr22 << endl;
cout << ans[0][0][n][m] << endl;
cout << ans[0][1] << endl;
cout << ans[cannot][can] << endl;
cout << ans[k - 1] - 1 << endl;
cout << ans[km - 1] << endl;
cout << ans[n - 1] << endl;
cout << ans[n] << endl;
cout << ansv  + ansh - ansb << endl;
cout << answer + sum[n] << endl;
cout << answer - (ll)n * m << endl;
cout << answer - (t == 1LL) << endl;
cout << answer - ex[n - 1] << endl;
cout << answer << endl;
cout << answer;
cout << answer[n] << endl;
cout << answers.first.x << ' ' << answers.first.y << endl;
cout << answers.second.x << ' ' << answers.second.y << endl;
cout << answery << ' ' << answerx << endl;
cout << answh << endl;
cout << b1 + b2 + b3 + b4 + b5 + b6 + b7 << endl;
cout << bestans << endl;
cout << d[0][n] << endl;
cout << d[n - 1] << endl;
cout << endl;
cout << ex[n - 1] << endl;
cout << fib(dmax) << endl;
cout << first << ' ' << second << ' ' << third << endl;
cout << fixed << a[i][b] << " bas = " << bas[i] << endl;
cout << fixed << a[res][b] << " bas = " << bas[res] << endl;
cout << fl[c1][i] + min(mr1, mr2) << endl;
cout << gcd(a, b) << endl;
cout << i + 1 << ' ';
cout << i << ' ';
cout << k[1][m][0] << endl;
cout << k[4] + k[3] + (k[2] * 2 + k[1] + 3) / 4 << endl;
cout << kar.size() - (k - t.size() - 1);
cout << l + 1 << endl;
cout << l;
cout << maxa << endl;
cout << maxans << endl;
cout << maxdist + 1 << ' ' << (answer + MOD) % MOD << endl;
cout << maxsum << endl;
cout << min(n, n + 1 - cnt / 2) << endl;
cout << min1 << ' ' << min0 << endl;
cout << mindx + mindy << endl;
cout << minx <<' ' << miny << endl;
cout << n * p << endl;
cout << n - (k - 1);
cout << n - 1 - 2 << endl;
cout << n - 1 << endl;
cout << n - i << endl;
cout << n << endl;
cout << now << endl;
cout << p << endl;
cout << p1 + 1 << ' ' << p2 + 1 << endl;
cout << p[wh1].x << ' ' << p[wh1].y << endl;
cout << p[wh2].x << ' ' << p[wh2].y << endl;
cout << powmod(a, k * it->second - i) << ' ' << b << endl;
cout << r << endl;
cout << res.first + res.second << endl;
cout << s << " 0 0\n";
cout << s << ' ' << 0 << ' ' << 0 << endl;
cout << s.x << ' ' << s.y << endl;
cout << sum - ans[0][full(0)] << endl;
cout << sz << endl;
cout << t << "null" << endl;
cout << tab << "NULL" << endl;
cout << x2 << endl;
cout.precision(2);
cout.precision(20);
cur *= i;
cur += cnty(cx, cy);
cur += cv;
cur += diffy(cy);
cur += get(i, bound);
cur -= A;
cur -= m;
cur = (cur % curp + curp) % curp;
cur = (cur * cur) % 2010;
cur = (cur + (ll)get_sum(l, r) * t) % MOD;
cur = (cur + curp) % curp;
cur = -1;
cur = 0;
cur = 1;
cur = copy(cur);
cur = cur * i;
cur = cur + 4;
cur = cur + curp * euclid(curp, p[i]) * (a[i] - cur);
cur = cur - 1;
cur = cur ^ from[cur];
cur = cur->p;
cur = from[cur];
cur = get_right(cur, x);
cur = gr[cur][from[cur]].v;
cur = i;
cur = merge(l, r);
cur = merge(new tnode(make_pair(0, v)), cur);
cur = new tnode(*cur);
cur = next.id + 1;
cur = next;
cur = next[cur];
cur = r;
cur = t;
cur = wh[a[begin]];
cur = wh[a[i]];
cur >>= 1;
cur++;
cur--;
cur->ans += cur->to_push;
cur->ans = min(cur->x, min(getans(cur->l), getans(cur->r)));
cur->ans.first += cur->to_push;
cur->f += f;
cur->how[curch] = make_pair(curstr, maxp);
cur->how[curch].second = i - 1;
cur->is0 = get0(cur->l) || get0(cur->r) || (cur->x == 0);
cur->is1 = get1(cur->l) || get1(cur->r) || (cur->x == 1);
cur->is2 = get2(cur->l) || get2(cur->r) || (cur->x == 2);
cur->isend = true;
cur->kv = 0;
cur->kv++;
cur->l = A;
cur->l = NULL;
cur->l = change(cur->l, cl, cm, x, y);
cur->l = cutleft(cur->l);
cur->l = make(cl, cm);
cur->l = make_splay(l, m);
cur->l = make_splay(l, m, a);
cur->l = null;
cur->l = p;
cur->l->p = cur;
cur->l->reverse ^= true;
cur->l->set = true;
cur->l->y = cur->y;
cur->link.push_back(make_pair(to_find, new tnode));
cur->min = min(min(cur->l->min, cur->r->min), cur->x);
cur->next[curch] = new tnode;
cur->next[curch] = x;
cur->p = pp;
cur->push();
cur->r = C;
cur->r = NULL;
cur->r = change(cur->r, cm + 1, cr, x, y);
cur->r = make(cm + 1, cr);
cur->r = make_splay(m + 1, r);
cur->r = make_splay(m + 1, r, a);
cur->r = p;
cur->r->p = cur;
cur->r->reverse ^= true;
cur->r->set = true;
cur->r->y = cur->y;
cur->reverse = false;
cur->set = false;
cur->set = true;
cur->size = 1 + cur->l->size + cur->r->size;
cur->size = 1 + getsize(cur->l) + getsize(cur->r);
cur->size = getsize(cur->l) + getsize(cur->r) + 1;
cur->sum = b[cl];
cur->sum = cur->l->sum + cur->r->sum;
cur->sum = y;
cur->to_push += t;
cur->to_push = 0;
cur->x += cur->to_push;
cur->x = min(cur->x, t);
cur->x = x;
cur->x.first += cur->to_push;
cur->y = newy;
cur.dir = newdir;
cur.f0 = (l.f0 + get_ith(r, len)) % MOD;
cur.f1 = (l.f1 + get_ith(r, len + 1)) % MOD;
cur.pop();
cur.resize(0);
cur.x = a[nnext] * dx[cur.dir] + cur.x;
cur.x1 += inf;
cur.x1 /= 2;
cur.x2 += inf;
cur.x2 /= 2;
cur.y = a[nnext] * dy[cur.dir] + cur.y;
cur.y1 += inf;
cur.y1 /= 2;
cur.y2 += inf;
cur.y2 /= 2;
cur.z = a[nnext] * dz[cur.dir] + cur.z;
cur1 += a[i];
cur1 = cur1 + v2;
cur1 = cur1 - 4 * kvar(3, 4);
cur1 = cur1 - v1;
cur1++;
cur2 += a[i];
cur2++;
cur3 += a[i];
cur3 = cur3 - 4;
cur3 = cur3 - 6;
cur = -1;
curB += x[j];
cur[beg / KB][i / KSMB] = -1;
cur[beg / KB][i / KSMB] = j;
cur[beg / KB][i / KSMB]++;
curadd = r[i].r;
curadd--;
curans += add[x][y];
curans += ans[cur][mask - mm];
curans += ans[p[c1]][full(p[c1]) - getmask(p[c1], c1)];
curans += ans[p[c2]][full(p[c2]) - getmask(p[c2], c2)];
curans += c[cur][j];
curans += calc(l, i - 1, i) + calc(i + 1, r, i);
curans += calc(l, i - 1, whmax) + calc(i + 1, r, whmax);
curans += getans(p[fst], p[snd], p[trd]);
curans = (curans * powmod(j + 1, cur - last)) % MOD;
curans = (have[n][i]) % MOD;
curans = (last * have[n][kv]) % MOD;
curans = -inf;
curans = 0;
curans = 1;
curans = max(curans, (ll)0) + getsum(l, i, r, i + 1);
curans = max(curans, a[curx][cury]);
curans = oldans;
curans = sum;
curans++;
curans.first = max(curans.first, t.first);
curans.second = max(curans.second, t.second);
curanswer[curans] = p[cur];
curch = 0;
curch++;
curcolor = 0;
curcolor++;
curcomp = 0;
curcomp++;
curcost += cost[s[j] - 'a'];
curf = (cur * i) - cur;
curfrom = mid;
curgo >>= 1;
curgr.push_back(j);
curgr.resize(0);
curh = curh + h;
curh = max(curh, (ll)a[curst] + h);
curj = m - 1;
curk += sob[i].second;
curk += sobx[i][j].t;
curk += soby[i][j].t;
curk = 0;
curk++;
curk--;
curkv += (1LL << (cur + 1));
curkv -= (1LL << cur);
curkv++;
curkv--;
curl += r[i].r;
curl = a[curlid];
curl = curr - x;
curl = -r[i].r;
curlen += m - lastx;
curlen += n - lastx;
curlid++;
curmax = max(curmax + sum[i - 1], 0.0);
curmax = max(curmax, h[j]);
curmin = bmin[curbl];
curminxb = min(curminxb, cur.x);
curminyb = min(curminyb, cur.y);
curp += sz[gr[cur][i]];
curp = curp * mods[i];
curp = curp * p[i];
curpath.push_back(gr[cur][i]);
curpath.resize(0);
curpts.clear();
curpts.insert(pt(0, -inf));
curpts.insert(pt(0, inf));
curpts.insert(sob[i].obj);
curr = a[currid];
curr = curl + x;
currid++;
currmq->push_back(cur, hx[cur]);
curs.clear();
curs.erase(it);
curs.insert(a[i].second);
cursize += a[cur];
cursize += cursize - 1;
curspeed[i] = comp[i].v;
curspeed[whmerge1] += comp[comps[whmerge2][i]].v;
curst++;
cursum += a[i];
cursum += c[i][j];
cursum += w[j];
cursum += x[i];
cursum[i] = build[i].s;
cursum[whmerge1] += build[builds[whmerge2][i]].s;
cursz *= 2;
curt += kv[cur];
curt += t;
curv[0][0][0][0] = 1;
curw += curadd + r[i].r;
curx += i;
curx += x;
curx = -1e8 + 1;
curx = curx + dx[whgo] * curgo;
curx = i;
curx = p[i].x;
curx = -1;
cury -= 1;
cury -= 1e6;
cury = cury + dy[whgo] * curgo;
cury = j;
cury++;
cury = -1;
cut(a, b);
cv = v[z] - a;
cv = v[z] - b;
cv = v[z] - c;
cv = v[z] - d;
cx += dx[d[i]];
cx++;
cy += dy[d[i]];
cy++;
cycled = true;
cyph mina[maxn][maxst];
cyph next = getlr(cur, cur + k);
d += ((ll)gr[i]) * (gr[i] - 1) / 2;
d += wd;
d = __gcd(d, h[i]);
d = __gcd(d, maxw);
d = __gcd(d, w[i]);
d.push_back(j);
d.push_back(maxx + 5);
d.resize(0);
d.resize(d.size() - 2);
d1[cur1]--;
d1[i] *= 2;
d2[cur2]--;
d2[i] *= 2;
d[0] = 0;
d[0] = 1;
d[0] = new deque<int, MAX> ;
d[0][0] = 1;
d[S] = 0;
d[cur] = curd;
d[gr[cur][i].v] = d[cur] + 1;
d[gr[cur][i].v] = d[cur] + gr[cur][i].c;
d[gr[cur][i]] = curd + c[cur][i];
d[gr[cur][i]] = d[cur] + 1;
d[gr[cur][i]] = d[cur];
d[grr[cur][i]] = d[cur] + 1;
d[i] = inf;
d[i][j][k] = d[i][j][k - 1];
d[j] = d[cur] + dist(pts[j] - pts[cur]);
d[j][t] = min(d[j][t], d[j][i] + d[i][t]);
d[n][0] = 0;
d[ncount++] = new deque<int, MAX>(d[ver]);
d[next.x][next.y] = d[cx][cy] + gr[cx][cy][i].second;
d[next] = d[cur] + 1;
d[s] = 0;
d[t[i]] = 0;
d[x][y] = lastd + 1;
d[x][y] = lastd;
data[x - add] += t;
deathtime = div0(cursum[i], curspeed[i]);
decompose(0, 0, next);
decompose(gr[cur][i], cur, currmq);
decompose(gr[cur][i], cur, next);
deep++;
deep--;
del(id1[
del.pop();
delete b;
delete[] a;
delete[] b;
delete[] e;
delete[] ra;
delete[] rb;
deque<pair<int, int> > o;
deque<int, MAX>* d[maxn];
deque<pair<T*, T*>, n - 1> *in;
deque()
deque(deque<T, 0> *d)
deque(deque<T, n> *d)
df[cur] = curdf;
dic.pb(buf);
dicsz.pb(dic.back().size());
dinic();
dinitc();
dir[ndir] = s.substr(last, parbegin - last);
discharge(cur);
dist = d(p[i] - p[j]);
dist[i][j] = inf;
dist[n][m] = 0;
dist[ni][nj] = dist[curx][cury] + 100;
dmax = (cur * dmax - r + cur - 1) / cur;
dn = d(n);
doall(0);
donext(T);
double A1 = b.x - a.x;
double A2 = c.x - a.x;
double Ax = x2 - x1;
double Ay = y2 - y1;
double B1 = b.y - a.y;
double B2 = c.y - a.y;
double Bx = x3 - x4;
double By = y3 - y4;
double Cx = x3 - x1;
double Cy = y3 - y1;
double T = T0;
double T0 = 100000;
double a[maxn][maxn];
double ans = -1;
double ans = 0;
double ans[maxgoal][maxgoal];
double ans[maxn];
double answer = 0;
double answer = solve(n, m);
double bestans = ans;
double c;
double cura = 0;
double curans = ans;
double curans = ans[i];
double curmax = 0;
double curv[maxt][2][maxgoal][maxgoal];
double d[maxn];
double d[maxv];
double dd = A1 * B2 - B1 * A2;
double dd = Ax * By - Bx * Ay;
double deathtime = inf;
double del = a[y][x];
double delta = 0.997;
double det = a.n.x * b.n.y - a.n.y * b.n.x;
double dist = d(c2 - c1);
double dn = d(n);
double dt = (endtime - begintime) / k;
double dt = Cx * By - Bx * Cy;
double dx = C1 * B2 - B1 * C2;
double dy = A1 * C2 - C1 * A2;
double f0, f1, s0, s1;
double get(int cur, int d)
double getangle(pt a, pt b)
double getans(pt a, pt b, pt c)
double intersect(tp a, tp b)
double l = 0;
double l = f(x);
double l = r[i] * r[i] - (xx - x[i]) * (xx - x[i]);
double l, r;
double len() const
double lx[3], rx[3], x[3], y[3], r[3];
double m = (l + r) / 2;
double maxo = eps;
double maxtime = 0;
double mergetime = inf;
double minb = 1;
double mindist = inf;
double mino = inf;
double mn = a[i][x];
double mn = a[m][bas[i]];
double mn = a[res][x];
double next;
double now = 0;
double nx = x * cos(a) - y * sin(a);
double ny = x * sin(a) + y * cos(a);
double otn[maxkg];
double p1[maxn], p2[maxn], osp1[maxn], osp2[maxn];
double pix, piy;
double pr = 0;
double r = 200 * 100 * 10;
double r1 = d(a - c1);
double r2 = d(a - c2);
double sina = sqrt(1 - cosa * cosa);
double solve(int n, int m)
double step = 5e - 6;
double sum = 0;
double sum[maxn];
double t = curans + ln2;
double t = curans + ln3;
double t = dt / dd;
double t;
double ver = cur.wh[i].second * 1.0 / sum;
double x = 0;
double x = a.x;
double x, y, r;
double x, y;
double x1 = (double)(a.x + b.x) / 2;
double x2 = x1 - (b.y - a.y);
double x3 = (double)(c.x + b.x) / 2;
double x4 = x3 - (b.y - c.y);
double x;
double x[maxk], y[maxk];
double xc = (double)(np[i].x + np[j].x) / 2;
double xc, yc;
double y1 = (double)(a.y + b.y) / 2;
double y2 = y1 + (b.x - a.x);
double y3 = (double)(c.y + b.y) / 2;
double y4 = y3 + (b.x - c.x);
double yc = (double)(np[i].y + np[j].y) / 2;
dowith();
dowith(dl);
dowith(dr);
dowith(nextp);
dowith(son);
dowith(ul);
dowith(ur);
dowith(x, y);
down--;
down[b] = min(down[b], height[c]);
down[cur] = min(down[cur], down[grc[cur][i].v]);
down[i] = height[i];
dp[0][5] = 0;
dt[j] = 0;
dt[t] = min(dt[t], dt[cur] + timed[cur][t][i]);
dump(now, deathtime);
dump(now, mergetime);
e = _e;
e.erase(make_pair(a, b));
e1[i].push_back(x);
e2[i].push_back(x);
e[i + (k - j - 1)][i + j] = 1;
e[i + 1] = make_pair(a, b);
e[j + i][i + (k - j - 1)] = 1;
e[ke++] = make_pair(a, b);
e[ken++] = edges[i];
e[ken++] = pp[i];
e[m].l = d(p[j] - p[i]);
e[m].v1 = i;
e[m].v2 = j;
e[make_pair(a, b)] = i;
ed[ke].id = a;
ed[ke].id = b;
ed[ke].id = i;
ed[ke].l = i;
ed[ke].l = wasq[a];
ed[ke].l = wasq[i];
ed[ke].r = i;
ed[ke].r = m + 2;
edges.push_back(make_pair(cur, base[0]));
edges.push_back(make_pair(cur, base[i]));
edges.push_back(tedge(a, b, c));
edges[ke++] = tedge(a, b, e[make_pair(a, b)], i);
edges[ke].first--, edges[ke].second--;
else
else R1[3] = -1;
else R2[3] = -1;
else a = min(a, b);
else a[i][j] = (a[i - 1][j - 1] ^ a[i - 1][j + 1]);
else add(pt(x, y));
else addto(t, -1, cur);
else adjj[d] = -1;
else aft[i] = i;
else ans = 22;
else ans[0][1] = 0;
else ans[i] = 0;
else ans[i][j] += ans[i - 1][j] / 2;
else ans[i][j] += ans[i][j - 1] / 2;
else ans[i][j] = '.';
else ans[i][j] = 'X';
else ans[i][j] = 1 + ans[j][next[i]];
else ans[i][j] = ans[i - 1][j];
else ans[i][j] = inf;
else ans[kv0][kv1 - 1][0] = 1;
else ans[next[0][i]][i] = 2;
else ans[x][y] = '.';
else ansl[i][1] = 0;
else ansr[i][1] = 0;
else answer *= kempty;
else answer += max(abs(curx), abs(cury));
else answer = pr * k - 1;
else answer = r.pop();
else answer ^= ans[a];
else answer[grc[cur][i].id] = make_pair(grc[cur][i].v, cur);
else b[i / 2] = p[i];
else can++;
else check(begin, n - 1);
else check(st[sts - 1] + 1, i - 1);
else cout << "Furlo" << endl;
else cout << "NO\n";
else cout << *d[ver]->right() << endl;
else cout << ans0 + ans1 + ans2 + 1 << endl;
else cout << mina << ' ' << minb << ' ' << 0 << endl;
else cur->p->r = cur;
else cur->r = doerasemax(cur->r);
else curans.first += (-curv);
else curr++;
else curs -= c[i];
else d[ver]->pop_right();
else d[ver]->push_right(wh);
else edges.push_back(make_pair(x + 1, y));
else edges.push_back(make_pair(x - 1, y));
else edges.push_back(make_pair(x, y + 1));
else edges.push_back(make_pair(x, y - 1));
else g[i] = 2;
else go(i, i);
else if ((cur->p->l == cur) ^ (cur->p->p->l == cur->p))
else if (Xwon) printf("X won\n");
else if (a >= maxx) answer ^= 1;
else if (can1) printf("2\n");
else if (cur > 0 && cur == maxt)
else if (cur > 0)
else if (d == 2)
else if (g1 != 1 && g2 != 1) g[i] = 1;
else if (h == 2 * lvl) answer = 0;
else if (i == 1) w[i].id = n + 1;
else if (isempty) printf("Game has not completed\n");
else if (j == n) a[i][j] = a[i - 1][j - 1];
else if (j > 0) upd(ans[i][j - 1][0], ans[i][j][kz]);
else if (kvtrue(i, j) == p[i][j]) setnear(i, j, false);
else if (kvtrue(x, y) == p[x][y]) ok = setnear(x, y, false);
else if (kvtrue(x, y) == p[x][y]) setnear(x, y, false);
else if (n == 5 && m == 3) printf("%d\n", 960);
else if (n == 5 && m == 4) printf("%d\n", 960);
else if (n == 6 && m == 3) printf("%d\n", 1440);
else if (n == 6 && m == 4) printf("%d\n", 1440);
else if (n >= 7 || m >= 5) printf("%d\n", 0);
else if (n >= prev + cur) answer = 1;
else if (p[i].x < 0 && p[i].y < 0) q3[kq3++] = abs(p[i]);
else if (p[i].x < 0 && p[i].y > 0) q2[kq2++] = abs(p[i]);
else if (p[i].x > 0 && p[i].y < 0) q4[kq4++] = abs(p[i]);
else kar.push_back(make_pair(C, i + 1));
else kv1++;
else kz++;
else l = m1;
else l = m;
else l = mid;
else l.push(x);
else last++;
else m[i] = domax(root);
else ma[i][j] = b[i - j];
else maxr[i][j] = maxr[i][j + 1];
else maxup[j][i] = maxup[j - 1][i];
else mc[i] = domax();
else minlen = min(minlen, p[i].len);
else mods.push_back(pm[i]), ost.push_back(b % pm[i]);
else mr1 = max(mr1, fl[c1][i]);
else next = min(next, time[b]);
else next = time[a];
else printf("%d\n", answer[i]);
else printf("%d\n", get_sum(1, 0, treesize - 1, l, r));
else printf("-1");
else printf(".");
else printf("0\n");
else printf("1\n");
else printf("C-dur\n");
else printf("Draw\n");
else printf("No\n");
else printf("no\n");
else qt.push(curt);
else r = m;
else r = mid;
else return -1;
else return 0;
else return DOWN;
else return a;
else return kv2[l];
else return y;
else return ys[cy] - ys[cy - 1];
else set(1, 0, treesize - 1, ry1, ry2 - 1, -1);
else set(y, false);
else sleep = t[cur + 1 + can];
else st[kv++] = s[i];
else sum[x >> S2]--;
else tree[cur].ans = getans(cur * 2) + getans(cur * 2 + 1);
else tree[i].l = null;
else tree[i].r = null;
else upd(ans[next[i][t]][t], ans[i][j] + 2);
else upd(ans[next[j][E]][aft[i]], ans[i][j] + j - i);
else upd(answer, ans[i][j][kz]);
else updold(ans[next[j][E]][aft[i]], ans[i][j] + j - i);
else w[i].id = i - 1;
else xlines.push_back(tline(y1, x1, x2));
empty = n * m + 1;
empty = wh * m + pos + 1;
end_time = 1.8 * CLOCKS_PER_SEC + clock();
end_time = clock() + 6.5 * CLOCKS_PER_SEC;
eo = (eo + 1) % (10 * maxn * maxn);
eo = 0;
eo = 1;
eo = bo;
eo++;
eprintf("Test %d\n", testId);
erase(pp[i].id, false);
erasemax(root[wh]);
es[x].push_back(edges[i]);
ev[k + 1].l = n;
ev[k + 1].r = n + 1;
ev[k + 1].wh = 0;
ev[k].l = -1;
ev[k].r = 1;
ev[k].wh = 0;
ex++;
ex[0] = gr[0][i].maxf;
ex[cur->u] -= f;
ex[cur->v] += f;
exist[mask[i]] = true;
exit(0);
expose(a);
expose(b);
ey++;
f = _f;
f = null;
f1[i].push_back(x);
f2[i].push_back(x);
f[0] = 1;
f[0] = tf(1, 0);
f[1] = 1;
f[nfact] = i;
f[nfact] = n;
fact(d);
fact(n / d);
fact(n);
fact[0] = 1;
fclose(f);
ff = 1;
ff = pow(first, a);
fflush(stdout);
fft(a, MAX, 1, w1, pa);
fft(a, n / 2, k * 2, w, ra);
fft(ans0, MAX, 1, w1, res[0]);
fft(ans1, MAX, 1, w1, res[1]);
fft(b, MAX, 1, w1, pb);
fft(b, n / 2, k * 2, w, rb);
fft(c, MAX, 1, w2, pc);
fft(res[k], MAX, 1, w2, ansk);
find = true;
first = 0;
first = m1;
first = m2;
first = nfirst;
fl[a].push_back(c);
fl[b].push_back(c);
fl[cur][i] -= t;
flow += maxf[all - 1];
flow = dfs(0, inf);
for (; curkv < n + 1; cur++)
for (; j < p; j += i) npr[j] = true;
for (bking.x = 0; bking.x < n; bking.x++)
for (char ch = 'a'; ch <= 'z'; ch++)
for (i = KB - KSMB; i >= 0 && b[i + beg].r >= x; i -= KSMB)
for (int IT = 0; ; IT++)
for (int IT = 0; IT < 100; IT++)
for (int IT = 0; IT < 1; IT++)
for (int IT = 0; IT < 5; IT++)
for (int IT = 0; IT < 8; IT++)
for (int IT = 0; IT < 90; IT++)
for (int IT = 0; IT < m; IT++)
for (int IT = 0; IT < n; IT++)
for (int IT2 = 0; IT2 < MAX_IT; IT2++)
for (int ITx = 0; ITx < a; ITx++)
for (int ITy = 0; ITy < b; ITy++)
for (int T = 0; T < NT; T++)
for (int T = 0; T < q; T++)
for (int T = 1; T <= NT; T++)
for (int a = 1; a <= n / 2; a++)
for (int b = 1; b <= 3; b++)
for (int b = 1; b <= m / 2; b++)
for (int b1 = 0; b1 <= maxr; b1++)
for (int b2 = 0; b2 <= maxr; b2++)
for (int b7 = 0; b7 < maxlen - x - y - z; b7++)
for (int beg = n - 1; beg >= 0; beg--)
for (int c = 'a'; c <= 'z'; c++)
for (int c = 0; c < 3; c++) if (c != a[i])
for (int c1 = 0; c1 < 10; c1++)
for (int c1 = 0; c1 < 3; c1++)
for (int c1 = 1; c1 <= 3; c1++)
for (int c2 = 0; c2 < 10; c2++) nextmany[i][c1][c2] = 2;
for (int c2 = 0; c2 < 10; c2++) nextmany[i][c1][c2] = inf;
for (int c2 = 1; c2 <= 3; c2++)
for (int ck = 0; ck < k; ck++)
for (int cst = 1; cst <= st[n]; cst++)
for (int cur = 0; cur < n; cur++)
for (int cur = minbl * BSZ; ; cur++) if (sz[cur] == curmin)
for (int d = 0; d < 4; d++)
for (int d = 0; d < 6; d++)
for (int d = min(n, m); d > 0; d--)
for (int dir = 0; dir < 4; dir++)
for (int dir = 0; dir < 6; dir++)
for (int f = 1; f <= 3; f++)
for (int fst = 0; fst < n; fst++)
for (int h = H; h > 0; h--)
for (int i = 'a'; i <= 'z'; i++) ans[i] = -inf;
for (int i = 0, j = 0; i < n / 2; i++, j += k)
for (int i = 0; (1LL << i) <= t; i++)
for (int i = 0; cur < n && q[cur].x <= pr; i++)
for (int i = 0; i + len < n; i++)
for (int i = 0; i < (int)a.size(); i++)
for (int i = 0; i < (int)answer.size(); i++)
for (int i = 0; i < (int)bounds.size(); i++)
for (int i = 0; i < (int)builds[whmerge2].size(); i++)
for (int i = 0; i < (int)comps[whmerge2].size(); i++)
for (int i = 0; i < (int)cur.size(); i++)
for (int i = 0; i < (int)edges.size(); i++)
for (int i = 0; i < (int)es[cur].size(); i++)
for (int i = 0; i < (int)forks.size() - 2; i++)
for (int i = 0; i < (int)gr[0].size(); i++)
for (int i = 0; i < (int)gr[best].size(); i++)
for (int i = 0; i < (int)gr[cx][cy].size(); i++)
for (int i = 0; i < (int)ids.size(); i++)
for (int i = 0; i < (int)in.size(); i++)
for (int i = 0; i < (int)sob.size(); i++)
for (int i = 0; i < (int)to_del.size(); i++)
for (int i = 0; i < (int)tree[cur].size(); i++)
for (int i = 0; i < (int)votr[x].size(); i++)
for (int i = 0; i < (int)xs.size(); i++)
for (int i = 0; i < (int)ys.size(); i++)
for (int i = 0; i < (n + 1) / 2; i++)
for (int i = 0; i < 100; i++)
for (int i = 0; i < 10; i++) if (i != E && next[0][i] != -1)
for (int i = 0; i < 10; i++) next[n - 1][i] = -1;
for (int i = 0; i < 12; i++) scanf("%d", &a[i]);
for (int i = 0; i < 2 * n - 1; i++) scanf("%d", &r[i]);
for (int i = 0; i < 2 * n; i++)
for (int i = 0; i < 2010; i++)
for (int i = 0; i < 2010; i++) next[i][0] = (i * i) % 2010;
for (int i = 0; i < 20; i++) if (conv[i]->n != 0)
for (int i = 0; i < 24; i++)
for (int i = 0; i < 24; i++) got += '*';
for (int i = 0; i < 24; i++) got[inpord[i]] = getsymb();
for (int i = 0; i < 24; i++) h = h * 239 + cur[i];
for (int i = 0; i < 26; i++) if (i != s[curpos] - 'a')
for (int i = 0; i < 26; i++) link[i] = NULL;
for (int i = 0; i < 26; i++) pushall(i, 1, 0, treesz - 1);
for (int i = 0; i < 27; i++)
for (int i = 0; i < 27; i++) next[i] = NULL;
for (int i = 0; i < 2; i++)
for (int i = 0; i < 3 * n; i++)
for (int i = 0; i < 3; i++)
for (int i = 0; i < 3; i++) scanf(LLD LLD, &x[i], &y[i]);
for (int i = 0; i < 4; i++)
for (int i = 0; i < 4; i++) scanf("%s", p[i]);
for (int i = 0; i < 521196; i++)
for (int i = 0; i < 6 - 1; i++) if (adjj[i] != -1)
for (int i = 0; i < 6; i++)
for (int i = 0; i < 6; i++) corn[i] = -1;
for (int i = 0; i < 6; i++) dirs[i] = i;
for (int i = 0; i < KB; i += KSMB)
for (int i = 0; i < KB; i++) b[i + beg] = p[i + beg];
for (int i = 0; i < MAX; i++)
for (int i = 0; i < MAX; i++) c[i] = pa[i] * pb[i];
for (int i = 0; i < NT; i++)
for (int i = 0; i < adj.size(); i++)
for (int i = 0; i < answer; i++)
for (int i = 0; i < answer; i++) result[i] = curanswer[i];
for (int i = 0; i < b->size; i++)
for (int i = 0; i < b1; i++) a4[i] = 'b';
for (int i = 0; i < beg * 2; i++) w[i] = (r[i] < R ? 2 : 0);
for (int i = 0; i < cnt; i++)
for (int i = 0; i < cur.wh.size(); i++)
for (int i = 0; i < cur; i++)
for (int i = 0; i < curcolor; i++) pr[i] = i, s[i] = 1;
for (int i = 0; i < curcomp; i++)
for (int i = 0; i < curcomp; i++) if (!was[i])
for (int i = 0; i < curcomp; i++) was[i] = false;
for (int i = 0; i < from[cur].size(); i++)
for (int i = 0; i < gr[c1].size(); i++)
for (int i = 0; i < gr[c1].size(); i++) if (gr[c1][i] != c2)
for (int i = 0; i < gr[c1].size(); i++) if (gr[c1][i] == c2)
for (int i = 0; i < gr[c2].size(); i++) if (gr[c2][i] != c1)
for (int i = 0; i < gr[cur].size(); i++)
for (int i = 0; i < gr[curx].size(); i++)
for (int i = 0; i < grf[cur].size(); i++)
for (int i = 0; i < grt[cur].size(); i++)
for (int i = 0; i < h21; i++) a2[i] = 'b';
for (int i = 0; i < k - 1; i++) ans += t[i].first;
for (int i = 0; i < k; i++)
for (int i = 0; i < k; i++) ans[i] = -inf;
for (int i = 0; i < k; i++) best.push(-inf);
for (int i = 0; i < k; i++) if (key[i] == t[id]) curkv++;
for (int i = 0; i < k; i++) kv[pr][i + 1] += kv[cur][i];
for (int i = 0; i < k; i++) scanf("%d", &key[i]);
for (int i = 0; i < k; i++) was[i] = -1;
for (int i = 0; i < k; i++) wh[i] = make_pair(0, i);
for (int i = 0; i < kar.size(); i++) ans += kar[i].first;
for (int i = 0; i < kc; i++)
for (int i = 0; i < kcomp; i++)
for (int i = 0; i < kcomp; i++) if (!was[i])
for (int i = 0; i < kcomp; i++) was[i] = false;
for (int i = 0; i < ke; i++)
for (int i = 0; i < ke; i++) if (!was[i])
for (int i = 0; i < kg; i++) p[i] = i;
for (int i = 0; i < km; i++)
for (int i = 0; i < km; i++) if (exist[i]) curk++;
for (int i = 0; i < km; i++) p[i] = i;
for (int i = 0; i < km; i++) was[i] = -1;
for (int i = 0; i < kp; i++)
for (int i = 0; i < kt; i++) if (was[i] == 0)
for (int i = 0; i < kv; i++)
for (int i = 0; i < kv; i++) answer = (answer * m) % mod;
for (int i = 0; i < kv; i++) p[n++] = a[i];
for (int i = 0; i < kv[cur]; i++)
for (int i = 0; i < kx; i++)
for (int i = 0; i < kx; i++) y[i] = 0;
for (int i = 0; i < ky; i++)
for (int i = 0; i < kz; i++) printf("0");
for (int i = 0; i < l; i++)
for (int i = 0; i < len; i++)
for (int i = 0; i < len; i++) ans |= (1 << (s[i] - 'a'));
for (int i = 0; i < lvl; i++)
for (int i = 0; i < m - 1; i++)
for (int i = 0; i < m; i += KB) build(i / KB);
for (int i = 0; i < m; i++)
for (int i = 0; i < m; i++) a[i][n + m] = -1;
for (int i = 0; i < m; i++) add(root, s, i, m);
for (int i = 0; i < m; i++) ans[bas[i]] = a[i][n + m + 1];
for (int i = 0; i < m; i++) ansb[i] = b[i];
for (int i = 0; i < m; i++) answer = max(answer, ansb[i]);
for (int i = 0; i < m; i++) b[m + i] = b[i];
for (int i = 0; i < m; i++) can[i] = true;
for (int i = 0; i < m; i++) go(grp[cur][i]);
for (int i = 0; i < m; i++) h[0][i] = 0;
for (int i = 0; i < m; i++) if (!was[i])
for (int i = 0; i < m; i++) if ((b[i] & mask) == 0) ans--;
for (int i = 0; i < m; i++) if (bas[i] == n + m)
for (int i = 0; i < m; i++) if (i != y)
for (int i = 0; i < m; i++) kcol += wascol[i];
for (int i = 0; i < m; i++) scanf("%d", &b[i]);
for (int i = 0; i < m; i++) scanf(LLD, &b[i]);
for (int i = 0; i < m; i++) unite(0, 3 * i + 2, 0, 3 * i);
for (int i = 0; i < m; i++) wh[b[i]] = i;
for (int i = 0; i < max(n, m); i++)
for (int i = 0; i < maxn; i++)
for (int i = 0; i < maxx; i++) last[i] = n;
for (int i = 0; i < maxx; i++) wh[i] = -1;
for (int i = 0; i < min(m, n - 2); i++)
for (int i = 0; i < n && ok; i++)
for (int i = 0; i < n * m; i++) scanf("%d", &l[i]);
for (int i = 0; i < n * n; i++) gr[i].resize(0);
for (int i = 0; i < n + 2; i++)
for (int i = 0; i < n + m; i++)
for (int i = 0; i < n + m; i++) d[i] = inf;
for (int i = 0; i < n + m; i++) was[i] = false;
for (int i = 0; i < n - 1; i++)
for (int i = 0; i < n - 1; i++) if (a[i] > maxsum)
for (int i = 0; i < n - 1; i++) scanf("%d", &p[i]);
for (int i = 0; i < n - k + 1; i++)
for (int i = 0; i < n - m + 1; i++)
for (int i = 0; i < n / 2; i++) printf("%d ", ans[i] + 1);
for (int i = 0; i < n; i++)
for (int i = 0; i < n; i++) a[2 * n + i] = a[i] + 4 * l;
for (int i = 0; i < n; i++) a[i] = b[i];
for (int i = 0; i < n; i++) a[i] = c[p[i] - 1] + r;
for (int i = 0; i < n; i++) a[i] = i + 1;
for (int i = 0; i < n; i++) a[i] = s[i] - 'a';
for (int i = 0; i < n; i++) a[i] ^= b[i];
for (int i = 0; i < n; i++) a[i][k] += p[i][j];
for (int i = 0; i < n; i++) a[n + i] = a[i] + 2 * l;
for (int i = 0; i < n; i++) a[n + i] = a[i];
for (int i = 0; i < n; i++) a[p[i] - 1] = c[i];
for (int i = 0; i < n; i++) a[y][i] /= del;
for (int i = 0; i < n; i++) add(1, 0, treesize - 1, i);
for (int i = 0; i < n; i++) add(v[i]);
for (int i = 0; i < n; i++) ans[i] = perm[i];
for (int i = 0; i < n; i++) ans[i][i + 1] = 1;
for (int i = 0; i < n; i++) ans[p[i]] = i;
for (int i = 0; i < n; i++) ansa[i] = a[i];
for (int i = 0; i < n; i++) answer += (p[i]) * (p[i + 1]);
for (int i = 0; i < n; i++) answer += rx[i] - lx[i];
for (int i = 0; i < n; i++) answer = max(answer, ansa[i]);
for (int i = 0; i < n; i++) answer[a[i].id] = bestans[i];
for (int i = 0; i < n; i++) answer[i] = -1;
for (int i = 0; i < n; i++) assert(ans[i] >= 0);
for (int i = 0; i < n; i++) assert(scanf("%d", &a[i]) == 1);
for (int i = 0; i < n; i++) b[i] = a[i];
for (int i = 0; i < n; i++) bestans[i] = ans[i];
for (int i = 0; i < n; i++) c[i] = a[i] - r;
for (int i = 0; i < n; i++) c[i] = a[i];
for (int i = 0; i < n; i++) can[i] = true;
for (int i = 0; i < n; i++) cerr << ex[i] << ' ';
for (int i = 0; i < n; i++) cerr << h[i] << ' ';
for (int i = 0; i < n; i++) check(i);
for (int i = 0; i < n; i++) cin >> a[i];
for (int i = 0; i < n; i++) cin >> a[m][i];
for (int i = 0; i < n; i++) cin >> a[n - i - 1];
for (int i = 0; i < n; i++) cin >> b[i];
for (int i = 0; i < n; i++) cin >> k[i];
for (int i = 0; i < n; i++) cin >> l[i].m;
for (int i = 0; i < n; i++) cin >> l[i].v;
for (int i = 0; i < n; i++) cin >> name[i];
for (int i = 0; i < n; i++) cin >> p[i].x >> p[i].y;
for (int i = 0; i < n; i++) cin >> p[i];
for (int i = 0; i < n; i++) cout << a[i] << ' ';
for (int i = 0; i < n; i++) cout << ans[i] + 1 << ' ';
for (int i = 0; i < n; i++) cout << ans[i] << ' ';
for (int i = 0; i < n; i++) cout << fixed << ans[i] << ' ';
for (int i = 0; i < n; i++) d[i] = MAX_TIME;
for (int i = 0; i < n; i++) d[i] = inf, was[i] = false;
for (int i = 0; i < n; i++) d[i] = inf;
for (int i = 0; i < n; i++) d[i] = n + 1;
for (int i = 0; i < n; i++) dfb[i] = df[i];
for (int i = 0; i < n; i++) from[i].resize(0);
for (int i = 0; i < n; i++) go(i);
for (int i = 0; i < n; i++) go(i, 0);
for (int i = 0; i < n; i++) good[i] = true;
for (int i = 0; i < n; i++) gr[i].resize(0);
for (int i = 0; i < n; i++) gr[i][prpr] = gr[prpr][i];
for (int i = 0; i < n; i++) gr[prpr][i] += gr[pr][i];
for (int i = 0; i < n; i++) hs.push_back(h[i]);
for (int i = 0; i < n; i++) if (!(mask & (1 << i)))
for (int i = 0; i < n; i++) if (!was[i] && d[i] < mindist)
for (int i = 0; i < n; i++) if (!was[i])
for (int i = 0; i < n; i++) if (!was[i]) color(i, -1, 0);
for (int i = 0; i < n; i++) if (!was[i]) go(i);
for (int i = 0; i < n; i++) if (!was[i]) result = false;
for (int i = 0; i < n; i++) if (!was[p[answer[i]]])
for (int i = 0; i < n; i++) if ((a[i] & mask) == 0) ans++;
for (int i = 0; i < n; i++) if (a[i] == -1)
for (int i = 0; i < n; i++) if (a[i] > 0) answer++;
for (int i = 0; i < n; i++) if (a[i] >= a[k]) answer++;
for (int i = 0; i < n; i++) if (a[res][i] > maxo)
for (int i = 0; i < n; i++) if (alive[i])
for (int i = 0; i < n; i++) if (can[i] && time[i] > maxtime)
for (int i = 0; i < n; i++) if (d[i] == inf) d[i] = -1;
for (int i = 0; i < n; i++) if (e[cur][i]) go(i);
for (int i = 0; i < n; i++) if (find(i) == a)
for (int i = 0; i < n; i++) if (live[i])
for (int i = 0; i < n; i++) if (mask & (1 << i))
for (int i = 0; i < n; i++) if (s[i] == '1')
for (int i = 0; i < n; i++) if (s[i] == 'X')
for (int i = 0; i < n; i++) if (s[i] == '|')
for (int i = 0; i < n; i++) if (sumrow[i] < 0)
for (int i = 0; i < n; i++) if (take[i])
for (int i = 0; i < n; i++) if (time[i] < maxtime - eps)
for (int i = 0; i < n; i++) if (was[i] == 0)
for (int i = 0; i < n; i++) if (wascol[i].size() > 1)
for (int i = 0; i < n; i++) if (wasq[i] != -1)
for (int i = 0; i < n; i++) krow += wasrow[i];
for (int i = 0; i < n; i++) l[i].id = i + 1;
for (int i = 0; i < n; i++) len[f[i].t].push_back(i);
for (int i = 0; i < n; i++) live[i] = true;
for (int i = 0; i < n; i++) makenew(i);
for (int i = 0; i < n; i++) minel[i] = inf;
for (int i = 0; i < n; i++) ms[i] = inf;
for (int i = 0; i < n; i++) need[i] = m;
for (int i = 0; i < n; i++) need[i] = oldneed[cur][i];
for (int i = 0; i < n; i++) next[i] = (i + 1) % n;
for (int i = 0; i < n; i++) next[i] = -1;
for (int i = 0; i < n; i++) next[i].resize(0);
for (int i = 0; i < n; i++) oldneed[cur][i] = need[i];
for (int i = 0; i < n; i++) oldst[i] = st[i];
for (int i = 0; i < n; i++) p[i + n] = p[i];
for (int i = 0; i < n; i++) p[i] = -1;
for (int i = 0; i < n; i++) p[i] = i, s[i] = 0;
for (int i = 0; i < n; i++) p[i] = i;
for (int i = 0; i < n; i++) perm[i] = i;
for (int i = 0; i < n; i++) prev[i] = (i - 1 + n) % n;
for (int i = 0; i < n; i++) printf(" %.7f", 100 * ans[i]);
for (int i = 0; i < n; i++) printf(" %d", ans[i] + 1);
for (int i = 0; i < n; i++) printf(" %d", ans[i]);
for (int i = 0; i < n; i++) printf(" %d", t[i].id);
for (int i = 0; i < n; i++) printf("%d ", ans[i] - 1);
for (int i = 0; i < n; i++) printf("%d ", ans[i]);
for (int i = 0; i < n; i++) printf("%d ", answer[i]);
for (int i = 0; i < n; i++) printf("%d ", order[i + 1] + 1);
for (int i = 0; i < n; i++) printf("%d", ans[i]);
for (int i = 0; i < n; i++) printf("%d", c[i]);
for (int i = 0; i < n; i++) printf(LLD " ", a[i]);
for (int i = 0; i < n; i++) printf(LLD " ", b[i]);
for (int i = 0; i < n; i++) printf(LLD "\n", ans[i]);
for (int i = 0; i < n; i++) r[i] = rand() % 1000000 + 5;
for (int i = 0; i < n; i++) scanf("%d", &A[i]);
for (int i = 0; i < n; i++) scanf("%d", &B[i]);
for (int i = 0; i < n; i++) scanf("%d", &a[i]), sum += a[i];
for (int i = 0; i < n; i++) scanf("%d", &a[i]);
for (int i = 0; i < n; i++) scanf("%d", &b[i]);
for (int i = 0; i < n; i++) scanf("%d", &col[i]);
for (int i = 0; i < n; i++) scanf("%d", &f[i]);
for (int i = 0; i < n; i++) scanf("%d", &last[i]);
for (int i = 0; i < n; i++) scanf("%d", &p[i]), p[i]--;
for (int i = 0; i < n; i++) scanf("%d", &s[i]);
for (int i = 0; i < n; i++) scanf("%d", &t[i]);
for (int i = 0; i < n; i++) scanf("%d", &t[i].l);
for (int i = 0; i < n; i++) scanf("%d", &v[i]);
for (int i = 0; i < n; i++) scanf("%d", &v[i].p);
for (int i = 0; i < n; i++) scanf("%d", &v[i].q);
for (int i = 0; i < n; i++) scanf("%d", &v[i].x);
for (int i = 0; i < n; i++) scanf("%d", &x[i]);
for (int i = 0; i < n; i++) scanf("%d%d", &d[i], &l[i]);
for (int i = 0; i < n; i++) scanf("%d%d", &h[i], &w[i]);
for (int i = 0; i < n; i++) scanf("%d%d", &p[i].x, &p[i].y);
for (int i = 0; i < n; i++) scanf("%d%d", &x[i], &v[i]);
for (int i = 0; i < n; i++) scanf("%d%d", &x[i], &y[i]);
for (int i = 0; i < n; i++) scanf("%s", p[i + 1] + 1);
for (int i = 0; i < n; i++) scanf("%s", p[i]);
for (int i = 0; i < n; i++) scanf(LLD, &a[i]);
for (int i = 0; i < n; i++) scanf(LLD, &t[i]);
for (int i = 0; i < n; i++) scanf(LLD, &x[i]);
for (int i = 0; i < n; i++) slink[i] = new tnode(i);
for (int i = 0; i < n; i++) sqall += p[i] * p[i + 1];
for (int i = 0; i < n; i++) st[i] = oldst[i];
for (int i = 0; i < n; i++) sum += (maxt / t[i]);
for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + a[i];
for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + h[i + 1];
for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + kv[i];
for (int i = 0; i < n; i++) sumb += t[i].b, ans[i] = 2;
for (int i = 0; i < n; i++) unite(3 * i + 2, 0, 3 * i, 0);
for (int i = 0; i < n; i++) up[i][0] = p[i];
for (int i = 0; i < n; i++) used[i] = false;
for (int i = 0; i < n; i++) v[i] = p[i + 1] - p[i];
for (int i = 0; i < n; i++) v[i] = r[i];
for (int i = 0; i < n; i++) v[i] = u[i];
for (int i = 0; i < n; i++) was[i] = -1;
for (int i = 0; i < n; i++) was[i] = false;
for (int i = 0; i < n; i++) wasq[i] = -1;
for (int i = 0; i < n; i++) wh[i] = -1;
for (int i = 0; i < n; i++) x[i + n] = x[i];
for (int i = 0; i < n; i++) x[i] = (mask >> i) & 1;
for (int i = 0; i < ndir; i++)
for (int i = 0; i < nfact; i++) if (onf[f[i]])
for (int i = 0; i < nfact; i++) onf[f[i]] = 0;
for (int i = 0; i < nfact; i++) onf[f[i]] = d;
for (int i = 0; i < nq; i++)
for (int i = 0; i < nt; i++)
for (int i = 0; i < ob.size() - 1; i++)
for (int i = 0; i < s; i++)
for (int i = 0; i < sizewas; i++) lines.push_back(lines[i]);
for (int i = 0; i < sob.size(); i++)
for (int i = 0; i < sz; i++) aarr1[i] = make_pair(inf, inf);
for (int i = 0; i < t.size(); i++) ans += t[i].first;
for (int i = 0; i < v.size(); i++) if (v[i] != prev)
for (int i = 0; i < xs.size(); i++)
for (int i = 0; i <= 2 * s; i++)
for (int i = 0; i <= answerwhi; i++)
for (int i = 0; i <= k; i++) kv[cur][i] = 0;
for (int i = 0; i <= k; i++) kv[n][i] = 0;
for (int i = 0; i <= m; i++)
for (int i = 0; i <= m; i++) a[i][n + m] = 0;
for (int i = 0; i <= m; i++) p[0][i] = 'C';
for (int i = 0; i <= m; i++) when[i] = m + 2;
for (int i = 0; i <= maxkv; i++) ans += popcount(can[i]);
for (int i = 0; i <= maxkv; i++) canans[i] = can[i];
for (int i = 0; i <= maxr; i++)
for (int i = 0; i <= n + 1; i++)
for (int i = 0; i <= n + 1; i++) if (was[job[i].id] == 0)
for (int i = 0; i <= n + m + 1; i++) a[m + 1][i] += a[m][i];
for (int i = 0; i <= n - 2; i++)
for (int i = 0; i <= n; i++)
for (int i = 0; i <= n; i++) ans[i] = -inf;
for (int i = 0; i <= n; i++) answer[i] = false;
for (int i = 0; i <= n; i++) answer[i] = inf;
for (int i = 0; i <= n; i++) can[i] = false;
for (int i = 0; i <= n; i++) cout << ans[i] << endl;
for (int i = 0; i <= n; i++) last[i] = -1;
for (int i = 0; i <= n; i++) maxr[i] = 0;
for (int i = 0; i <= n; i++) minr[i] = n + 1;
for (int i = 0; i <= n; i++) p[i][0] = 'C';
for (int i = 0; i <= t; i++)
for (int i = 0; i <= x; i += BS)
for (int i = 0; kv < n / 3; i++) if (can[i])
for (int i = 0; sum + goods[p[i]].first <= n; i++)
for (int i = 1; ; i++)
for (int i = 1; i < (int)lines.size(); i++)
for (int i = 1; i < (int)mods.size(); i++)
for (int i = 1; i < 43; i++) if (cur & (1LL << i))
for (int i = 1; i < MAX; i++) w1[i] = w1[i - 1] * W;
for (int i = 1; i < MAX; i++) w2[i] = w2[i - 1] / W;
for (int i = 1; i < b->size; i++)
for (int i = 1; i < m; i++) if (can[i])
for (int i = 1; i < m; i++) unite(0, 3 * i, 0, 3 * i - 1);
for (int i = 1; i < maxx; i++)
for (int i = 1; i < n - 1; i++)
for (int i = 1; i < n; i++)
for (int i = 1; i < n; i++) if (a[i] == a[i - 1]) kdiv2++;
for (int i = 1; i < n; i++) p[i] = p[i] + p[0];
for (int i = 1; i < n; i++) p[i] = p[i] - p[0];
for (int i = 1; i < n; i++) scanf("%d", &a[i]);
for (int i = 1; i < n; i++) unite(3 * i, 0, 3 * i - 1, 0);
for (int i = 1; i < n; i++) x[i] = (x[i - 1] * A + B) % M;
for (int i = 1; i <= 150; i++)
for (int i = 1; i <= 3; i++)
for (int i = 1; i <= 3; i++) ans[1][i][i] = 1;
for (int i = 1; i <= a[nnext]; i++)
for (int i = 1; i <= da; i++)
for (int i = 1; i <= k; i++) cout << ans[i] << ' ';
for (int i = 1; i <= m; i++)
for (int i = 1; i <= m; i++) edges[i] = rand() % INT_MAX;
for (int i = 1; i <= m; i++) if (kv[i] == 2) answer++;
for (int i = 1; i <= m; i++) last[i] = -1;
for (int i = 1; i <= m; i++) st2[i] = st2[i - 1] * hst2;
for (int i = 1; i <= n + 1; i++)
for (int i = 1; i <= n - 1; i++) printf("%d ", ans[i]);
for (int i = 1; i <= n; i++)
for (int i = 1; i <= n; i++) cout << was[i] << ' ';
for (int i = 1; i <= n; i++) f[i] = f[i - 1] * tf(i);
for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;
for (int i = 1; i <= n; i++) h[i] = 0;
for (int i = 1; i <= n; i++) if (!used[i])
for (int i = 1; i <= n; i++) if (ans[i] < ans[i - 1])
for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
for (int i = 1; i <= n; i++) scanf("%d%d", &t[i], &d[i]);
for (int i = 1; i <= n; i++) st1[i] = st1[i - 1] * hst1;
for (int i = 1; i <= n; i++) st[i] = (st[i - 1] * 2) % MOD;
for (int i = 1; i <= n; i++) st[i] = st[i - 1] * hst;
for (int i = 1; i <= x; i++) if (ans[i][x] == '?')
for (int i = 1; i <= y[1].size(); i++)
for (int i = 2; d * i <= min(n, m); i++)
for (int i = 2; i < 100; i++)
for (int i = 2; i < 105; i++)
for (int i = 2; i < 32; i++)
for (int i = 2; i < maxi; i++)
for (int i = 2; i < n; i++)
for (int i = 2; i < n; i++) ans[i] = 0;
for (int i = 2; i < n; i++) ans[i] = 2;
for (int i = 2; i < p; i++) if (!npr[i])
for (int i = 2; i <= maxx; i++)
for (int i = 2; i <= n; i++)
for (int i = 2; i <= n; i++) kv2[i] = (2 * kv2[i - 2]) % m;
for (int i = 2; i <= sqrt(n); i++)
for (int i = 30; i > 0; i--)
for (int i = 3; i <= n; i++) if (n % i == 0)
for (int i = 3; i <= p; i++)
for (int i = MAX - 1; i >= 0; i--)
for (int i = a; i <= b; i++)
for (int i = ansl; i < ansr; i++) cout << s[i];
for (int i = b->size - 2; i >= 0; i--)
for (int i = bbegin + 1; i <= n + bbegin; i++)
for (int i = begin; next[i] != begin; i = next[i])
for (int i = cur; i < n; i++)
for (int i = have + 1; i <= need; i++)
for (int i = k - 1; i < t.size(); i++) ans += t[i].first;
for (int i = kv0; i >= 0; i--)
for (int i = l + 1; i < r; i++) minp = min(minp, p[i]);
for (int i = l; i < n; i++)
for (int i = l; i <= r; i++)
for (int i = l; i <= r; i++) kvo += n - i;
for (int i = l; i <= r; i++) sum += v[i].q;
for (int i = m - 1; i >= 0; i--)
for (int i = m - 1; i >= 0; i--) if (d[i] != inf)
for (int i = m; i < n - 1; i++)
for (int i = m; i < n; i++)
for (int i = m; i >= 1; i--)
for (int i = maxn - 1; i >= 512; i--) if (ma[i][n] == 1)
for (int i = n - 1; i > 0; i--)
for (int i = n - 1; i >= 0; i -= sk + 2)
for (int i = n - 1; i >= 0; i--)
for (int i = n - 1; i >= 0; i--) if (ans[i] > 0)
for (int i = n - 2; i >= 0; i--)
for (int i = n - 3; i >= 2; i--)
for (int i = n - m + 1; i < n; i++)
for (int i = n; i < maxn; i++) x[i] = 0;
for (int i = n; i >= 0; i--)
for (int i = n; i >= 0; i--) r[i] = min(r[i + 1], minr[i]);
for (int i = n; i >= 1; i--)
for (int i = sz - 1; i >= 0; i--)
for (int i = treesize - 1; i > 0; i--)
for (int i = treesz - 1; i >= 1; i--)
for (int i = up; i <= down; i++)
for (int i = x - 1; i <= x + 1; i++)
for (int i = x - 2; i <= x + 2; i++) if (x >= 0)
for (int i = x; i < x + y + z; i++) a3[i] = 'b';
for (int i = x; i <= min(n, x + sz); i++)
for (int i = x; i >= 1; i--) if (ans[x][i] == '?')
for (int j = 0, k = 0; k <= 3 * m; k++, j = (j + 1) % m)
for (int j = 0; j + len < n; j++)
for (int j = 0; j < (int)can[i].size(); j++)
for (int j = 0; j < (int)d.size() - 1; j++)
for (int j = 0; j < (int)f1[i].size(); j++)
for (int j = 0; j < (int)sobx[i].size(); j++)
for (int j = 0; j < (int)soby[i].size(); j++)
for (int j = 0; j < 10; j++)
for (int j = 0; j < 10; j++) if (!was[j])
for (int j = 0; j < 10; j++) if (j != E && ans[i][j] != 0)
for (int j = 0; j < 10; j++) next[i][j] = next[i + 1][j];
for (int j = 0; j < 10; j++) was[j] = false;
for (int j = 0; j < 2 * n; j++)
for (int j = 0; j < 2; j++)
for (int j = 0; j < 2; j++) if (p[gr[i][j]] == i)
for (int j = 0; j < 3 * m; j++)
for (int j = 0; j < 4; j++) add(p[i][j]);
for (int j = 0; j < 4; j++) add(p[j][4 - j - 1]);
for (int j = 0; j < 4; j++) add(p[j][i]);
for (int j = 0; j < 4; j++) add(p[j][j]);
for (int j = 0; j < 4; j++) if (j != i)
for (int j = 0; j < KSMB; j++) if (c[i + j + beg].len == 0)
for (int j = 0; j < N; j++)
for (int j = 0; j < a; j++)
for (int j = 0; j < d; j++)
for (int j = 0; j < gr[c1].size(); j++) if (gr[c1][j] != c2)
for (int j = 0; j < gr[c2].size(); j++) if (gr[c2][j] != c1)
for (int j = 0; j < i; j++) swap(a[i][j], a[j][i]);
for (int j = 0; j < k; j++)
for (int j = 0; j < k; j++) if (comp[comps[i][j]].id != -1)
for (int j = 0; j < kret; j++) cur.push(to_return[j]);
for (int j = 0; j < kv; j++)
for (int j = 0; j < kv[i]; j++)
for (int j = 0; j < kv[i]; j++) scanf("%d", &keyin[i][j]);
for (int j = 0; j < l; j++) sum[j] = 0;
for (int j = 0; j < m; j++)
for (int j = 0; j < m; j++) cin >> p[i][j];
for (int j = 0; j < m; j++) if (!used[i][j] && !was[i][j])
for (int j = 0; j < m; j++) if (sumcol[j] < 0)
for (int j = 0; j < m; j++) scanf("%d", &a[i][j]);
for (int j = 0; j < m; j++) scanf("%d", &b[j]);
for (int j = 0; j < m; j++) scanf("%d", &d[i][j]);
for (int j = 0; j < m; j++) scanf("%d", &p[i][j]);
for (int j = 0; j < m; j++) was[i][j] = false;
for (int j = 0; j < maxk; j++) kv[i][j] = kv[i + 1][j];
for (int j = 0; j < n + m; j++) a[m + 1][j] -= mn * a[i][j];
for (int j = 0; j < n + m; j++) if (abs(a[i][j]) > eps)
for (int j = 0; j < n; j++)
for (int j = 0; j < n; j++) add(i + 1, j, i, j);
for (int j = 0; j < n; j++) add(i, j, i + 1, j);
for (int j = 0; j < n; j++) can[i][j] = true;
for (int j = 0; j < n; j++) can[j] = true;
for (int j = 0; j < n; j++) cin >> a[i][j];
for (int j = 0; j < n; j++) cin >> f[i][j];
for (int j = 0; j < n; j++) cout << fixed << a[i][j] << ' ';
for (int j = 0; j < n; j++) d[i][j][0] = inf;
for (int j = 0; j < n; j++) if (ans[i][j] != 0)
for (int j = 0; j < n; j++) if (cury != j)
for (int j = 0; j < n; j++) if (i != j && find(j) == b)
for (int j = 0; j < n; j++) if (i != j)
for (int j = 0; j < n; j++) if (j != ansp)
for (int j = 0; j < n; j++) if (j != i)
for (int j = 0; j < n; j++) if (j & (1 << i)) cnt++;
for (int j = 0; j < n; j++) if (len[j] == curlen)
for (int j = 0; j < n; j++) if (y[i] > y[j])
for (int j = 0; j < n; j++) kv[i] += (1 - t[j][i]);
for (int j = 0; j < n; j++) minh[i][j] = inf;
for (int j = 0; j < n; j++) scanf("%d", &p[i][j]);
for (int j = 0; j < n; j++) sum[j % l] += t[j];
for (int j = 0; j < n; j++) u[i] += v[j] * a[i][j];
for (int j = 0; j < n; j++) u[i] += v[j] * b[i][j];
for (int j = 0; j < n; j++) u[i] += v[j] * c[i][j];
for (int j = 0; j < n; j++) was[j] = false;
for (int j = 0; j < ne; j++)
for (int j = 0; j < nf; j++)
for (int j = 0; j < w; j++)
for (int j = 0; j < ys.size(); j++)
for (int j = 0; j <= 2 * s; j++)
for (int j = 0; j <= 5; j++) ans[i][j] = inf;
for (int j = 0; j <= 5; j++) if (ans[i][j] < inf)
for (int j = 0; j <= a; j++)
for (int j = 0; j <= i; j++)
for (int j = 0; j <= i; j++) if (was[j])
for (int j = 0; j <= m + 1; j++)
for (int j = 0; j <= m + 1; j++) ans[i][j] = '.';
for (int j = 0; j <= m; j++)
for (int j = 0; j <= maxkv; j++) can[j] = canall[j];
for (int j = 0; j <= maxr; j++) ans[i][j] = 0;
for (int j = 0; j <= maxr; j++) if (i != maxr || j != maxr)
for (int j = 0; j <= n; j++)
for (int j = 0; j <= n; j++) cout << (a[i][j] ? "#" : ".");
for (int j = 0; j <= n; j++) d[i][j] = inf;
for (int j = 0; j <= nm + 1; j++) ans[i][j] = inf;
for (int j = 0; j <= nm; j++)
for (int j = 1; (1 << j) <= m; j++)
for (int j = 1; j < i; j++) if (cur & (1LL << j))
for (int j = 1; j < k; j++)
for (int j = 1; j < k[i]; j++)
for (int j = 1; j < m; j++)
for (int j = 1; j < n; j++)
for (int j = 1; j <= 3; j++) if (can[f][j] == 1)
for (int j = 1; j <= 3; j++) scanf("%d", &can[i][j]);
for (int j = 1; j <= db; j++)
for (int j = 1; j <= m; j++)
for (int j = 1; j <= m; j++) ans[i][j] = '?';
for (int j = 1; j <= m; j++) ans[i][j] = p[i][j];
for (int j = 1; j <= m; j++) curd += sy[j] * d(i, j);
for (int j = 1; j <= m; j++) if (a[i][j] == '#')
for (int j = 1; j <= m; j++) if (all5(i, j))
for (int j = 1; j <= m; j++) if (ans[i][j] <= H - h)
for (int j = 1; j <= m; j++) if (ans[i][j] == '?')
for (int j = 1; j <= m; j++) if (s[j] != s[j - 1]) cnt++;
for (int j = 1; j <= m; j++) printf("%c", ans[i][j]);
for (int j = 1; j <= m; j++) printf("%c", p[i][j]);
for (int j = 1; j <= m; j++) scanf("%c", &p[i][j]);
for (int j = 1; j <= m; j++) scanf("%d", &c[i][j]);
for (int j = 1; j <= min(i + 1, s); j++)
for (int j = 1; j <= n; j++) curd += sx[j] * d(i, j);
for (int j = 31; j >= 0; j--) if (!was[i][j])
for (int j = cury + 1; j < n; j++)
for (int j = i % 2; j + 1 < 2 * n; j += 2)
for (int j = i + 1; j < (int)cur.size(); j++)
for (int j = i + 1; j < 6; j++) if (adjj[j] == adjj[i])
for (int j = i + 1; j < m; j++)
for (int j = i + 1; j < m; j++) a[i][j] /= a[i][i];
for (int j = i + 1; j < n - 1; j++)
for (int j = i + 1; j < n; j++)
for (int j = i + 1; j < n; j++) if (alive[j])
for (int j = i + 1; j < n; j++) if (d(p[i] - p[j]) < mind)
for (int j = i + 1; j < n; j++) if (n >= 4)
for (int j = i + 1; j < n; j++) if (wh[i] < wh[j]) points++;
for (int j = i + 1; j < n; j++) printf("%c", s[j]);
for (int j = i + 2; j < n; j++) if (j != i + n - 1)
for (int j = i - 1; j >= 0; j--)
for (int j = i - cur - 1; (j >= 0 && i - j <= 3 * cur); j--)
for (int j = i; j < m && p[j].l <= x; j++)
for (int j = i; j < maxn; j++)
for (int j = i; j < n; j++)
for (int j = i; j < n; j++) cnt += was[j];
for (int j = i; j <= x; j++) if (df[j] > b)cur++;
for (int j = i; j >= 0; j--) cout << ' ' << ans[j];
for (int j = i; j >= l; j--)
for (int j = kv1; j >= 0; j--)
for (int j = left; j <= right; j++) printf("%c", ans[i][j]);
for (int j = m - 1; j >= 0; j--)
for (int j = m - 1; j >= t; j--)
for (int j = m; j >= 0; j--)
for (int j = n - 1; j > i; j--)
for (int j = n - 1; j >= 0; j--)
for (int j = y - 1; j <= y + 1; j++)
for (int j = -n; j <= n; j++)
for (int k = 0; k < h; k++)
for (int k = 0; k < ksob; k++)
for (int k = 0; k < n; k++) minneed[i][j][k] = m;
for (int k = 0; k <= n; k++)
for (int k = 1; k < MAXLOG; k++)
for (int k = 1; k < maxk; k++)
for (int k = 1; k <= dc; k++)
for (int k = 1; k <= maxk; k++)
for (int k = 1; k <= n / 2; k++)
for (int k = 1; k <= n; k++)
for (int k = MAXLOG - 1; k >= 0; k--)
for (int k = cup + 1; k <= maxkv; k++)
for (int k = i +
for (int k = i; k < j; k++) sq1 += p[k + 1] * p[k];
for (int k = j + 1; k < (int)cur.size(); k++)
for (int k = j + 1; k < n; k++)
for (int k = j + 1; k < n; k++) if (n >= 5)
for (int k = j + 2; k < n; k++)
for (int k = j; k < i + n; k++) sq2 += p[k + 1] * p[k];
for (int k = maxk - 1; k >= 0; k--)
for (int k = maxk; k >= 0; k--)
for (int k = maxkv; k >= 0; k--)
for (int k = n; k >= 0; k--)
for (int kv = 0; kv < maxc; kv++)
for (int kz = 0; kz <= 2; kz++)
for (int l = 0; l + len <= n; l++)
for (int l = 0; l < n; l++)
for (int l = 0; l <= n - tr; l++)
for (int len = 1; len * 2 <= n; len++)
for (int len = 1; len < n; len++)
for (int len = 1; len <= m; len++)
for (int len = 1; len <= n; len++)
for (int len = 2; len < n; len++)
for (int len = m; len >= 1; len--)
for (int lenx = 1; lenx <= n; lenx++)
for (int ll = 0; ll <= n; ll++)
for (int ll = l; ll <= n; ll++)
for (int lvl = 0; lvl <= k; lvl++) if (!can[wh][lvl])
for (int lvl = 1; lvl < k; lvl++)
for (int m = 1; m <= 150; m++)
for (int m1 = 0; m1 < km; m1++)
for (int mask = 0; mask < 8; mask++)
for (int mask = 0; mask < km - 1; mask++)
for (int mask = 0; mask < km; mask++)
for (int mask = 0; mask < km; mask++) ans[mask] = inf;
for (int mask = 0; mask < km; mask++) ans[mask].first = 0;
for (int mask = 0; mask < km; mask++) can[mask] = false;
for (int mask = 0; mask < km; mask++) if (can[mask])
for (int mask = 1; mask < (1 << kv); mask++)
for (int mask = 1; mask < km; mask++)
for (int med = 0; med <= n; med++)
for (int med2 = 0; med2 <= m; med2++)
for (int place = n; place > 0; place--)
for (int r = l + 1; r <= n; r++)
for (int r = l; r < n; r++)
for (int s = 0; s < b; s++)
for (int s = 0; s < n; s++)
for (int s = 0; s <= n; s++)
for (int snd = fst + 1; snd < n; snd++)
for (int sz = 1; ; sz++)
for (int t = 0; t < 10; t++) if (t != E && next[i][t] != -1)
for (int t = 0; t < 10; t++) if (t != E && next[j][t] != -1)
for (int t = 0; t < 26; t++)
for (int t = 0; t < 26; t++) if (t != odd)
for (int t = 0; t < k; t++)
for (int t = 0; t < k; t++) cursum[t] += a[j][t];
for (int t = 0; t < k; t++) cursum[t] = 0;
for (int t = 0; t < m; t++)
for (int t = 0; t < maxtime; t++)
for (int t = 0; t < n; t++)
for (int t = 0; t < n; t++) dt[t] = inf;
for (int t = 0; t < r; t++)
for (int t = 0; t < xlines.size() && cand; t++)
for (int t = 0; t < xlines.size() && canu; t++)
for (int t = 0; t < ylines.size() && canl; t++)
for (int t = 0; t < ylines.size() && canr; t++)
for (int t = 0; t <= need[cur]; t++)
for (int t = 1; t <= dd; t++)
for (int t = 2; t <= maxtime; t++)
for (int t = i + 1; t <= n; t++)
for (int t = k + 1; t < n; t++) if (n >= 6)
for (int t = l; ; t++) if (maxr[t][i] > j) return t;
for (int t = n; t >= 0; t--)
for (int t2 = 1; t + t2 <= maxtime; t2++)
for (int time = MAXTIME; time > t[i]; time--)
for (int trd = snd + 1; trd < n; trd++)
for (int wh = 0; wh < (int)hs.size(); wh++)
for (int wx = 0; wx < 3; wx++)
for (int wy = 0; wy < 3; wy++)
for (int x = 0; x + 1 < (int)xs.size(); x++)
for (int x = 0; x < (int)xs.size(); x++)
for (int x = 0; x < 2; x++)
for (int x = 0; x <= n - lenx; x++)
for (int x = 1; x + 1 < (int)xs.size(); x++)
for (int x = 1; x + len - 1 <= m; x++)
for (int x2 = x + 1; x2 < (int)xs.size(); x2++)
for (int y = 0; y < (int)ys.size(); y++)
for (int y = 0; y < 2; y++)
for (int y = 0; y <= m - leny; y++)
for (int y = 0; y <= maxy; y++)
for (int y = 2; y <= 30; y++)
for (int z = 0; z < n; z++)
for (int z = y; z <= 2 * (x + y); z++)
for (ll b = 2; b * b <= n; b++)
for (ll i = 0, j = 0; i < n / 2; i++, j += k)
for (ll i = 0; i < n; i++)
for (ll i = 1; i < MAX; i++) w1[i] = (w1[i - 1] * W) % mod;
for (ll i = 1; i < MAX; i++) w2[i] = w1[MAX - i];
for (ll i = 1; i < nm; i++)
for (ll i = 1; i <= fn / k; i++)
for (ll i = 2; i < min(nold, maxr); i++)
for (ll i = 2; i <= k; i++)
for (ll i = 2; i <= maxi; i++)
for (ll i = 2; i <= n; i++)
for (ll i = 2; i <= t; i++)
for (ll i = k; i > 0; i--)
for (ll mask = 1; mask < nm; mask++)
for (ll x = 1; x * (x + 1) <= n; x++)
for (tmap::iterator it = e.begin(); it != e.end(); it++)
for (wking.x = 0; wking.x < n; wking.x++)
for (wking.y = 0; wking.y < n; wking.y++)
for (wrook1.x = 0; wrook1.x < n; wrook1.x++)
for (wrook2.x = 0; wrook2.x < n; wrook2.x++)
for(int i = 0; i < out.size(); ++i)
forked = true;
forks.resize(0);
forward = (dx[dir] == 1);
forward = (dy[dir] == 1);
found = false;
found = true;
fprintf(stderr, "%d %d\n", out[i].first, out[i].second);
fprintf(stderr, "%d/%d cases done!\n", T, NT);
fprintf(stderr, "%d/%d done\n", T, NT);
fprintf(stderr, "total %d nodes\n", cntvertex);
freopen("again.in", "r", stdin);
freopen("again.out", "w", stdout);
freopen("circles3.in", "r", stdin);
freopen("circles3.out", "w", stdout);
freopen("input.txt", "r", stdin);
freopen("invite.in", "r", stdin);
freopen("invite.out", "w", stdout);
freopen("log.in", "r", stdin);
freopen("log.out", "w", stdout);
freopen("memory.in", "r", stdin);
freopen("memory.out", "w", stdout);
freopen("multiply.in", "r", stdin);
freopen("multiply.out", "w", stdout);
freopen("necklace.in", "r", stdin);
freopen("necklace.out", "w", stdout);
freopen("output.txt", "w", stdout);
freopen("paint.in", "r", stdin);
freopen("paint.out", "w", stdout);
freopen("pollard.in", "r", stdin);
freopen("pollard.out", "w", stdout);
freopen("queens.in", "r", stdin);
freopen("queens.out", "w", stdout);
freopen("queue.in", "r", stdin);
freopen("queue.out", "w", stdout);
freopen("squares.in", "r", stdin);
freopen("squares.out", "w", stdout);
freopen("stack.in", "r", stdin);
freopen("stack.out", "w", stdout);
freopen("treestr.in", "r", stdin);
freopen("treestr.out", "w", stdout);
freopen(FILENAME ".in", "r", stdin);
freopen(FILENAME ".out", "w", stdout);
freopen(TASKNAME ".in", "r", stdin);
freopen(TASKNAME ".out", "w", stdout);
freopen(TASKNAME"-"TASKMOD".in", "r", stdin);
freopen(TASKNAME"-"TASKMOD".out", "w", stdout);
from[(cur * cur) % 2010] = cur;
from[0] = 0;
from[2] = -1;
from[gr[cur][i].v] = gr[cur][i].o;
from[gr[cur][i]] = cur;
from[i + 1] = i;
from[i + 2] = i;
from[i + 3] = i;
from[i] = -1;
from[i] = from[i - 1];
from[i] = i;
from[j] = cur;
from[mask] = lastmask;
from[next] = cur;
from[nextm] = nextfr;
from[nx[i]].push_back(i);
fs = 1;
fs = pow(second, b);
fscanf(dict, "%s", s);
fscanf(ssin, "%c", &c1);
fscanf(ssin, "%d\n", &NT);
fscanf(ssout, "%c", &c2);
ft = 1;
ft = pow(third, c);
g[0] = 0;
g[1] = 0;
g[2] = 0;
get1(cur * 2 + 1, cm + 1, cr, x));
get2(cur * 2 + 1, cm + 1, cr, l, r));
getcircle(a, b, c, x, y, r);
getline(cin, name[i]);
getline(cin, s);
getnext(curfrom, getdir(fromb, tob), curto, cure, i);
getnext(curto, getdir(curfrom, curto), curto, cure, i);
gets(buf);
gets(s);
getsize(0, 0, 0);
getsizes(0, -1);
getsizes(gr[cur][i], cur);
go();
go(0);
go(0, -1);
go(0, -1, 0, n);
go(0, -1, m);
go(0, 0);
go(0, 0, 0);
go(0, MAX, edges, ke);
go(0, i);
go(0, i, 0);
go(0, m - 1, ed, ke);
go(1);
go(1, 0, 0);
go(100, n);
go(cur + 1, maxc - kv);
go(cur - 1);
go(cur - 2);
go(e[gr[cur][i]].second);
go(e[i].first);
go(e[i].first, i);
go(faceto(returnside[i], rotleft(faceto(i, cube))));
go(faceto(returnside[i], rotright(faceto(i, cube))));
go(from[cur][i], nh, cur, curh);
go(from[n - 1], 0);
go(got);
go(gr[cur][i], cur);
go(gr[cur][i], cur, curp, curp + sz[gr[cur][i]]);
go(gr[cur][pr], cur);
go(i + 1);
go(i);
go(i, j);
go(i, j, 0);
go(i, j, false, minneed[i][j]);
go(l, m, e, ken);
go(m + 1, r, e, ken);
go(p[cur], beg);
go(u);
go(x + 1);
go(x + 1, y);
go(x + sz + 1, 1);
go(x - 1, y);
go(x);
go(x, y + 1);
go(x, y + sz);
go(x, y - 1);
go(x, y);
go1(0, -1);
go1(1, 1);
go1(i, kv);
go1(ni, nj);
go2();
go2(0, -1);
go2(0, 0, -1);
go2(gr[cur][i], cur);
go2(i, 0, -1);
goall(root, l[i], r[i]);
goc(i, -1, 0);
goend(i, -1);
gogood(base[0]);
gogood(base[i]);
gonew(i, knew++);
good = true;
good.pop();
good[n] = false;
good[next[cur]] = false;
goods.resize(0);
goods[kg++] = make_pair(cur, cnt);
got = bestmatchcube;
goto " << allisgood << "\n";
goto " << rightturn << "\n";
gr3[a][kv[a]] = gr[a].size();
gr3[next][kv[next]] = opp[cur][gr3[cur][i]];
gr[0].push_back(paired[n - 1]);
gr[0].push_back(tedge(0, cur, b, 0, wa));
gr[0].push_back(tedge(0, i + 1, a, 0, wa));
gr[0].push_back(tedge(i + 1, 0, 1, 0, gr[i + 1].size()));
gr[0].push_back(tedge(i + 1, 0, 2, 0, gr[i + 1].size()));
gr[A].push_back(B);
gr[B].push_back(A);
gr[a]++;
gr[a].push_back(b);
gr[a].push_back(i);
gr[a].push_back(ke - 1);
gr[a].push_back(make_pair(b, i + 1));
gr[a].push_back(make_pair(b, res));
gr[a].push_back(n + i);
gr[a].push_back(tedge(a, b, c, 0, wb));
gr[a].push_back(tedge(a, i + 1, 0, 0, wa));
gr[a].push_back(tedge(b, i + 1));
gr[a].push_back(tedge(b, i));
gr[a][b] += c;
gr[a][b] = 1;
gr[a][getdir(a, b)] = i + 1;
gr[b]++;
gr[b].push_back(a);
gr[b].push_back(make_pair(a, i + 1));
gr[b].push_back(make_pair(a, res));
gr[b].push_back(n + i);
gr[b].push_back(tedge(a, i + 1));
gr[b].push_back(tedge(a, i));
gr[b].push_back(tedge(b, a, 0, 0, wa));
gr[b][a] += c;
gr[b][a] = 1;
gr[b][getdir(b, a)] = i + 1;
gr[cur->v][cur->o].f -= f;
gr[cur].push_back(tedge(cur, 0, 0, 0, wb));
gr[cur].push_back(tedge(cur, n * m + 1, w, 0, wb));
gr[cur].push_back(tedge(cur, next, g, 0, wb));
gr[cur][from[cur]].f -= maxf[all - 1];
gr[cur][from[cur]].f--;
gr[cur][i].f += curflow;
gr[e[i].first].push_back(i);
gr[e[i].first][e[i].second] = 1;
gr[e[i].second].push_back(i);
gr[e[i].second][e[i].first] = 1;
gr[from[i - 1]].push_back(make_pair(i, msum[i - 1]));
gr[gr[cur][i].v][gr[cur][i].o].f -= curflow;
gr[i + 1].push_back(paired[i]);
gr[i + 1].push_back(tedge(0, 0, 0, 0, gr[0].size() - 1));
gr[i + 1].push_back(tedge(i + 1, 0, 0, 0, wb));
gr[i + 1].push_back(tedge(i + 1, a, inf, 0, wb));
gr[i + 1].push_back(tedge(i + 1, n + 1, -a, 0, wb));
gr[i].push_back(make_pair(from[i - 1], abs(msum[i - 1])));
gr[i].push_back(n + x);
gr[i].push_back(paired[i + 1]);
gr[i][0] = x;
gr[i][1] = y;
gr[id[i + 1][j]].push_back(id[i][j]);
gr[id[i][j + 1]].push_back(id[i][j]);
gr[id[i][j]].push_back(id[i + 1][j]);
gr[id[i][j]].push_back(id[i][j + 1]);
gr[last[A[i]]].push_back(i);
gr[n * m + 1].push_back(tedge(n * m + 1, cur, 0, 0, wa));
gr[n + 1].push_back(tedge(n + 1, i + 1, 0, 0, wa));
gr[n + i].push_back(a);
gr[n + i].push_back(b);
gr[n + i].push_back(x);
gr[n + x].push_back(i);
gr[n - 1].push_back(paired[0]);
gr[next].push_back(tedge(next, cur, g, 0, wa));
gr[next][gr[cur][from[cur]].o].f++;
gr[whb].push_back(wha);
gr[x1][y1].push_back(make_pair(pt(x2, y2), c));
gr[x].push_back(n + i);
gr[x][y].push_back(make_pair(i, j));
grf[b].push_back(a);
grp[cur].push_back(gr[cur][i]);
grr[a].push_back(b);
grr[b].push_back(a);
grt[a].push_back(b);
h = nh;
h.push_back(y);
h[0] = n;
h[a] = h[a] + b * st[b];
h[b] = h[b] + a * st[a];
h[cur] = curh;
h[cur] = minh;
h[i][0] = 0;
hash = hash * hst + s[i];
hash[0] = 0;
have[i][j] = (ans[i][j][0] + ans[i][j][1]) % MOD;
have[n][0]--;
have[n][kv]++;
have[n][kv]--;
height[cur] = curh;
hs.resize(0);
hs.resize(unique(hs.begin(), hs.end()) - hs.begin());
hx[a] = h;
i--, j--;
i--;
id = _id;
id1[n] = cur;
id2[m] = cur;
id[S] = 1;
id[cur] = 0;
id[i] = i;
id[i][j + 1] = cur;
id[i][j] = cur;
id[next] = 1;
ids.push_back(a[i]);
ids.push_back(b[i]);
ids.resize(unique(ids.begin(), ids.end()) - ids.begin());
if (*wh == x)
if (-a[m + 1][n + m + 1] < -eps)
if (-v < v) v = -v;
if (!(cur & (1LL << (i - j))))
if (!(cv == pt(0, 0))) kv++;
if (!(cv == pt(0, 0))) out(cur);
if (!(fscanf(ssin, "%c", &c1) == 1)) break;
if (!(scanf("%c", &c1) == 1)) break;
if (!(x < cur->x.first))
if (!(x < cur->x.first)) return upper_bound(cur->r, x);
if (!ans)
if (!ansfound) printf("Case #%d: none\n", T);
if (!can(r))
if (!can)
if (!can) continue;
if (!can[i][j % n]) continue;
if (!can[nextm] || (can[nextm] && from[nextm] > nextfr))
if (!check(i, j)) return false;
if (!check(pt(0, 0), 0)) continue;
if (!check(pts[i], 1)) continue;
if (!cmpx(p[i], p[i + n])) swap(p[i], p[i + n]);
if (!cur->is0)
if (!cur->is1)
if (!cur->is2)
if (!del.empty() && del.top() == cur.top())
if (!eq2(cur.x1, x)) cur.x1++;
if (!eq2(cur.x2, x)) cur.x2--;
if (!eq2(cur.y1, y)) cur.y1++;
if (!eq2(cur.y2, y)) cur.y2--;
if (!getnew(v[i], v[j], a, b)) continue;
if (!getnew(v[i], v[j], v[k], a, b, c)) continue;
if (!getnew(v[i], v[j], v[k], v[t], a, b, c, d)) continue;
if (!go(cur + 1, curans + 1)) return false;
if (!go(i))
if (!inq[gr[cur][i].v]) push(gr[cur][i].v);
if (!inq[gr[cur][i].v]) pushq(gr[cur][i].v);
if (!iscolored(cx, cy) && !iscolored(cx - 1, cy))
if (!ispr(p[a][0], b)) return -1;
if (!ispr(p[a][k], b)) a = p[a][k];
if (!ispred(c, b)) a = c;
if (!ok)
if (!ok) break;
if (!ok) can[whmax] = false;
if (!ok) continue;
if (!on[d])
if (!q.empty() && last[q.top().second] >= place)
if (!q[l])
if (!res) return true;
if (!result)
if (!sett[i]) go(i, inf, i + 2000, inf + 1);
if (!simplex(n + m, m, n + m + 1, m + 1))
if (!take[cur])
if (!used[j]) cur++;
if (!was)
if (!was[0])
if (!was[cur->v])
if (!was[gr[cur][i].v])
if (!was[i])
if (!was[j]) ans++;
if (!was[j]) curans++;
if (!was[n - 1])
if (((a + pk) * (a + pk)) % (pk * p) == x) return (a + pk);
if (((h41 - h42 + x + y) % 2) != 0) bad();
if (((h43 + h41 - y - z) % 2) != 0) bad();
if (((h43 + h42 - x - z) % 2) != 0) bad();
if ((1LL << i) == t) wht = i;
if ((a * a) % (pk * p) == x) return a;
if ((b % (a + 1)) % 2 == 0) return true;
if ((b & 1) == 1)
if ((b * b) % n == a) return b;
if ((b - a) / n > 0) n = -n;
if ((c - a) / n > 0) n = -n;
if ((cur & 1) == 0) calcans();
if ((cur & 1) == 1) calcans();
if ((cur & need) == need)
if ((cur * h * 1.0) / l[i].v < time + eps)
if ((cur * h * 1.0) / l[i].v < time + eps) cur--;
if ((curl != -1) && (abs(curl - curpl) <= mind))
if ((curr != -1) && (abs(curr - curpl) < mind))
if ((i + j < 43) && !(cur & (1LL << (i + j))))
if ((i + j) % 2 == 0) printf("X");
if ((kb & 1) == 1)
if ((kv[t] & 1) == 1)
if ((ll)curx * cury >= 0) answer += abs(curx) + abs(cury);
if ((m - 1 - kx) % 2 == 1) answer ^= n;
if ((n - 1 - ky) % 2 == 1) answer ^= m;
if ((np[k] - np[j]) * (np[i] - np[j]) == 0) continue;
if ((whopen & 1) == 0) curd = opens[cur][whopen];
if ((x % 2) != 0) bad();
if ((x & 1) == 0)
if ((x & 3) == 0)
if (0 <= b && 0 >= a)
if (2 * a > n)
if (A > B) swap(A, B);
if (D < 0 || exp(- D * T0 / T) > random01())
if (IT == 5000)
if (M == 1)
if (Owon) printf("O won\n");
if (R == 1)
if (R > n + 1)
if (T == 1)
if (T == 1) t.push_back(make_pair(C, i + 1));
if (X < 0) X = -X;
if (a % minmod != b % minmod) can = false;
if (a % n != b % m) can = false;
if (a + b + c + d == pt(0, 0))
if (a + b + c == pt(0, 0))
if (a + b == pt(0, 0))
if (a < 0) return -1;
if (a < 0) return a + n;
if (a <= 0) a = b;
if (a == 0 && b == 0 && c == 0)
if (a == 0)
if (a == 0) a = b;
if (a == 0) return 0;
if (a == 0) return a;
if (a == 0) return false;
if (a == 1) kv0++;
if (a == 42)
if (a == NULL)
if (a == NULL) return b;
if (a == b)
if (a == b) break;
if (a == b) return a;
if (a == b) return;
if (a > 0)
if (a > 0) return 1;
if (a > b) swap(a, b);
if (a >= 1)
if (a >= wh2) answer ^= 2;
if (a->size < b->size) swap(a, b);
if (a->size() < b->size()) swap(a, b);
if (a->size() > b->size()) swap(a, b);
if (a.first.x == a.second.x) return a.first.y;
if (a.id == b.id) return;
if (a.point != b.point) return a.point > b.point;
if (a.prob != b.prob) return a.prob > b.prob;
if (a.set != b.set) return a.set < b.set;
if (a.size() != b.size()) return a.size() < b.size();
if (a.tin != b.tin) return a.tin < b.tin;
if (a.wh < b.wh) return true;
if (a.x != b.x) return a.x < b.x;
if (a.y != b.y) return a.y < b.y;
if (a.z != b.z) return a.z < b.z;
if (a[1] > a[0])
if (a[currid] - curr < a[curlid] - curl)
if (a[cury][i] == 0) continue;
if (a[i - 1] == -1) cannot++;
if (a[i - 1] > a[i] && a[i] < a[i + 1])
if (a[i] != -1)
if (a[i] != -1) used[a[i]] = true;
if (a[i] != prev) k1++;
if (a[i] % 2 == 1) ansl[i][0] = ansl[i - 1][0] + a[i];
if (a[i] + i == a[j] + j || a[i] - i == a[j] - j) answer++;
if (a[i] < 0) cur++;
if (a[i].first != a[last].first)
if (a[i][j] == '#') kv++;
if (a[i][n + m + 1] < minb)
if (a[j][b] / a[j][i] < mino)
if (a[j][i] < eps) continue;
if (a[j][i] == 0) continue;
if (a[j][i] > a[cury][i]) swap(a[j], a[cury]);
if (a[k] == 0)
if (a[n - 2] > a[n - 1])
if (a[w1].first == b[w2].first)
if (a[x.id] >= a[y.id]) return x;
if (a[x] == y)
if (a[x][y] != '#') return;
if (abs(a - m0) + abs(b - m1) + abs(c - m2) < minans)
if (abs(a.p / a.l - b.p / b.l) < eps) return a.id < b.id;
if (abs(a.x - b.x) > answer)
if (abs(a[i][i]) < eps) return false;
if (abs(a[j][i]) > abs(a[i][i])) swap(a[j], a[i]);
if (abs(md(a - b) ^ md(c - b)) > (2 * Pi / 3))
if (abs(md(b - a) ^ md(c - a)) > (2 * Pi / 3))
if (abs(md(b - c) ^ md(a - c)) > (2 * Pi / 3))
if (add[cur] == 0) return;
if (adj.size() == 0)
if (adjj[i + 1] == adjj[i]) continue;
if (allcheaters.find(whother) != allcheaters.end())
if (ans < answer || (ans == answer && answh < wh))
if (ans == 2)
if (ans == NULL)
if (ans == NULL) ans = l;
if (ans == NULL) ans = r;
if (ans == md(a))
if (ans > answer || (ans == answer && a[wh] < a[ansp]))
if (ans > mod) ans -= mod;
if (ans.first == -1)
if (ans1 == 0) printf("Impossible\n");
if (ans1 > ans2) r = m2;
if (ans1 == -1)
if (ans[curx][cury] != curt)
if (ans[i] == -1) return -1;
if (ans[i] == 1 && was1 < 2)
if (ans[i] == 1) max1 = max(max1, a[i].x);
if (ans[i] == 1) min1 = min(min1, a[i].x);
if (ans[i] == 2 && was2 < 2)
if (ans[i] == 2) max2 = max(max2, a[i].x);
if (ans[i] == 2) min2 = min(min2, a[i].x);
if (ans[i] > maxw) break;
if (ans[j] == ans[i] + job[j].c)
if (ans[n + 1] == -1)
if (ans[t + i] < ans[t] + can[i][j])
if (ans[x][y] != '?') continue;
if (ansfound) ans = i + 1;
if (ansfound) continue;
if (answer < kv || (answer == kv && mins * sumq < answerw))
if (answer == -1) return;
if (answer == 0)
if (answer == 0) cout << "Rublo" << endl;
if (answer == 0) cut = true;
if (answer == 1) break;
if (answer > 0)
if (answer > 0) reverse(p, p + n + 1);
if (answer > 1e9) answer = 0;
if (answer.size() < 3) return false;
if (answer[i] == -1) printf("oo\n");
if (as[n - 1] == '-')
if (atob(l, r))
if (b & 1) ans = (ans * tmp) % MOD;
if (b < a) swap(a, b);
if (b == 0 && c == 0)
if (b == 0)
if (b == 0) return 0;
if (b == 0) return 325;
if (b == 0) return make_pair(1, 0);
if (b == NULL) return a;
if (b->count(shashl) > 0) outwrite(b->[shashl], cur);
if (b->count(shashr) > 0) outwrite(cur, b->[shashr]);
if (b->size < lenr - lenl + 1)
if (b.wh < a.wh) return false;
if (b <= -1)
if (b[i] != prev) k2++;
if (b[i] == 0) last = i;
if (b[i] == 1)
if (bad[cur][j]) ok = false;
if (begin == n)
if (begin == wh) begin = next[wh];
if (best == -1)
if (best.first + barr[i].first <= 0)
if (bestans > curans)
if (besttime < 0) besttime = 0;
if (bo == n) bo = 0;
if (bs[m - 1] == '-')
if (c == '!')
if (c == '+')
if (c == '+') add(++kv);
if (c == '-')
if (c == '.' || c == 'G') return c;
if (c == '?')
if (c == 'A' || c == 'D' || c == 'E') cntA++;
if (c == 'C' || c == 'F' || c == 'G') cntC++;
if (c == 'L') cnt++;
if (c == -1)
if (c == 0)
if (c1 != ' ') a[c1] = c2;
if (c1 != ' ') c1 = a[c1];
if (c1 != cur) curans += ans[c1][full(c1)];
if (c2 != cur) curans += ans[c2][full(c2)];
if (calc(m) >= k) l = m;
if (can + a[i] > maxsum)
if (can(a, b) && a * b < mina * minb)
if (can(costs[m])) l = m;
if (can(cur + 1))
if (can(cur - 1))
if (can(gr[cur][i]) && d[cur] == d[gr[cur][i].v] - 1)
if (can(m)) l = m;
if (can(m)) r = m;
if (can(mid)) r = mid;
if (can)
if (can) answer = k;
if (can0) printf("0\n");
if (can[i] && a[cur] == a[i] * k) can[cur] = false;
if (can[i]) ans++;
if (can[i][j][l >> BST2])
if (can[km - 1])
if (cand) gr[i][j].push_back(make_pair(i, j - 1));
if (canl) gr[i][j].push_back(make_pair(i - 1, j));
if (cann(mask, i))
if (canone(i, last, mid, t)) l = mid;
if (canr) gr[i][j].push_back(make_pair(i + 1, j));
if (canu) gr[i][j].push_back(make_pair(i, j + 1));
if (ch == '+')
if (ch == '-')
if (check(i, j)) ans = 1;
if (check(x, y, z))
if (check(xc, yc))
if (cl == cr)
if (cl == cr) return cl;
if (cl == cr) return;
if (cl == x && cr == x)
if (cl > r || cr < l) return 0;
if (cl > r || cr < l) return 1;
if (cl > r || cr < l) return;
if (cl > r) return;
if (cl > x || cr < x) return 0;
if (cl > x || cr < x) return cur;
if (cl > x || cr < x) return;
if (cl >= begin)
if (cl >= l && cr <= r)
if (cl >= l && cr <= r) return sum[cur];
if (cl >= l && cr <= r) return tree[cur];
if (cl >= n) return;
if (clock() > end_time)
if (clock() >= end_time) return false;
if (cnt != 0) break;
if (cnt % 2 == 1) continue;
if (cnt == len)
if (cnt > 1)
if (cnt > treesize - 1000) rebuild();
if (cnt > treesize - 3000) rebuild();
if (cntA > cntC) printf("A-mol\n");
if (cntC == cntA)
if (cntC > cntA) printf("C-dur\n");
if (cntgo == 1000)
if (cntmatch(bestmatchcube) == cntmatch(got)) maxsteps += 3;
if (cntmatch(cube) > bestmatch && cube != last)
if (col[p[0]] == col[p[n - 1]])
if (command == "link")
if (command == '?')
if (command == 'A')
if (command == 'Q')
if (command == 'R')
if (command == 'X') break;
if (command[0] == 'g') printf(LLD "\n", get(x, y));
if (comp[re[id].first] == answer[id].first)
if (cornered) res += "bridge";
if (cost == -1) continue;
if (cost[cur][i] < m) addto(t, 1, cur);
if (count1 > count2) can = false;
if (count_it == 0)
if (cr < begin) return -1;
if (cr < l || cl > r) return 0;
if (cr < l || cl > r) return;
if (cr < l) return;
if (cr < x || cl > x) return;
if (cr == cl)
if (cube == ideal)
if (cur != wasmin + 1 && l > 0) return kv2[l - 1];
if (cur + 1 + can > n) sleep = MAXTIME + 1;
if (cur + cnty(cx, cy) >= k)
if (cur < 0) cur = MOD - 1;
if (cur < 0) return;
if (cur < 1) break;
if (cur < 1) return true;
if (cur < m) answer.push_back(cur);
if (cur <= clast) r = m;
if (cur ==  NULL) return;
if (cur == '.' || cur == 'G')
if (cur == -1) return;
if (cur == 0)
if (cur == 0) return;
if (cur == 1) break;
if (cur == 6)
if (cur == K)
if (cur == NULL)
if (cur == NULL) cur = new tnode;
if (cur == NULL) return -1;
if (cur == NULL) return 0;
if (cur == NULL) return 1;
if (cur == NULL) return false;
if (cur == NULL) return;
if (cur == c2) return mfl;
if (cur == cnt)
if (cur == cur->p->l)
if (cur == me)
if (cur == n * m - 1)
if (cur == n - 1 || cur == 0) continue;
if (cur == n - 1) return maxf;
if (cur == n)
if (cur == null)
if (cur == null) return -1;
if (cur == null) return cur;
if (cur == null) return;
if (cur > km) return true;
if (cur > n) return 0;
if (cur >= n - 1 || cur <= 0 || was[cur]) return false;
if (cur >= n || a[cur] - x > b[i]) continue;
if (cur->isend)
if (cur->kv < l || cur->kv > r) cur->ok = false;
if (cur->l != NULL) cur->l->to_push += cur->to_push;
if (cur->l == NULL) cur->l = newnode();
if (cur->l == NULL) return cur->r;
if (cur->l->size < x)
if (cur->l->size == x) return cur;
if (cur->l->size > x) return get_right(cur->l, x);
if (cur->l->sum >= k) return get(cur->l, cl, cm, k);
if (cur->maxf - cur->f <= 0) return;
if (cur->next[curch] == NULL)
if (cur->next[i] != NULL)
if (cur->ok) answer++;
if (cur->p == null) return;
if (cur->p->l == pr) cur->p->l = cur;
if (cur->p->p == null)
if (cur->r != NULL) cur->r->to_push += cur->to_push;
if (cur->r == NULL) cur->r = newnode();
if (cur->r == pr) answer += cur->l->size + 1;
if (cur->reverse)
if (cur->set)
if (cur->set) return cur->y;
if (cur->sum < k) return -1;
if (cur->x < x)
if (cur->x == 0)
if (cur->x == 0) return getsize(cur->l);
if (cur->x == 1) return getsize(cur->l);
if (cur->x == 2)
if (cur->x == 2) return getsize(cur->l);
if (cur->x == cur->ans) cur->x = -inf;
if (cur->x == x) return getsize(cur->l);
if (cur->x.first + getans(m).first <= 0)
if (cur.set == 0)
if (cur.size() == 0) return true;
if (cur.size() == 1)
if (cur.x == m)
if (cur.x2 < cur.x1 || cur.y2 < cur.y1) continue;
if (cur1 < n && a[cur1] == prev)
if (cur1 < n && d1[cur1] == 0) cur1++;
if (cur1 <= cur2 && cur1 <= cur3)
if (cur1 == v) break;
if (cur1 >= v1)
if (cur2 < m && d2[cur2] == 0) cur2++;
if (cur2 <= cur1 && cur2 <= cur3)
if (cur3 <= cur2 && cur3 <= cur1)
if (cur[a][wha].v < cur[b][whb].v)
if (cur[i] != '.' && cur[i] != 'G') ans += 2;
if (cur[i] != '.') ans++;
if (cur[i] == ideal[i])
if (curans + 1 < answer)
if (curans > ans[i + 1])
if (curans >= answer - 1) return true;
if (curanswer < bestanswer)
if (curc == len) return;
if (curd < mind)
if (curd < mindx)
if (curd < mindy)
if (curj < m && s[i] == t[curj]) curj++;
if (curj >= 0 && s[i] == t[curj]) curj--;
if (curk == 0)
if (curk == 0) curlen += sobx[i][j].x - lastx;
if (curk == 0) curlen += soby[i][j].x - lastx;
if (curk == 0) lenx[i] += sobx[i][j].x - lastx;
if (curk == 0) leny[i] += soby[i][j].x - lastx;
if (curk >= k) answer += sob[i].first - sob[i - 1].first;
if (curkv == 0)
if (curkv == 1) begin = sob[i].x;
if (curl + r[i].r > l)
if (curlen >= need)
if (curnum <= x)
if (curp > maxp) return;
if (curpos - maxpos > 0)
if (curpos - minpos < 0)
if (curpos == len)
if (curpos >= n) return;
if (cursize > a[cur])
if (curspeed[a] * kv[b] == curspeed[b] * kv[a]) return inf;
if (cursum > curh) break;
if (curv > 0) curans.second += curv;
if (cy < m - 1) go(cx, cy + 1, true, minneed);
if (cycled)
if (d == 1) return kv1[l];
if (d > 1 && d < n)
if (d(p[i] - p[j]) < mind - eps)
if (d(p[i] - p[j]) < mind)
if (d2 < 25)
if (d2 == 25)
if (d[cur] != curd) continue;
if (d[cur] == q) continue;
if (d[cur] > maxdist) break;
if (d[cx][cy] != cur.first) continue;
if (d[gr[cur][i]] < curd) answer += addingnm;
if (d[gr[cur][i]] > d[cur] + 1)
if (d[n - 1] != inf) printf("%d\n", d[n - 1] / 2 + 1);
if (d[n - 1] == MAX_TIME) d[n - 1] = -1;
if (d[n - 1] == inf) break;
if (d[next.x][next.y] > d[cx][cy] + gr[cx][cy][i].second)
if (d[next] > d[cur] + 1)
if (deathtime < mergetime)
if (diffy(cy) >= need)
if (dir & (1 << i)) curs += c[i];
if (dir == 'L') x = -x;
if (dir[0] == 'E') d[i] = 2;
if (dir[0] == 'N') d[i] = 0;
if (dir[0] == 'S') d[i] = 1;
if (dir[0] == 'W') d[i] = 3;
if (dist(xc, yc, np[i]) > r + eps) return false;
if (dist[ni][nj] <= dist[curx][cury] + 100) continue;
if (div0(cursum[i], curspeed[i]) < deathtime)
if (dobest(whmax, i))
if (down(n))
if (down[cur] < height[cur] && up[cur] < height[cur])
if (dp[i][j] > 100000) continue;
if (dx[d[i]] == 0)
if (dx[d[i]] == 1)
if (dx[dir] != 0)
if (dy[d[i]] == 1)
if (e[i].first == e[j].first)
if (e[i].first == e[j].second)
if (e[i].second == e[j].first)
if (e[i].second == e[j].second)
if (edges[i].first % 3 == 1)
if (edges[i].l <= l && edges[i].r >= r)
if (endtime - begintime < eps) return;
if (eo - bo > 0) curp.x = intersect(o[eo - 1], curp);
if (eo == n) eo = 0;
if (ex[cur] == 0) return;
if (f == 0)
if (f >= D) ans = true;
if (f(a) == 0) break;
if (f[i] == 1)
if (f[i] == 2)
if (find(a) != find(b))
if (find) continue;
if (flow != n - 1)
if (forked)
if (forward)
if (found) return a;
if (found) return ans;
if (found) return;
if (from[cur].size() == 0) return;
if (g1 != 0 && g2 != 0) g[i] = 0;
if (get(a + 1, b, 1) && getgr(a, b))
if (get(a, b - 1, 1) && getgr(b, b - 1))
if (get(i + 1, i, 0))
if (get(i + 1, i, 1))
if (get0(cur->l)) return change0(cur->l, x);
if (get0(cur->l)) return find0(cur->l);
if (get1(cur->l)) return find1(cur->l);
if (get2(cur->l)) return change2(cur->l, x);
if (get2(cur->l)) return find2(cur->l);
if (getans(cur->l) == cur->ans) cur->l = doerasemax(cur->l);
if (getbest(m, 1LL << n) > p) r = m;
if (getdir(fromb, tob) == UP) swap(fromb, tob);
if (getdv(m) >= 0) r = m;
if (gethash(1, m - j) != gethash(j + 1, m)) can[j] = false;
if (getsize(cur->l) == x)
if (getsize(cur->l) >= x)
if (getworst(m, 1LL << n) > p) r = m;
if (go(a, -1))
if (go(b, a))
if (go(next, cur))
if (go(sx, sy, 0, 0))
if (good)
if (good.empty()) ans[i] = -1;
if (good[l] && good[r] && a[l] > a[r]) q.push(l);
if (gr[cur].size() != 1 || pr == -1)
if (gr[cur][i] == c2)
if (gr[cur][i] == pr)
if (gr[e[i].first][e[j].first])
if (gr[e[i].first][e[j].second])
if (gr[e[i].second][e[j].first])
if (gr[e[i].second][e[j].second])
if (grp[cur][j] == c1) wh1 = j;
if (grp[cur][j] == c2) wh2 = j;
if (grrcomp[i].size() == 0) base.push_back(i);
if (h % b != 0)
if (h < f[i][j] + 20) time = H - h + 100;
if (h[a] > h[b] && h[up[a][k]] >= h[b]) a = up[a][k];
if (h[b] > h[a] && h[up[b][k]] >= h[a]) b = up[b][k];
if (h[cur->u] != h[cur->v] + 1 && cur->u != 0) return;
if (h[i] <= curh) upd(ans[i], w[i] + ans[i - 1]);
if (h[i] == h[i - 1]) kv++;
if (ha == hb) answer++;
if (have < 0) continue;
if (i != 1) m[i] = domin(root);
if (i != 1) mc[i] = domin();
if (i % 2 == 0) a[i / 2] = p[i];
if (i % 3 == wx)
if (i + dicsz[k] > len) continue;
if (i + j == n - prev && i >= h + 1) answer += ans[i][j];
if (i - (l - 1) >= 0) cur.push(sum[i - (l - 1)]);
if (i - (r - 1) >= 0) del.push(sum[i - (r - 1)]);
if (i - r >= 0) erasefirst(root[i]);
if (i < 2) go(i, 0);
if (i < m)
if (i < n) go(i + 1, j, cur * 2 + (a[i] - 'A'));
if (i == 0 || xs[i].lvl != xs[i - 1].lvl)
if (i == 0 || ys[i].lvl != ys[i - 1].lvl)
if (i == 0) answer *= 9;
if (i == 0) return cur.f0;
if (i == 0) w[i].id = 0;
if (i == 1) return cur.f1;
if (i == m) ans[i][j] += ans[i][j - 1];
if (i == n && j == m) kv[cur]++;
if (i > 0) root[i] = root[i - 1];
if (i > 0) upd(ans[i - 1][j][1], ans[i][j][kz]);
if (i > 1) updsum(ans[i][j], mul(ans[i - 2][j + 1], i - 1));
if (i > n + bbegin) break;
if (i >= h + 1 && i == n - prev) answer += ans[i][0];
if (id >= 0)
if (id[next] == 0)
if (ij < j) break;
if (ij > j) d.push_back(ij);
if (in.size() < 3) return false;
if (in[i].id == -1) continue;
if (inp[curch] == '$')
if (inp[curch] == '+')
if (inp[curch] == '-')
if (inside) return (a.x * b.n.x + a.y * b.n.y + b.c < -eps);
if (inters == 0) return;
if (intersect(i, j) < mergetime)
if (intersection) cout << "YES\n";
if (iscolored(cx, cy) && iscolored(cx - 1, cy)) return;
if (iscolored(cx, cy)) cx--;
if (isgood(x, y))
if (isl[x + 1][y]) set(y, true);
if (isl[x][y] && !isl[x + 1][y]) ends[x].push_back(y);
if (isme) continue;
if (ison(a, c, d) || ison(b, c, d)) return true;
if (ison(c, a, b) || ison(d, a, b)) return true;
if (ispr(a, b)) return a;
if (ispred(a, b)) return a;
if (it != segments.begin() && itnext != segments.end())
if (it != segments.begin())
if (it != segments.end())
if (it == curs.begin()) answer++;
if (it == s.end()) continue;
if (it == str.end())
if (it->first == az)
if (itnext != segments.end()) check(s[-p[i].id], *itnext);
if (j % 3 == wy) ans[i][j] = '.';
if (j % 3 == wy) ans[i][j] = 'X';
if (j * 2 <= i) ma[i][j] = (a[i - j * 2] + b[i - j]) % 2;
if (j + h[i + 1] <= a)
if (j < m) go(i, j + 1, cur * 2 + (b[j] - 'A'));
if (j < m[i] - '0')
if (j <= need[i]) curmax = max(curmax, cursum);
if (j == 0) a[i][j] = a[i - 1][j + 1];
if (j == m) ans[i][j] += ans[i - 1][j];
if (j == n - 1 || s[j + 1] != 'e') continue;
if (j == s[i] - 'a')
if (j > 0) upd(ans[i][j - 1][kz], (ll)ans[i][j][kz] * j);
if (j > 0) updsum(ans[i][j], mul(ans[i - 1][j], j));
if (j >= i)
if (j1 == n - 1 || s[j1 + 1] != 'e') continue;
if (j2 > j1)
if (job[j].id != 0) was[job[j].id] = 1;
if (ju[i] < l) ans[i] = (l - ju[i]) / x;
if (k == 0)
if (k == 1)
if (k == 2)
if (k == 26)
if (k == 3)
if (k > n) k = n;
if (k0 < 1 || k2 > y[2].size()) continue;
if (k1 > k2 || (k1 == k2 && b[m - 1] == 0))
if (kar.size() == 0) return t[t.size() - 1].first;
if (kb == k)
if (kb > k) continue;
if (knew > n) knew = n;
if (kv != 0 && st[kv - 1] == s[i]) kv--;
if (kv <= 0) can = false;
if (kv <= 2)
if (kv == 2)
if (kv > 0)
if (kv > 1) c[cur] = 1 - c[cur];
if (kv > 2)
if (kv(cur + d[i]) <= 1) add(cur + d[i]);
if (kv(m) >= need) r = m;
if (kv0 > 0)
if (kv0 > 0) ans[kv0 - 1][kv1][1] = 1;
if (kv1 > 0)
if (kv1 >= need)
if (kv[cur] < 3)
if (kv[cure] != 0) continue;
if (kv[i][j].size() == 0) add(n + j, i);
if (kvbad != kvother)
if (kvdown == 32)
if (kvget[gr[cur][i]] == kv[gr[cur][i]] - 1)
if (kvo < k)
if (kvodd == 1)
if (kvodd > 1) continue;
if (kvr[i] < kvl[j]) can1 = false;
if (kvr[j] > kvl[i]) can0 = false;
if (kvup == 32)
if (kx > 0 && ry[0] != 1) emptyy = 1;
if (ky > 0 && rx[0] != 1) emptyx = 1;
if (l != NULL)
if (l != NULL) return l;
if (l != null) l->update();
if (l < eps)
if (l <= cl && r >= cr)
if (l <= cl && r >= cr) return vmax[cur];
if (l <= me && r >= me) arr[me - l] = cur->x;
if (l == -1)
if (l == NULL)
if (l == NULL) return r;
if (l == null) return r;
if (l == r)
if (l > 0) ans[l - 1][r] = max(ans[l - 1][r], ans[l][r]);
if (l > r) continue;
if (l > r) return 0;
if (l > r) return false;
if (l > r) return true;
if (l > r) swap(l, r);
if (l >= k) return;
if (l >= m) return;
if (l >= r) return null;
if (l >= r) return;
if (l->y < r->y)
if (l->y > r->y)
if (l.size == 0 && r.size == 0)
if (l.size == 1)
if (l.size == r.size + 1)
if (l.size > 1)
if (l[curl].second < r[curr].second) curl++;
if (l[i] + 1 <= r[i + 1])
if (last != 0 && t < i && t >= a)
if (last < 5) return;
if (last >= m) return true;
if (last.second > cnt)
if (last == -1)
if (last[A[i] + 1] != -1) gr[last[A[i] + 1]].push_back(i);
if (last[A[i] - 1] != -1) gr[i].push_back(last[A[i] - 1]);
if (last[A[i]] != -1)
if (last[B[i] + 1] != -1) gr[last[B[i] + 1]].push_back(i);
if (last[B[i] - 1] != -1) gr[i].push_back(last[B[i] - 1]);
if (last[B[i]] != -1) gr[last[B[i]]].push_back(i);
if (last[i] != -1) b[last[i]] = 1;
if (laste > j)
if (len % 2 == 0) return len / 2;
if (len == 0) return 0;
if (len == 1) return 0;
if (len[f[i].t].back() == i)
if (like[a] && a > 0) kvl[i]++;
if (like[a]) kvr[i]++;
if (lleft[i] != -1) tree[i].l = &tree[lleft[i]];
if (log1 > 2900 || log2 > 2900)
if (lp.size > 0) f.push(x);
if (m != 1) mods.push_back(m), ost.push_back(b % m);
if (m & 1) cur = (cur * tmp) % MOD;
if (m + 1 <= i) break;
if (m == 0)
if (m == 1) printf("%d\n", powmod(2, n, p));
if (m == 4) printf("%d %d\n", 1, 1);
if (m > 1 && kx == 0) emptyy = 1;
if (m > 1) go(1, m - 1, 0);
if (m > 4)
if (m >= n - 1)
if (m >= n)
if (m >= x) return get(cur->l, cl, m, x);
if (m1 & (1 << i)) curx++;
if (m2 & (1 << j)) cury++;
if (mark[cur]) d[cur] = 0;
if (mask & (1 << i)) swap(xn[i], yn[i]);
if (mask & (1 << j)) k++;
if (max(kv1, kv2) > maxkv)
if (maxans + curans <= answer) return;
if (maxdown[j][k] == 0)
if (maxf - minf < bestanswer)
if (maxf == 0) break;
if (maxf[all - 1] == 0) break;
if (maxr[i][j] <= k) continue;
if (maxr[l][i] > j) return l;
if (maxwh == -1) break;
if (maxx >= x)
if (me == 0) return 0;
if (me == tot - 1) return me;
if (min0 < min1)
if (min2 < min1)
if (minX > maxX) continue;
if (mina == n + 1) cout << "Not found!!!!!!" << endl;
if (minans == inf) cout << -1 << endl;
if (minb < -eps)
if (mind < curd) answer += addingnm;
if (mind >= curans)
if (minh == h[cur])
if (minlen > 0)
if (minneed[i][j][i] <= j)
if (minpl != -1)
if (minpos - curpos > 0)
if (minus) printf("-");
if (minwh == -1) return false;
if (msum[i - 1] < 0)
if (n != 1) answer.push_back(n);
if (n != 1) mods.push_back(n), ost.push_back(a % n);
if (n % (i * i) == 0 && (i * i) < n)
if (n % 2 == 1) answer = pr * k + 1;
if (n % 2 == 1) sum = (sum * a[i]) % mod;
if (n % i == 0)
if (n & 1) ans = ans * t;
if (n + 1 < i) break;
if (n < 4)
if (n < m) swap(n, m);
if (n <= 20000)
if (n <= prev) answer = 0;
if (n == 0)
if (n == 0) break;
if (n == 1)
if (n == 1) return 1;
if (n == 2) return a;
if (n == 2) return answer - inter(0, 1);
if (n == 3)
if (n == m)
if (n > 1 && ky == 0) emptyx = 1;
if (n > 1)
if (n > 1) go(n - 1, i, 0);
if (n >= l && n <= r)
if (ncan[ch][s[i]] == 0)
if (near[i][0] >= m)
if (need <= 1)
if (need <= lenx[i])
if (need <= leny[i])
if (need <= m && emptyx != -1)
if (need <= n && emptyy != -1)
if (need > n) return 0;
if (need[cur] == m) doall(cur + 1);
if (next != NULL) ans = next->first;
if (next != NULL) ans = next->second;
if (next + curl > 2 * l) next = 2 * l - curl;
if (next - now > eps)
if (next < 0) continue;
if (next == cur) break;
if (next == nnext)
if (next > mmax) continue;
if (next >= mmax) continue;
if (next[0][E] == -1)
if (next[i] != -1)
if (next[i] <= j) ans[i][j] = ans[next[i]][j];
if (next[i][E] == -1) answer = min(answer, ans[i][j]);
if (next[i][t] < next[i][j]) continue;
if (next[i][t] > next[i][c1]) nextmany[i][c1][t] = 2;
if (next[j1][E] == -1)
if (next[j][E] == -1)
if (nl == nr) return calc(l, r);
if (nm < 0) continue;
if (nnext == n)
if (normsize == 0) return x * p[0].x + y * p[0].y;
if (now) updneed(minneed[cx], cy);
if (now[x] == t) return;
if (nwas % 2 == 1) sum = (sum * a[i]) % mod;
if (nx1 == nx2 && x1 != x2)
if (nx[i] > j && nx[j] > nx[i]) can = false;
if (ny == pts.end())
if (o[bo].first.first + barr[id].first <= 0)
if (ok) break;
if (ok) doall(cur + 1);
if (on[d])
if (p == 2)
if (p == 3)
if (p > 29)
if (p.x != 0 || p.y != 0) dowith(p);
if (p1 != -1) return true;
if (p1 * p2 < 0) swap(p1, p2);
if (p1 == p2) return;
if (p[1].y == 0)
if (p[i + 1][j + 1] == 'W')
if (p[i + 1][j] == 'B')
if (p[i + 1][j] == 'W')
if (p[i].id > 0)
if (p[i].len == 0) answer++;
if (p[i].x == 0 || p[i].y == 0)
if (p[i].y == 0) break;
if (p[i][j + 1] == 'B')
if (p[i][j + 1] == 'W')
if (p[i][j] == '*' || p[i][k] == '*') maxdown[j][k] = 0;
if (p[i][j] == '*') maxr[i][j] = j;
if (p[i][j] == '1') last = 0;
if (p[i][j] == 'S') sx = i, sy = j;
if (p[i][j] == p[i + 1][j])
if (p[i][j] == p[i][j + 1])
if (p[j].len == 0) answer++;
if (p[j].r >= x)
if (p[j][i] == '*') maxup[j][i] = j;
if (p[wh.x + d[i].x][wh.y + d[i].y] == '.') ans++;
if (p[wh.x][wh.y] != '.') return 5;
if (p[x][y] != l[cur]) return;
if (p[x][y] == '#') return false;
if (p[x][y] == last)
if (pl[x + 1][y] == '.') unite(x + 1, y - 1, x + 1, y + 1);
if (pl[x - 1][y] == '.') unite(x - 1, y - 1, x - 1, y + 1);
if (pl[x][y + 1] == '.') unite(x - 1, y + 1, x + 1, y + 1);
if (pl[x][y - 1] == '.') unite(x - 1, y - 1, x + 1, y - 1);
if (pn[i] == 1 && pm[i] == 1) continue;
if (pos != data.end()) return pos->second;
if (pos % k < 0)
if (poss.find(cur) == poss.end()) addpos(cur, last);
if (pp[a] != a) pp[a] = find(pp[a]);
if (pp[i].l <= l && pp[i].r >= r && pp[i].l != pp[i].r)
if (pr > 1e9) pr = 1e9;
if (pr[a] != a) pr[a] = find(pr[a]);
if (pr[cur] != cur) pr[cur] = find(pr[cur]);
if (pr[x] == pr[y]) printf("Yes\n");
if (prev == 1) answer.push_back(v.size());
if (q == 1)
if (q.empty()) break;
if (q[l]) printf("%d\n", answer);
if (r != NULL)
if (r != NULL) return r;
if (r != null) r->update();
if (r < cl || l > cr) return 0;
if (r < cl || l > cr) return;
if (r < l) return r + 2;
if (r < n) ans[l][r + 1] = max(ans[l][r + 1], ans[l][r]);
if (r <= 0 || l >= cur->size) return;
if (r <= q[eo - 1].begin) eo--;
if (r == NULL)
if (r == NULL) return l;
if (r == m)
if (r == n)
if (r == null) return l;
if (r > l)
if (rect[i].x1 > rect[i].x2) swap(rect[i].x1, rect[i].x2);
if (rect[i].y1 > rect[i].y2) swap(rect[i].y1, rect[i].y2);
if (res != 0)
if (res == NULL) return &cur->x;
if (res.length() > 0) res += '-';
if (root == NULL) return;
if (rotated)
if (rotated) return cntx(cy, cx);
if (rotated) return xs[cy] - xs[cy - 1];
if (rotated) swap(cx, cy);
if (rp.size != cnt) lp.push(rp.pop());
if (rp.size == cnt)
if (rright[i] != -1) tree[i].r = &tree[rright[i]];
if (s <= 2) return;
if (s == "pwd") print();
if (s > d)
if (s.size == 0) s = r;
if (s.size > 0)
if (s[0] == '*') ansv *= 3;
if (s[0] == '*') printf("4\n");
if (s[0] == 'c')
if (s[0] == 'o')
if (s[0] == 's')
if (s[a] < s[b])
if (s[a] < s[b]) pr[a] = b;
if (s[a] == s[b]) s[a]++;
if (s[i - 1] == '[') sum[i]++;
if (s[i] - 'a' == c1)
if (s[i] == '(' || s[i] == '[')
if (s[i] == '*') ansv *= 4;
if (s[i] == '0' || i == n - 1)
if (s[i] == '?')
if (s[i] == 'P')
if (s[i] == 'e') aft[i] = aft[i + 1];
if (s[i] == maxc) was[i] = 1;
if (s[i] == t[j])
if (s[i] > maxc)
if (s[i] >= 'A' && s[i] <= 'J' && !used[s[i] - 'A'])
if (s[n - 1] == 'A') printf("A-mol\n");
if (s[p1.first][p1.second] < s[p2.first][p2.second])
if (s[parbegin] == '.')
if (s[parbegin] == '/')
if (same)
if (set(i, j, false) && doall())
if (set(i, j, true) && doall())
if (set(i, x, false) && doall())
if (set(i, x, true) && doall())
if (set(x, i, false) && doall())
if (set(x, i, true) && doall())
if (sett[cur] > 0) return cr - cl + 1;
if (side == 'L') cout << *d[ver]->left() << endl;
if (side == 'L') d[ver]->pop_left();
if (side == 'L') d[ver]->push_left(wh);
if (side == SIDE_B) return facetoup(cube);
if (side == SIDE_D) return facetoleft(facetoleft(cube));
if (side == SIDE_L) return facetoleft(cube);
if (side == SIDE_U) return cube;
if (side1[cur1][0] == 'L') nx1--;
if (side1[cur1][0] == 'R') nx1++;
if (side2[cur2][0] == 'L') nx2--;
if (side2[cur2][0] == 'R') nx2++;
if (sob[i].t == OPEN)
if (sob[k].t == -1)
if (sq <= bestsq) continue;
if (ss[a] < ss[b])
if (ss[a] == ss[b]) ss[a]++;
if (steps > maxsteps) return;
if (sts != 0) check(st[sts - 1] + 1, n - 1);
if (sts == 0) check(begin, i - 1);
if (sum < 1) l = m;
if (sum <= 1000) hs.push_back(sum);
if (sum <= p)
if (sum == 0)
if (sum >= l && sum <= r) answer++;
if (sum[i] - j + h[i + 1] <= b)
if (sum[r] - sum[l] > answer || (!was))
if (suma <= k * (n + 1) && sumb <= k * (n + 1))
if (sumb > suma)
if (sums[i].first == sums[i - 1].first)
if (sz % 2 == 1)
if (sz == -1)
if (sz[1][1] != 0) corn[0] = find(1, 1);
if (sz[1][s] != 0) corn[1] = find(1, s);
if (sz[2 * s - 1][s] != 0) corn[4] = find(2 * s - 1, s);
if (sz[gr[cur][i]] > sz[cur] / 2)
if (sz[s][1] != 0) corn[5] = find(s, 1);
if (sz[s][2 * s - 1] != 0) corn[2] = find(s, 2 * s - 1);
if (t != -1) edges[gr[cur][i].e] = t;
if (t * 2 == i)
if (t < 0) return 0;
if (t <= x) return (y * (y + 1) / 2 + y * (t - y));
if (t <= y) return (t * (t + 1) / 2);
if (t == 0)
if (t == 0) return 1;
if (t == 0) t = -1;
if (t == 1)
if (t == 1) qt.push(1 - curt);
if (t == 1) reverse(l, r);
if (t == 1) to_sqr(1, 0, treesize - 1, l, r);
if (t == 2)
if (t == 2) printf("%d\n", getmin(l, r));
if (t == 2) set2(1, 0, treesize - 1, tin[v], T + 1);
if (t == 3)
if (t == open)
if (t > 0)
if (t > 0) c = t, a = fl[c1][i];
if (t > 0) return t;
if (t > ans[i + 2])
if (t > ans[i + 3])
if (t > mod) t -= mod;
if (t >= 0) return t + getsize(cur->l) + 1;
if (t >= 0) return t;
if (t >= x + y - 1) return x * y;
if (t) ans[x][y] = 'X';
if (t) sum[x >> S2]++;
if (t.second > t.first)
if (t.size() < k)
if (t.size() == 0) return kar[kar.size() - 1].first;
if (t[i] == t[id]) curkv--;
if (time > 2.95) break;
if (tmp[last].first != tmp[i].first)
if (tot == 1) return 0;
if (tree[ct][cur].set == -1) return;
if (tree[cur] >= MOD) tree[cur] -= MOD;
if (tree[cur].kset != 0) tree[cur].ans = tree[cur].len;
if (up[a][k] != up[b][k])
if (up[cur] < height[cur]) return UP;
if (used[x][y]) return;
if (v % t != 0 || v > max(v1, v2))
if (v == v1)
if (v2 > v1)
if (v[i].p > v[whmax].p)
if (vp != 0) return (vp < 0);
if (vp != 0) return (vp > 0);
if (vp < 0) return false;
if (vp > 0) return true;
if (w % a != 0)
if (w[l + tr + 1].x - w[l].x >= width) return l + 1;
if (w[n + 1].x - w[0].x < width)
if (was <= 2) answer *= i;
if (was == 0) cout << "1\n0\n";
if (was == 1 || was == 2) cout << "2\n";
if (was >= 3) cout << "1\n" << answer << endl;
if (was)
if (was) break;
if (was.count(get_num(cube)) != 0) return;
if (was1 < 0) continue;
if (was1 < 2) maxs1 = -1e9;
if (was1 < 2) mins1 = 1e9;
if (was1[next] == 0 && f[next] != 1)
if (was1[next] == 0) was1[next] = 1;
if (was2 < 2) maxs2 = -1e9;
if (was2 < 2) mins2 = 1e9;
if (was2)
if (was2[next] == 0 && f[next] != 1)
if (was2[next] == 0) was2[next] = 1;
if (was[cur] != 0) return;
if (was[cur] == 1) return;
if (was[cur] == 2)
if (was[cur] == 2) bad();
if (was[cur] == kwas) return false;
if (was[cur] >= kwas) return false;
if (was[cur]) continue;
if (was[cur]) return -1;
if (was[cur]) return h[cur];
if (was[cur]) return;
if (was[cure]) return nextv;
if (was[curx][cury])
if (was[cx][cy]) return;
if (was[gr[cur][i].v] != 2)
if (was[gr[cur][i]] == 1)
if (was[i][j]) ans[i][j] = 0;
if (was[in[i].id]) answer.push_back(in[i]);
if (was[l][r][whmax]) return ans[l][r][whmax];
if (was[p[i]] == -1) was[p[i]] = i;
if (was[x][y] == 1)
if (was[x][y] == 1) return;
if (was[x][y] || p[x][y] == '.') return;
if (was[x][y]) return;
if (wascalc[l][r]) return memcalc[l][r];
if (wascur)
if (wasgo[l][r][nl]) return memgo[l][r][nl];
if (wh != NULL)
if (wh == (int)ids.size() || ids[wh] != x) printf("%d ", k);
if (wh == -1)
if (wh == -1) return;
if (wh == 0)
if (wh == n)
if (wh == normsize)
if (wh > i - 2) cur = 0;
if (wh1 != -1 && !(mask & (1 << wh1))) continue;
if (wh1 != -1) mm += (1 << wh1);
if (wh1 == NULL) wh1 = get_left(root);
if (wh2 != -1 && !(mask & (1 << wh2))) continue;
if (wh2 != -1) mm += (1 << wh2);
if (wh2 == NULL) wh2 = get_left(root);
if (wh[i] < k - 1) can = sum[k - 1] - a[i];
if (wh[t] != -1) printf(" %d", t);
if (whdeath == -1) break;
if (where(b) == wa) return wa->size - 1;
if (which[gr[cur][i]].size() > 1) maxdist = d[cur];
if (whmax == -1) break;
if (wht == -1)
if (x != -1)
if (x != 1) ans *= x - 1;
if (x != 1) can = false;
if (x % 2 == 0)
if (x % 4 == 0 && sz % 2 == 0)
if (x & 1) ans += (ansk[cur] * ans + ansa[cur]) % MOD;
if (x & 1) umn(ans, tmp);
if (x < (1LL << sz)) return get(t, x, sz - 1);
if (x < 0 || x >= l) return true;
if (x < 0 || x >= n || y < 0 || y >= m) return;
if (x < 0 || y < 0 || x >= n || y >= m) return;
if (x < 0 || y < 0 || z < 0) bad();
if (x < 0)
if (x < 0) return -1;
if (x < 1 || x > n || y < 1 || y > m) return true;
if (x < 1 || x > n || y < 1 || y > m) return;
if (x < n) kv1++;
if (x < y) swap(x, y);
if (x <= m)
if (x <= maxx)
if (x <= n)
if (x == 'O') cntO++;
if (x == 'T')
if (x == 'X') cntX++;
if (x == 0) continue;
if (x == 1 || x == p - 1) continue;
if (x == 1)
if (x == 3)
if (x == p - 1)
if (x == y) a[x][y][0][0] = (a[x][y][0][0] + 1) % MOD;
if (x > 0) return 1;
if (x > 1 && y < m)
if (x > 1)
if (x > 1) kv1++;
if (x > max(n, m))
if (x > max(n, m)) outwrite();
if (x > n) outwrite();
if (x >= cur->size)
if (x >= n)
if (x1 == x2)
if (x1 == x2) ylines.push_back(tline(x1, y1, y2));
if (x1 > x2) swap(x1, x2);
if (x1[i] == x2[i])
if (x1[i] > x2[i]) swap(x1[i], x2[i]);
if (x2 < x1 && a >= 0)
if (x2 < x1) swap(x1, x2);
if (x2 > x1 && b <= 0)
if (x2 >= x1 + a && x2 <= x1 + b)
if (x[a] < x[b]) return RIGHT;
if (x[a] > x[b]) return LEFT;
if (x[cur] >= d) return 0;
if (y & 1) x = next[x][t];
if (y < 0 || y >= w) return true;
if (y < 0)
if (y < m)
if (y < n) kv1++;
if (y < x) swap(x, y);
if (y == 0)
if (y > 1) kv1++;
if (y > m)
if (y >= m)
if (y1 > y2) swap(y1, y2);
if (y1[i] > y2[i]) swap(y1[i], y2[i]);
if (y2 < y1) swap(y1, y2);
if (y[a] < y[b]) return UP;
if (z < 0 || z >= h) return true;
if (z == i)
if (z == j)
if (z == k)
if (z == t)
in = d->in;
in = new deque<pair<T*, T*>, n - 1> (in);
in = new deque<pair<T*, T*>, n - 1>;
in->pop_left();
in->pop_right();
in->print();
in->push_left(wh);
in->push_right(wh);
in.push_back(lines[0]);
in.push_back(lines[i]);
in.resize(0);
incomp(gr[cur][i].v, cur, c);
incomp(i, -1, comp[i]);
ing[i].push_back(a);
init |= (1 << i);
inline T d() const
inline T* left()
inline T* right()
inline bool all5(int x, int y)
inline bool can(int a, int b)
inline bool can(int cur)
inline bool can(tedge cur)
inline bool canone(int i, int li, int ri, ll t)
inline bool check(int x, int y)
inline bool check(int x, int y, int z)
inline bool chone(int x, int y, int z)
inline bool cmp(pt a)
inline bool cmp(pt a, pt b)
inline bool cmp0(const pt &a, const pt &b)
inline bool cmpbits(int a, int b)
inline bool cmpeq(const line &a, const line &b)
inline bool cmph(int a, int b);
inline bool cmpminx(int a, int b)
inline bool cmpp(const int &a, const int &b)
inline bool cmpparam(const int &a, const int &b)
inline bool cmpsum(const int &a, const int &b)
inline bool cmpsum(int a, int b)
inline bool cmpx(pt a, pt b)
inline bool down(const line &a)
inline bool down(const pt &a)
inline bool eq2(int a, int b)
inline bool get(int a, int b, int c)
inline bool get0(pnode cur)
inline bool get1(pnode cur)
inline bool get2(pnode cur)
inline bool getgr(int a, int b)
inline bool getnew(pt wa, pt wb, pt &ansa, pt &ansb)
inline bool goodmask(int x, int y, int t)
inline bool in(pt a, pt b, pt c)
inline bool intersect(pt a, pt b, pt c, pt d)
inline bool is_palindrome(ll a)
inline bool isgood(ll x, ll y)
inline bool ison(pt a, pt b, pt c)
inline bool ispr(int a, int b)
inline bool ispred(int a, int b)
inline bool match(char a, char b)
inline bool match(char have, char need)
inline bool onseg(pt a, pt b, pt c)
inline bool operator<(const line &a, const line &b)
inline bool operator<(const pt &a, const pt &b)
inline bool operator<(const tans &a, const tans &b)
inline bool operator<(const tb &a, const tb &b)
inline bool operator<(const tc &a, const tc &b)
inline bool operator<(const tedge &a, const tedge &b)
inline bool operator<(const tsob &a, const tsob &b)
inline bool operator<(const tsum &a, const tsum &b)
inline bool operator<(const tvertex &a, const tvertex &b)
inline bool operator<(pt a, pt b)
inline bool operator<(tp a, tp b)
inline bool operator<(Worker a, Worker b)
inline bool operator<(const pos &a, const pos &b)
inline bool operator<(const pt &a, const pt &b)
inline bool operator<(const tevent &a, const tevent &b)
inline bool operator<(const tfish &a, const tfish &b)
inline bool operator<(const tq &a, const tq &b)
inline bool operator<(const tsob &a, const tsob &b)
inline bool operator<(const tt &a, const tt &b)
inline bool operator<(cont a, cont b)
inline bool operator<(lem a, lem b)
inline bool operator<(pt a, pt b)
inline bool operator<(tjob a, tjob b)
inline bool operator<(tr a, tr b)
inline bool operator<(tx a, tx b)
inline bool operator == (const pt &a, const pt &b)
inline bool operator()(int a, int b)
inline bool operator()(sgm a, sgm b)
inline bool same(pt a, pt b, pt c)
inline bool set(int x, int y, bool t)
inline bool& iscolored(int cx, int cy)
inline cyph getlr(int l, int r)
inline cyph getmax(cyph x, cyph y)
inline double ang(pt a, pt b)
inline double d(ptd a)
inline double dist(const pt &a)
inline double dist(double x, double y, pt a)
inline double div0(int a, int b)
inline double f(double xx)
inline double getdist(int a, int b)
inline double inter(int a, int b)
inline double intersect(int a, int b)
inline double operator * (ptd a, ptd b)
inline double operator / (pt a, ptd b)
inline double operator / (ptd a, ptd b)
inline double operator ^ (ptd a, ptd b)
inline double random01()
inline double sum(const tv &a)
inline int bit_count(int a)
inline int calc(uint *a, uint *b)
inline int cntmatch(const string &cur)
inline int count(int x, int y)
inline int domax()
inline int domin()
inline int find(int a)
inline int find(int cur)
inline int full(int cur)
inline int get(int len)
inline int get_ith(const tnode &cur, int i)
inline int get_sum(int l, int r)
inline int getans(int cur)
inline int getans(int cur, int cl, int cr)
inline int getans(int wasmin, int wasmax, int cur, int l)
inline int getans(pnode cur)
inline int getansr(int b, int f, int len)
inline int getbest(int t, int k)
inline int getdir(int a, int b)
inline int getmin(int lx, int rx)
inline int getsize(pnode cur)
inline int getsum(int x1, int y1, int x2, int y2)
inline int getv(const int &curv, const int &cure)
inline int kv(int a, int b, int c, int d)
inline int kv(pt wh)
inline int kvtrue(int x, int y)
inline int kvunknown(int x, int y)
inline int mul(int a, int b)
inline int norm(int a)
inline int norm(pt &wa)
inline int operator * (const pt &a, const pt &b)
inline int operator *(const pt &a, const pt &b)
inline int operator / (const pt &a, const pt &b)
inline int operator /(const pt &a, const pt &b)
inline int pop()
inline int popq()
inline int sgn(int a)
inline int sgn(int x)
inline int sgn(ll a)
inline int whhalf(const pt &a)
inline int& operator[](int x)
inline ld d(pt a)
inline ld getans(int a, int b, int c)
inline ld intersect(sgm a, ld x)
inline ld operator * (pt a, pt b)
inline ld operator / (pt a, pt b)
inline ll calc(ll t, ll x, ll y)
inline ll cntx(int cx, int cy)
inline ll cnty(int cx, int cy)
inline ll d() const
inline ll d(ll x, ll y)
inline ll d(pt a)
inline ll diffy(int cy)
inline ll get(int x, ll b)
inline ll get(ll x, ll y)
inline ll getans(pnode cur)
inline ll gethash(ll l, ll r)
inline ll gethash(ll x1, ll y1, ll x2, ll y2)
inline ll getsum(int xl, int yl, int xr, int yr)
inline ll kv(ll t)
inline ll kvar(int have, int need)
inline ll operator * (const pt &a, const pt &b)
inline ll operator * (pt a, pt b)
inline ll operator *(const pt &a, const pt &b)
inline ll operator *(pt a, pt b)
inline ll operator / (const pt &a, const pt &b)
inline ll operator / (pt a, pt b)
inline ll operator /(const pt &a, const pt &b)
inline ll operator /(pt a, pt b)
inline ll sgn(ll a)
inline ll wh(int x, int y, int z)
inline pair<int, int> find(int x, int y)
inline pair<int, int> getans(pnode cur)
inline pair<ll, ll> euclid(ll a, ll b)
inline pnode get_right(pnode cur, int x)
inline pnode merge(pnode l, pnode r)
inline pnode newnode()
inline pt<double> intersect(const line &a, const line &b)
inline pt abs(pt a)
inline pt get_norm(const pt &a)
inline pt get_norm(const pt &a, int id)
inline pt operator * (int k, const pt &a)
inline pt operator + (const pt &a, const pt &b)
inline pt operator + (pt a, pt b)
inline pt operator +(pt a, pt b)
inline pt operator - (const pt &a, const pt &b)
inline pt operator - (pt a)
inline pt operator - (pt a, pt b)
inline pt operator -(const pt &a, const pt &b)
inline pt operator -(pt a, pt b)
inline pt& operator += (const pt &a)
inline ptd getpoint(pt a, pt b, pt c)
inline ptd md(pt a)
inline ptd operator * (ptd a, double b)
inline ptd operator + (ptd a, ptd b)
inline ptd operator - (ptd a)
inline ptd operator - (ptd a, ptd b)
inline ptd operator -(pt a, ptd b)
inline ptd operator / (ptd a, double b)
inline tf operator *(const tf &a, const tf &b)
inline tpair operator *(tpair a, tpair b)
inline tv operator *(const tv &a, const double &b)
inline tv operator +(const tv &a, const tv &b)
inline ull next(ull a, ull n)
inline void _union(int a, int b)
inline void add(int a, int b)
inline void add(int i)
inline void add(int l, int r)
inline void add(int t, int id)
inline void add(int x)
inline void add(int x, int y)
inline void add(int x1, int y1, int x2, int y2)
inline void add(pnode &root, ll t)
inline void add(pt *a, int kv)
inline void add(pt wh)
inline void add_one(int &cur, int l, int r, int t)
inline void addmod(ll &a, ll b)
inline void addpos(pos cur, pos last)
inline void bad()
inline void check(const tsum &a, const tsum &b)
inline void check(int ans, int wh)
inline void check(int cx, int cy, ll addy)
inline void check(int i)
inline void check(int l, int r)
inline void check(sgm a, sgm b)
inline void correct(int id)
inline void del()
inline void dowith()
inline void dump(double begintime, double endtime)
inline void erasefirst(pnode &root)
inline void erasemax(pnode &root)
inline void insert(pnode &root, ll x)
inline void make_root(pnode cur)
inline void makenew(int i)
inline void out(const pt &a)
inline void pop_left()
inline void pop_right()
inline void print()
inline void print(pnode cur, pnode pr, string s)
inline void push()
inline void push(int ct, int cur, int cl, int cr)
inline void push(int cur, int len)
inline void push(int x)
inline void push(pnode cur)
inline void push_back(int x, int y)
inline void push_left(T *x)
inline void push_right(T *x)
inline void pushone(pnode &cur, ll t)
inline void pushq(int x)
inline void put(int a, int b, int c, bool zn)
inline void rebuild()
inline void reverse(int lx, int rx)
inline void rotate(double a)
inline void rotate(ld a)
inline void rotate(pnode cur)
inline void set(uint *a, int x)
inline void setpal(int ct, int l, int r, int kvl, int kvm)
inline void splay(pnode cur)
inline void split(pnode cur, int x, pnode &l, pnode &r)
inline void undo()
inline void union_(int a, int b)
inline void unite(int a, int b)
inline void unite(int x1, int y1, int x2, int y2)
inline void upd(int &a, int b)
inline void upd(int &a, ll b)
inline void upd(pnode cur)
inline void update(int ct, int cur)
inline void update(int cur)
inline void update(pnode cur)
inline void updateans(const pt &a, const pt &b)
inline void updneed(int &a, int b)
inline void updsum(int &a, int b)
inline void upupdate(pnode pr, pnode cur)
inline void willun(int a, int b, int timer)
inp[leninp++] = c;
inplace_merge(p, p + m, p + n, cmpy);
inq[ans] = false;
inq[x] = false;
inq[x] = true;
int &curx;
int *arr;
int *d = dist[s];
int *wh = new int;
int *x;
int A, B;
int A;
int ALL;
int A[maxn], B[maxn];
int C, T;
int D = f(b) - f(a);
int D;
int IT = 0;
int K;
int M, n;
int MOD;
int N;
int NT = 0;
int NT;
int R1[4], L1[4], R2[4], L2[4];
int T;
int X, Y;
int Y, B;
int a = a1[i];
int a = e[i].first;
int a = e[i].v1;
int a = wascol[i][0];
int a, b, c, whb;
int a, b, c;
int a, b, id;
int a, b, l;
int a, b, s;
int a, b, t;
int a, b, w;
int a, b;
int a, m;
int a1[maxn], b1[maxn];
int a;
int a[100005];
int a[100], b[100];
int a[100], next[100];
int a[100];
int a[20];
int a[20][20];
int a[300], b[300];
int a[30], b[30];
int a[maxn], b[maxn], ans[maxn];
int a[maxn], b[maxn], c[maxn], k[maxn], p[maxn];
int a[maxn], b[maxn], c[maxn];
int a[maxn], b[maxn];
int a[maxn], kv[maxx];
int a[maxn], p[maxn];
int a[maxn];
int a[maxn][maxn], b[maxn][maxn], c[maxn][maxn];
int a[maxn][maxn];
int a[maxt];
int a[treesize * 2];
int acur = s[cur];
int add = (j == 4 || j == 7);
int add = 2;
int add;
int add[maxn], was[maxn], sub[maxn];
int add[maxn];
int add[maxn][maxn];
int addd, addu;
int adjj[6];
int aft[maxn];
int all = 1 + 2 * n + 1;
int ans = *min_element(dp[len], dp[len] + 6);
int ans = 0;
int ans = 2;
int ans = inf;
int ans = min(a, b);
int ans = q.front();
int ans0 = ((w / a) * (h / b));
int ans1, ans2, o1, o2;
int ans1 = -1;
int ans1[maxn][15];
int ans2 = go(c1, -1, 2000);
int ans2 = -1;
int ans2[maxn], ans3[maxn];
int ans2[maxn][15][15];
int ans3 = -1;
int ans;
int ans[100005][256];
int ans[100005][4][4];
int ans[MAXTIME + 5][2];
int ans[MAX];
int ans[maxk], from[maxk];
int ans[maxk];
int ans[maxn], a[maxn], b[maxn];
int ans[maxn], bestans[maxn], answer[maxn];
int ans[maxn], last[maxn];
int ans[maxn], was[maxn];
int ans[maxn];
int ans[maxn][1 << 11];
int ans[maxn][12];
int ans[maxn][6];
int ans[maxn][maxa][2];
int ans[maxn][maxn];
int ans[maxn][maxn][5];
int ans[maxn][maxn][maxn][maxn];
int ans[maxx];
int ansr[maxn][3], ansl[maxn][3];
int answer = 0;
int answer = 1000000000;
int answer = 1;
int answer = 1e9;
int answer = ans[n][m];
int answer = back->x;
int answer = inf;
int answer = m->min;
int answer = maxt;
int answer = n * 10;
int answer = n * m * 2;
int answer = solve(a, m);
int answer, ansl, ansr;
int answer, ansq, ansp;
int answer, answh;
int answer, ansx, ansy;
int answer;
int answer[maxn], ans[maxn];
int answer[maxn];
int answer[treesize * 2], sett[treesize * 2];
int answerwhi;
int as[maxn], bs[maxn];
int b = b1[i];
int b = e[i].second;
int b = e[i].v2;
int b = wascol[i][1];
int b, c;
int b, w, g;
int b1 = (h43 + h41 - 2 * b7 - y - z) / 2;
int b2 = x - b1;
int b3 = (h43 + h42 - 2 * b7 - x - z) / 2;
int b4 = y - b3;
int b5 = (2 * b7 + 2 * z + x + y - h41 - h42) / 2;
int b6 = z - b5;
int b;
int b[maxn];
int back = cnt;
int back = last;
int back = re.size();
int bas[maxn];
int bbegin = begin;
int begin = 0;
int begin;
int begintime = clock();
int best = -1;
int best = q.top().second;
int bestanswer;
int bestmatch;
int big = get(1, 0, treesize - 1, i + 1, whmax[f[i].t]);
int bl = wh[id] / BSZ;
int bl, c;
int bmax[maxn], bmin[maxn];
int bo = 0, eo = 0;
int bo = 0;
int bo, eo;
int bord[maxn];
int c = lca(a, b);
int c = up[a][k];
int c, a, b;
int c1 = es[cur][i].a;
int c2 = es[cur][i].b;
int c;
int c[3];
int c[maxn];
int c[maxn][maxn], f[maxn][maxn], dist[maxn][maxn];
int c[maxn][maxn];
int calc(pnode cur)
int calcrev(int cur, int pr)
int can = 0;
int can = k - ans[time][1];
int can(int tr)
int can[2 * maxc];
int can[4][4];
int cannot = 0;
int change0(pnode cur, int x)
int change2(pnode cur, int x)
int check2(int K)
int chinese(int *a, int p, int n)
int ci = id[i];
int cm = (cl + cr) / 2;
int cnt = 0;
int cnt = sob[i].kv;
int cnt, k, n;
int cnt1[maxn], cnt2[maxn];
int cnt;
int cntA = 0;
int cntC = 0;
int cntO, cntX;
int cnt[maxn][maxn];
int cntgo = 0;
int cntvertex = 0;
int code(int len)
int col = answer[i].c;
int color(int cur, int pr, int curh)
int compress(int n)
int compress(pnode cur)
int conf;
int corn[6];
int cost = -1;
int cost;
int cost[30];
int costs[maxn];
int count1 = 0;
int count2 = 0;
int countans(int mask)
int cup = a[i] / 32;
int cup = a[j] / 32;
int cur = (len - 1) * (i - wh - 1);
int cur = -1;
int cur = 0;
int cur = 1;
int cur = a[0];
int cur = all - 1;
int cur = check2(K);
int cur = get(t.first, t.second);
int cur = i;
int cur = j;
int cur = k;
int cur = km - 1;
int cur = lower_bound(a, a + n, d[j + 1]) - a;
int cur = m * i + j + 1;
int cur = n - 1;
int cur = o.front();
int cur = o[bo++];
int cur = o[bo];
int cur = pop();
int cur = popq();
int cur = pq.top().second;
int cur = q.front();
int cur = q[bo++];
int cur = size + a;
int cur = wh[a[begin]];
int cur1 = 0, cur2 = 0, cur3 = 0;
int cur1 = 0;
int cur2 = 0;
int cur[maxn];
int curadd = 0;
int curadd = C / A;
int curans = 0;
int curans = lower_bound(minel, minel + n, a[i]) - minel;
int curans = max(ans[i][j], maxans[i][t - 1]);
int curans;
int curch = s[curstr][curp] - 'A';
int curcnt = --cnt;
int curcnt = cnt++;
int curcolor;
int curcomp;
int curcost = 0;
int curd = pq.top().first;
int cure = bord[i];
int curfrom = tob;
int curh = hs[wh];
int curj = 0;
int curk = 0;
int curk;
int curkv = 0;
int curl = 0;
int curl = l;
int curlen = 0;
int curlen = leftsize + getsize(cur->l);
int curlen = strlen(t);
int curlid = 0;
int curmax = (need[i] == m ? 0 : -inf);
int curmax = 0;
int curmin = m + 1;
int curminxa = min(0, a.x);
int curminxa = min(min(0, a.x), (a + b).x);
int curminxb = 0;
int curminya = min(0, a.y);
int curminya = min(min(0, a.y), (a + b).y);
int curminyb = 0;
int curnum = getsize(cur->l);
int curp = l + 1;
int curp = p[0];
int curpl = cnt++;
int curpl = wh[id];
int curr = 0;
int currid = 0;
int curs = 0;
int cursize = M;
int curst = 0;
int cursum = 0;
int cursum[maxn], curspeed[maxn];
int cursz = 1;
int curt = 0;
int curt = qt.front();
int curto;
int curw = -r[0].r;
int curx = -100000;
int curx = -1e8 + 1;
int curx = 0;
int curx = n;
int curx = qx.front();
int cury = 0;
int cury = 1e8;
int cury = m;
int cury = qy.front();
int cx = cur.second.x;
int cx = x[ci];
int cy = cur.second.y;
int cy = y[ci];
int d = 10;
int d = wasmax - wasmin;
int d1[maxn], d2[maxn];
int d2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
int d;
int d[maxk], from[maxk];
int d[maxm], from[maxm];
int d[maxm][maxm];
int d[maxn], ms[maxn], l[maxn];
int d[maxn];
int d[maxn][maxn];
int d[maxn][maxn][maxn];
int da = __gcd(abs(wa.x), abs(wa.y));
int da = norm(wa);
int db = norm(wb);
int dc = norm(wc);
int dd = norm(wd);
int deep;
int dir1 = getdir(e[a].first, e[a].second);
int dir2 = getdir(e[b].first, e[b].second);
int dirs[6];
int dist[maxn][maxn];
int down = n;
int dp[MAXN][6];
int dt[maxn];
int dx = x[b] - x[a];
int dy = y[b] - y[a];
int e[maxn][maxn];
int edges[maxe];
int empty = n * m + 1;
int emptyx = -1;
int emptyy = -1;
int end_time, count_it;
int end_time;
int eo = 0;
int f = d[i] + (d[i] - ms[i]);
int f(int *a)
int f, maxf;
int f0, f1;
int f[10][maxn];
int f[maxn];
int f[treesize * 2], sum[treesize * 2];
int find(int a)
int find(int a, int b)
int find(int v)
int find(pnode cur, int x)
int find0(pnode cur)
int find1(pnode cur)
int find2(pnode cur)
int first = from[cur][0];
int flow = 0;
int from[maxn];
int fromb = e[cure].first;
int g1 = g[i - t];
int g2 = g[t];
int g[10000];
int get(int a, int b)
int get(int cur, int cl, int cr, int l, int r)
int get(int i, int j, int l, int r)
int get(int l, int r)
int get(int x)
int get(int x, int y)
int get(pnode cur, int cl, int cr, int k)
int get1(int cur, int cl, int cr, int x)
int get2(int cur, int cl, int cr, int l, int r)
int get_sum(int cur, int cl, int cr, int l, int r)
int getans(int b, int f, int len)
int getdv(ld time)
int getmask(int cur, int son)
int getmax(int cur, int cl, int cr, int l, int r)
int getmin()
int getnum(pnode cur)
int getsize(int cur, int pr, int curh)
int getsum(int ct, int cur, int l, int r, int cl, int cr)
int go(int cur, int pr)
int go(int cur, int pr, int mfl)
int go(int curv, int cure)
int go2(int cur, int pr)
int goend(int cur, int pr)
int gogo(int cur, int pr, int mfl)
int gr3[maxn][3];
int gr[maxn];
int gr[maxn][2];
int gr[maxn][4];
int gr[maxn][maxn];
int h = Y;
int h21, h31, h32, h41, h42, h43;
int h[maxn], hx[maxn], sz[maxn];
int h[maxn], nextedge[maxn];
int h[maxn], sum[maxn];
int h[maxn], w[maxn];
int ha = h[a] - b * st[b];
int hb = h[b] - a * st[a];
int i = dirs[d];
int i = maxwh;
int i = next[cur];
int i = wh[cury];
int i = workers.top();
int i, j, k;
int i;
int id = sz - i - (lenr - lenl + 1);
int id;
int id[maxn];
int id[maxn][2 * maxn];
int ij = i / j;
int init = 0;
int j = 2 * i;
int j = i % k;
int j = i + len;
int j = n + 1;
int j = next[i][c];
int j1 = next[i][c1];
int j2 = next[i][c2];
int ju[maxn];
int k = (n + 1) / 2;
int k = 0;
int k = comps[i].size();
int k = j + len;
int k, n;
int k1 = (a / (w % a));
int k1 = 0;
int k2 = (b / (h % b));
int k2 = 0;
int k;
int k[10];
int kans;
int kb = 26 - bit_count(mask);
int kcol = 0;
int kcomp = 0;
int kdiv2 = 0;
int ke = 0;
int ke, n, m, t;
int ke[maxn];
int kempty = 10;
int ken = 0;
int key[maxkey];
int keyin[maxn][maxkey];
int kg = 0;
int km
int km = (1 << (n - 1));
int km = (1 << n);
int km = 1 << 26;
int km = 1 << m;
int km = 1 << n;
int knew = 0;
int knew = j + a[i];
int ko = 1;
int kp = 0;
int kq1 = 0, kq2 = 0, kq3 = 0, kq4 = 0;
int kr[maxn], kl[maxn];
int kret = 0;
int krow = 0;
int kset;
int ksob = 0;
int kt = m;
int kv = 0;
int kv = 1;
int kv = ans->without0.get(0);
int kv = compress(tree[cur].size());
int kv = mymerge(tree[cur * 2], tree[cur * 2 + 1]);
int kv = n;
int kv0 = 0;
int kv1 = 0;
int kv1 = 1;
int kv1, kv2, kv0;
int kv1[maxn], kv2[maxn];
int kv;
int kv[26];
int kv[2];
int kv[maxk][maxk];
int kv[maxm], kvget[maxm];
int kv[maxmask];
int kv[maxn], when[maxn];
int kv[maxn], whmax[maxn];
int kv[maxn];
int kv[maxn][maxk];
int kvbad = 0;
int kvdown = a[j] % 32;
int kvl[maxn], kvr[maxn];
int kvodd = 0;
int kvother = (it == wins.end() ? 0 : it->second);
int kvrev = calcrev(cur, -1);
int kvup = 32 - a[i] % 32;
int kvup = 32 - a[j] % 32;
int kvv[maxn];
int kwas;
int kx = 0;
int kx = unique(x, x + n) - x;
int ky = 0;
int kz = 0;
int l = 0;
int l = last - 1;
int l = max(sum - k0, k2);
int l = n / i;
int l = prev[to_del[i]];
int l, r, a, b;
int l, r, b;
int l, r, id;
int l, r, len;
int l, r;
int l, t;
int l, w, h, n;
int l1, l2, r1, r2;
int l = -1;
int l[20], r[20];
int l[maxn * maxn];
int l[maxn], r[maxn], count[maxn];
int l[maxn], r[maxn], maxr[maxn], minr[maxn], ans[maxn];
int l[maxn], v[maxn], x[maxn];
int l[maxn];
int last = 0;
int last = 3 * m;
int last = 5;
int last = n;
int last = parbegin;
int last = t % 10;
int last = wh[a[i]];
int last0 = get2(1, 0, treesize - 1, tin[v], tout[v]);
int last1 = get1(1, 0, treesize - 1, tin[v]);
int last;
int last[maxn];
int last[maxx];
int lastdir = cur.dir;
int laste = next[i][E];
int lastx = 0;
int lca(int a, int b)
int left = 1;
int left = lenl - (b->size - 1);
int len = (1 << i);
int len = s.length();
int len = strlen(buf);
int len = strlen(s);
int len = strlen(s[i]);
int len = t.size();
int len;
int len[20];
int leninp, curch;
int lleft[maxn], rright[maxn];
int lup = where(a)->up;
int lvl = (X + Y) / 2;
int lvl, x1, x2;
int m = (cur - 1) / 2;
int m = (int)grp[cur].size();
int m = (l + r + 1) / 2;
int m = (l + r) / 2;
int m = (x - 1 - i) / (2 * i + 1);
int m = 0;
int m = b.size();
int m = n * n - n / 2;
int m = n - k;
int m = n / 2;
int m = strlen(s);
int m = t.length();
int m;
int ma[maxn][maxn];
int main()
int mark[maxn];
int mask[maxk];
int max1 = -1e9;
int max2 = -1e9;
int maxa = 1;
int maxans = 0;
int maxans[maxn][maxn];
int maxb = min(i - 1, (int)sqrt(i) + 5);
int maxd[maxn];
int maxdist = inf;
int maxf = -1e9;
int maxf[maxv], from[maxv];
int maxi = sqrt(n) + 3;
int maxj = 0;
int maxkv = 0;
int maxl = -1, curl = -1, maxr = -1, curr = -1;
int maxlvl;
int maxr[maxn][maxn], maxup[maxn][maxn];
int maxs1 = 0, maxs2 = 0;
int maxst = st[r - l + 1];
int maxsteps = 1;
int maxsum = -inf;
int maxt = 0;
int maxtop[maxn][maxn], maxdown[maxn][maxn];
int maxv = 0, minv = inf;
int maxwh = -1;
int maxx = ((sz / 2 - 1) * (sz / 2 - 1) + 1) / 2;
int mc[maxn];
int me = getsize(cur->l);
int mid = (l + r) / 2;
int mid = curto;
int mid = find0(cur);
int mid = find1(cur);
int mid = find2(cur);
int midl = lenl;
int midr = lenr - (b->size - 1);
int min0 = find0(cur);
int min1 = 1e9;
int min1 = find1(cur);
int min2 = 1e9;
int min2 = find2(cur);
int min;
int mina = inf;
int mina = n + 1;
int minans, minans0, minans1, minans2, m0, m1, m2, n;
int minb = m + 1;
int minb = max(0, (int)sqrt(sqrt(i)) - 5);
int minbl = 0;
int mind = curd;
int mind = inf;
int mind = n + 2;
int mind[maxn][5];
int mindt = inf;
int minel[maxn], a[maxn];
int minf = 1e9;
int minh = 4 * n;
int minh = h[cur];
int minh[maxn][maxn];
int minlen = n;
int minmod = min(pn[i], pm[i]);
int minneed[maxn][maxn][maxn];
int minpl = -1;
int mins1 = 0, mins2 = 0;
int minwh = -1;
int minx = 1e9;
int minx, miny;
int miny = 1e9;
int mm = 0;
int mr1 = 0;
int mr12 = 0;
int mr2 = 0;
int mr22 = 0;
int n = (x - 2 - i) / (2 * i + 1);
int n = 0;
int n = 150;
int n = a.size();
int n = s.length();
int n = strlen(s);
int n = strlen(s[0]);
int n, A, B, C;
int n, L, S;
int n, a, b;
int n, ans;
int n, c1, c2;
int n, cnt;
int n, h;
int n, k, answer = 0; ;
int n, k, km;
int n, k, l, r;
int n, k, m;
int n, k;
int n, kans;
int n, kbl, k, m;
int n, l, k;
int n, lenl, lenr;
int n, m, H;
int n, m, a, b;
int n, m, bo, eo;
int n, m, c;
int n, m, k, S, T;
int n, m, k;
int n, m, kc;
int n, m, ke;
int n, m, nt;
int n, m, p;
int n, m, r;
int n, m, sx, sy;
int n, m, x, y;
int n, m;
int n, maxr, maxtime;
int n, maxw;
int n, me;
int n, mr, R;
int n, nq;
int n, p;
int n, q;
int n, r;
int n, s, p;
int n, u, r;
int n, w, l;
int n, width;
int n;
int ncan[255][255];
int ncount = 1;
int ndir;
int near[maxn][maxm];
int need = (answer ^ lenx[i]);
int need = (answer ^ leny[i]);
int need = (answer ^ m);
int need[maxn];
int needlenl = lenl - curlen;
int needlenr = lenr - curlen;
int newx, id;
int next = (i - 1) * m + j + 1;
int next = -1;
int next = cur.wh[i].first - b[cur.x];
int next = gr[cur][from[cur]].v;
int next = gr[cur][gr3[cur][i]];
int next = gr[cur][i];
int next = gr[i + 1][j].v - k - 1;
int next = grf[cur][i];
int next = grt[cur][i];
int next = st.top();
int next, first, last, all;
int next[3000][20];
int next[maxn], prev[maxn];
int next[maxn];
int next[maxn][12];
int next[maxn][15];
int nextdir = (curdir + 3) % 4;
int nexte = (oure + sz / 2) % sz;
int nextm = mask | (1 << i);
int nextmany[maxn][15][15];
int nextn = 0;
int nextv = getv(curv, cure);
int nf, ne;
int nfact;
int nfirst = from[cur][i];
int ni = curx + dx[d];
int ni = i + dx[d];
int ni = x + dx[d];
int nj = cury + dy[d];
int nj = j + dy[d];
int nj = y + dy[d];
int nm = m - popcount(mask);
int nm[maxn][3];
int nnext = next[bit_count(cur.set)];
int normsize, upmid;
int num = kp++;
int nx1 = x1, nx2 = x2;
int nx[maxn];
int o;
int o[maxn];
int odd = 0;
int oldans = curans;
int oldneed[maxn][maxn];
int oldst[maxn], ans[maxn];
int on[maxn];
int onf[maxn];
int open = 0;
int order[maxn];
int oure = -1;
int p = 0;
int p = 5000;
int p, id, l;
int p1, p2;
int p[20][20];
int p[4];
int p[maxk], was[maxk];
int p[maxkg];
int p[maxn];
int p[maxn][2 * maxn];
int p[maxn][maxk + 2];
int p[maxn][maxn];
int parbegin = 2;
int perm[maxn];
int pm[200], pn[200];
int point, prob, id;
int points = 0;
int pos = kv[wh][col].back();
int powmod(int a, int n, ll mod)
int powmod(int x)
int pr = -1;
int pr[maxn], s[maxn];
int prcur = cur;
int prev = -1;
int prev = 0;
int prev[maxn], next[maxn];
int prlast = cur;
int prpr = -1;
int push;
int q, id;
int q;
int q[5 * maxn];
int q[5];
int r = l + len;
int r = m;
int r = min((int)(y[2].size()), sum - 1);
int r = n - 1;
int r = n - 2;
int r = n;
int r = next[to_del[i]];
int r, id;
int r[3];
int r[maxn];
int result[maxk], curanswer[maxk];
int right = lenr;
int right = m;
int rright[maxn][maxn];
int rx[maxn], ry[maxn], lenx[maxn], leny[maxn];
int s = 0;
int s, a, b, c;
int s, id;
int s, kv, m;
int s, t, c, id;
int s[maxn], p[maxn];
int s[maxn][maxn];
int samem1 = kv[f[i].t] % MOD;
int schwh[maxn], schx[maxn], pchwh[maxn], pchx[maxn];
int set, sum;
int shift[maxn];
int size()
int size;
int sizewas = lines.size();
int sk = inf;
int sleep;
int small = get(1, 0, treesize - 1, 0, i - 1);
int solve(int a, int n)
int solve(pt *a, int n)
int solveprime(ll a, ll n)
int sortparam;
int ss[maxss], pp[maxss];
int ssum = 1;
int st = 1;
int st[maxn];
int steps = 0;
int sts;
int sum = 0;
int sum = m0 + m1 + m2 - (y[1].size() - i + 1);
int sum;
int sum[maxn], len[maxn];
int sum[maxn];
int sum[maxn][maxn];
int suma = 0;
int sumb = 0;
int sumrow[maxn], sumcol[maxn], wasrow[maxn], wascol[maxn];
int sumwas = tree[ct][1].sum;
int sz = (int)dic.size();
int sz = 0;
int sz = gr[nextv].size();
int sz = lenr - (lenl - (b->size - 1)) + 1;
int sz[maxn];
int sz[maxs][maxs];
int t = (x1 - x2) % (abs(a + b));
int t = (x2 - x1) % (a + b);
int t = 0;
int t = 1;
int t = __gcd(v1, v2);
int t = can(r);
int t = cur->x;
int t = find(cur->l, x);
int t = find0(cur->r);
int t = find1(cur->r);
int t = find2(cur->r);
int t = get(tree[cur][i].first, st);
int t = getnext(cur * 2, cl, cm, begin, l, r);
int t = go(gr[cur][i], cur, min(mfl, fl[cur][i]));
int t = go(gr[cur][i].v, cur);
int t = go2(gr[cur][i].first, cur);
int t = gogo(gr[c1][i], c1, 2000);
int t = gogo(gr[cur][i], cur, min(mfl, fl[cur][i]));
int t = i / 3;
int t = i;
int t = pl[i].top();
int t = pl[minpl].top();
int t, id;
int t, l, r;
int t, m;
int t, v;
int t, x;
int t0 = max(mind[cur][0], mind[gr[cur][i]][0]);
int t1 = max(mind[cur][1], mind[gr[cur][i]][1] + 1);
int t1 = t / 3;
int t2 = (t - t1) / 2;
int t2 = max(mind[cur][2], mind[gr[cur][i]][2]);
int t3 = max(mind[cur][3], mind[gr[cur][i]][3] + 1);
int t3 = t - t1 - t2;
int t4 = max(mind[cur][4], mind[gr[cur][i]][4]);
int t;
int t[maxk];
int t[maxn], d[maxn];
int t[maxn], kv[maxn];
int t[maxn];
int t[maxn][maxn];
int taked[maxn];
int testNum;
int thatedge = goend(grc[cur][i].v, cur);
int time = H - h + 10;
int timed[maxn][maxn][maxn];
int timer = 0;
int timer;
int tin, tout;
int tin[maxn], tout[maxn], p[maxn];
int tin[maxn], tout[maxn];
int tmp[20];
int to_find = s[curc] - 'a';
int to_push;
int tob = e[cure].second;
int tree1[treesize * 2], tree2[treesize * 2];
int tree[treesize * 2];
int u, v;
int up = 1;
int up(ll a, ll x, ll p, ll k)
int up;
int up[maxn], down[maxn];
int up[maxn][MAXLOG];
int up[maxn][maxk + 1];
int v, e;
int v, id;
int v1, v2, v;
int v1, v2;
int v;
int v[maxn], x[maxn];
int v[maxn];
int ver;
int w, h, a, b;
int w, h;
int w1 = 0;
int w2 = 0;
int w[maxn];
int wa = gr[a].size();
int wa = gr[cur].size();
int wa = gr[i + 1].size();
int was = 0;
int was1 = 0, was2 = 0;
int was1 = -1;
int was1[maxn], was2[maxn], o[maxn], f[maxn];
int was[maxn], p[maxn], paired[maxn], col[maxn];
int was[maxn], pr[maxn], p[maxn];
int was[maxn];
int was[maxn][maxn];
int wascnt;
int wasi = -1;
int wasmax = 0;
int wasmin = 0;
int wasq[maxn];
int waup = wb->up;
int wb = gr[0].size();
int wb = gr[a].size();
int wb = gr[b].size();
int wb = gr[n * m + 1].size();
int wb = gr[n + 1].size();
int wh = (lower_bound(norm, norm + upmid, n, cmp0) - norm);
int wh = -1;
int wh = 0;
int wh = answer[i].bl;
int wh = cur % n;
int wh = find(root, 1);
int wh = q.top().second;
int wh = re.back();
int wh, kv;
int wh1 = -1;
int wh2 = -1;
int wh2 = n + 1 + j;
int wh;
int wh[maxn], ans[maxn];
int wh[maxn], len[maxn];
int wh[maxn];
int wh[maxx];
int wha = 0;
int whb = 0;
int whcnv;
int whdeath = -1;
int whgo = -1;
int whmax = -1;
int whme = -1;
int whmerge1 = -1;
int whmerge2 = -1;
int wht = -1;
int x = (i - a + n) % n;
int x = 0;
int x = 2;
int x = 3 * i + 1;
int x = cur.first;
int x = edges[i].a;
int x = h21 + h32 - h31;
int x = q.front();
int x = rand() % n;
int x, id;
int x, kv, t;
int x, p, q;
int x, t, add;
int x, t, y1, y2;
int x, t;
int x, y, z, dir;
int x, y1, y2;
int x, y;
int x1 = 0;
int x1, y1, x2, y2, t;
int x1, y1, x2, y2;
int x1[maxn], x2[maxn], y1[maxn], y2[maxn];
int x2 = 0;
int x;
int x[maxk], y[maxk], id[maxk];
int x[maxn * 2];
int x[maxn], y[maxn];
int x[maxn];
int xc, yc;
int xr = x + lenx;
int y = (i + a) % n;
int y = 3 * j + 1;
int y = cur.second;
int y = edges[i].b;
int y = h21 - x;
int y = rand() % n;
int y = x + len - 1;
int y;
int yr = y + leny;
int z = h31 - y;
iscolored(cx - 1, cy) = true;
iscolored(cx, cy) = true;
isend = false;
isme = true;
it = str.find(hash);
it--;
itnext++;
itprev--;
j = i;
job[i].id = i + 1;
job[n + 1].c = 1;
job[n + 1].id = 0;
job[n + 1].s = 2e9 + 1;
job[n + 1].t = 1;
job[n].c = 0;
job[n].id = 0;
job[n].s = 0;
job[n].t = 0;
k *= 2;
k += 2;
k -= next.id - cur;
k /= 2;
k = min(k, n);
k++;
k--;
k[0][j][0] = k[1][j][0];
k[0][j][1] = k[1][j][1];
k[0][j][2] = k[1][j][2];
k[1] = max(0, k[1] - k[3]);
k[1][j][0] %= mod;
k[1][j][0] += 1 + k[0][j - 1][1];
k[1][j][0] = (k[1][j - 1][1] + k[0][j][0]) % mod;
k[1][j][1] %= mod;
k[1][j][1] += 1 + k[0][j - 1][1];
k[1][j][1] = k[1][j - 1][1];
k[A]++;
k[num] = 0;
k[num]++;
kans -= 2;
kans = 0;
kans = bestmatchans.length();
kar.resize(0);
kbl = (n - 1) / BSZ + 1;
ke = 0;
ke++;
ke[e[i].first]++;
ke[e[i].second]++;
kempty--;
kl[i] = curj;
km = (1 << n);
ko++;
ko--;
kr[i] = curj;
kt++;
kv *= 2;
kv += n;
kv = 0;
kv = 1;
kv++;
kv--;
kv0 = 0;
kv0++;
kv0--;
kv1 = 0;
kv1++;
kv1--;
kv1[0] = 1;
kv1[1] = 2;
kv2 = 0;
kv2--;
kv2[0] = 1;
kv2[1] = 2;
kv[0] = 0;
kv[0][0] = 1;
kv[1] = 0;
kv[a[i]]++;
kv[a]++;
kv[b]++;
kv[c] -= 2;
kv[cur + 1][0] = kv[cur][0];
kv[cur]--;
kv[cur][0] = 1;
kv[cure]++;
kv[i] = 0;
kv[i] = 1;
kv[i][a[i]]++;
kv[i][x].push_back(j);
kv[next]++;
kv[sob[i].t] += sob[i].add;
kv[t] = getsum(t, 1, l, r, 0, treesz - 1);
kv[wh][col].pop_back();
kv[wha][whb]++;
kv[whmerge1] += kv[whmerge2];
kv[x] = 1;
kvget[gr[cur][i]]++;
kvl[i] = 0;
kvl[i] = max(kvl[i], d - (m - k));
kvodd++;
kvr[i] = 0;
kvr[i] = min(kvr[i], k);
kvv[curv]++;
kwas = 0;
kwas++;
kx++;
ky++;
l += BSZ;
l = (r + l) / 2;
l = 0;
l = NULL;
l = _c;
l = copy(l);
l = cur->l;
l = cur;
l = d->l;
l = f;
l = get_right(l, l->size - 1);
l = new tnode(*l);
l = null;
l = wh->second;
l = x.l;
l = x;
l++;
l--, r--;
l->add = l->add + add;
l->p = null;
l->push();
l->r = merge(l->r, r);
l->r = null;
l->r = r;
l->up = lup;
l->update();
l1--;
l2--;
l[0] = 0;
last -= m;
last = 0;
last = 3 * m;
last = cur;
last = curlast;
last = got;
last = i;
last = l + 1;
last = last + len[i];
last = max(last, t);
last = min(last, 5);
last = next;
last++;
last.second -= cnt;
last[A[i]] = i;
last[B[i]] = i;
last[a[i]] = i;
lastx = sob[i].x;
lastx = sobx[i][j].x;
lastx = soby[i][j].x;
ld X, Y;
ld a, d;
ld a[maxn][maxn];
ld ans = 0;
ld ans1 = calc2(log1);
ld ans1 = fs * ft;
ld ans2 = calc2(log2);
ld ans2 = fs * ft;
ld ans;
ld ans[maxn];
ld answer = 0;
ld answer;
ld answerw;
ld calc2(ld &log)
ld curl = 0;
ld curpos = x[i] + v[i] * time;
ld curr = x;
ld fact[maxn];
ld ff, ft, fs, first, second, third;
ld getd(ld time)
ld kv[maxn][maxn];
ld l = 0;
ld last = 0;
ld log1 = log10(fs) + log10(ft);
ld log1, log2;
ld log1;
ld log2 = log10(fs) + log10(ft);
ld m = (r + l) / 2;
ld m1 = (2 * l + r) / 3;
ld m2 = (l + 2 * r) / 3;
ld maxa = -inf;
ld mind = 3e18;
ld mind = 6e18;
ld mind = inf;
ld minpos = inf, maxpos = 0;
ld minpos = max_x, maxpos = 0;
ld mins;
ld next = min(a[currid] - curr, a[curlid] - curl);
ld nx = x * cos(a) - y * sin(a);
ld ny = x * sin(a) + y * cos(a);
ld r = 1e10;
ld r = max_bound;
ld r = s - first;
ld r = s;
ld rotalpha = 0.23235489;
ld s = v * v / 2 / a;
ld t, v;
ld v[2][maxn * 3][maxn];
ld v[maxn], u[maxn], r[maxn], r1[maxn];
ld vp = (a - p[0]) * (b - p[0]);
ld x = l * (1 - 1.0 * v1 / (v1 + v2));
ld x, y;
left++;
left\n\
lem l[maxn];
len /= 2;
len--;
len[i] = strlen(p[i]);
len[i] = strlen(s[i]);
len[i] = strlen(t + last);
leninp = 0;
lenx[i] += n - lastx;
lenx[i] = 0;
leny[i] += m - lastx;
leny[i] = 0;
lift(cur);
like[0] = true;
like[a] = true;
line(pt<ll> p1, pt<ll> p2, int _id)
lines.resize(0);
link(a, b);
link.resize(0);
live[pr] = false;
ll *a = new ll[n / 2];
ll *b = new ll[n / 2];
ll *ra = new ll[n / 2];
ll *rb = new ll[n / 2];
ll A, B, C;
ll A, B, M;
ll A, B;
ll B;
ll MINF;
ll MOD;
ll X, D;
ll a = ((ll)n) * (n - 1) * (n - 2) / 6;
ll a, b;
ll a, ll b, ll mod;
ll a;
ll a[64];
ll a[maxn], b[maxn], cnk[maxn];
ll a[maxn], b[maxn];
ll a[maxn];
ll a[maxn][maxn][2][2], b[maxn][maxn][2][2];
ll addx = 0;
ll all = 0;
ll all = 1LL << k;
ll ans = ((ll)(n + 2)) * (n + 1) / 2;
ll ans = 0;
ll ans = 1;
ll ans = get(t - 1, x - (1LL << sz), sz - 1) + kv[sz][t];
ll ans0[MAX], ans1[MAX], ansk[MAX];
ll ans1 = 0;
ll ans2 = 0;
ll ans;
ll ans[20][20][2];
ll ans[2][2];
ll ans[maxn];
ll ans[maxn][maxn];
ll ans[maxn][maxn][maxn];
ll ans_alw = l;
ll ans_can = l;
ll ansa[maxn], ansb[maxn];
ll ansb = 1;
ll ansh = 1;
ll ansk[maxn], ansa[maxn], ans[maxn];
ll ansl[maxn][2], ansr[maxn][2];
ll ansup[maxn], ansdown[maxn];
ll ansv = 1;
ll answer = -llinf;
ll answer = 0;
ll answer = 1;
ll answer = ans.mod;
ll answer = m->sum;
ll answer, addingm, addingnm;
ll answer, curans;
ll answer1 = 0;
ll answer;
ll answer[maxn];
ll answerall[maxn][maxn];
ll answerx = 0, answery = 0;
ll az = mul(b, powmod(a, i));
ll b = ((ll)m) * (n - 2);
ll b = powmod(ab->b, n - 2);
ll bestanswer = llinf;
ll bestsq = 0;
ll bound = a[i] + t;
ll bound = df[from[i]] + (m - msum[i]);
ll bsqrt = 2;
ll c = powmod(b, MOD - 2);
ll c;
ll calc(int l, int r, int whmax)
ll calc(ll m)
ll can = sum[k - 2];
ll clast = m * q[eo - 1].a + q[eo - 1].b;
ll cnt = 1;
ll cntnodes = 0;
ll cur = (l - 1) / dmax + k;
ll cur = 0;
ll cur = 1;
ll cur = A * curadd;
ll cur = from[nnext];
ll cur = i;
ll cur = m * a + b;
ll cur = o.front();
ll cur = ost[0];
ll cur1 = 0;
ll cur2 = 0;
ll cur3 = 0;
ll cur;
ll curB = -x[i];
ll curans = -inf;
ll curans = 1;
ll curans = getdist(curx, cury);
ll curans = k + sum;
ll curansa = ansa[cx];
ll curansb = ansb[cy];
ll curanswer = getdist(curx, cury);
ll curd = 0;
ll curf = 1;
ll curgo = 1e8;
ll curh = 0;
ll curkv = 1;
ll curp = mods[0];
ll cursum = 0;
ll curv = curans.first - curans.second + v[cur];
ll curx = rand() % (2 * inf) - inf;
ll curx = x[i] - cx;
ll cury = rand() % (2 * inf) - inf;
ll cury = y[i] - cy;
ll d = 0;
ll d = __gcd(answer, (ll)n);
ll d[maxn][maxn];
ll df[maxn], dfb[maxn];
ll dfs(int cur, ll maxf)
ll dist = d(answer.first - answer.second);
ll divmod(ll a, ll b)
ll dmax = (r - l + k - 1) / k;
ll ex = x[i] + dx[d[i]] * len[i];
ll ex[maxn];
ll ey = y[i] + dy[d[i]] * len[i];
ll f = min(ex[cur->u], cur->maxf - cur->f);
ll f, maxf;
ll fib(int x)
ll flow;
ll fn = getf(mod);
ll gcd = __gcd(abs(n.x), abs(n.y));
ll gcd(ll a, ll b)
ll get(ll t, ll x, ll sz)
ll get(ll x, ll y)
ll get(pnode cur, ll cl, ll cr, ll x)
ll get_num(const string &cur)
ll getbest(ll me, ll tot)
ll getdist(ll cx, ll cy)
ll getf(ll x)
ll getsum(int lx, int rx)
ll getsum(ll b)
ll getworst(ll me, ll tot)
ll gr[maxn][maxn];
ll h = 0;
ll h[maxn][maxn];
ll hash = 0;
ll hash[maxn];
ll have = B - curneed;
ll have[20][20];
ll inf = 1LL << 50;
ll k = (t[0].a + t[0].b) / 4;
ll k = 1;
ll k = sqrt(fn) + 1;
ll k;
ll k[2][maxn][4];
ll kv[100][100];
ll kv[maxn][maxk];
ll kvo = 0;
ll l = -1;
ll l = 0;
ll l = 1;
ll l = b[li];
ll l, r;
ll l;
ll l = -1e15;
ll last = curans;
ll len = xs[cx] - xs[cx - 1];
ll len = ys[cy] - ys[cy - 1];
ll m = (cl + cr) / 2;
ll m = (l + r) / 2;
ll m, v, id;
ll m;
ll mask1 = sums[i].second;
ll mask2 = sums[i - 1].second;
ll maxX = x[j + 1] - 1;
ll maxb = min(n / x, (n + x - l) / x);
ll maxcurlvl = (2 * all) >> lvl;
ll maxi = min(n, (ll)maxn);
ll maxr = sqrt(n) + 3;
ll maxsum;
ll maxw = -1;
ll maxx = p[i].x + ans[p[i].id];
ll maxy = C / B;
ll mid = (l + r) / 2;
ll minX = max(x[i], x[j] - 1);
ll minb_x = x + 1;
ll minb_y = (n / (x + 1)) + 1;
ll mind = inf;
ll mind = llinf;
ll mindx = linf;
ll mindy = linf;
ll minx = p[i].x - ans[p[i].id];
ll mmax = need * need;
ll mod, st2;
ll mod;
ll msum[maxn];
ll mul(ll a, ll b)
ll mul(ll a, ll b, ll mod)
ll n, k, h;
ll n, k;
ll n, l, r;
ll n, l, v1, v2;
ll n, m, k;
ll n, need, x, y;
ll n, t;
ll n;
ll need = 0;
ll need = k - cur;
ll need;
ll newy = p[i].y + ans[p[i].id];
ll next = cur | (1LL << (i + j));
ll next = cur | (1LL << (i - j));
ll next = cur | (1LL << j);
ll nm = 1 << n;
ll nold = n;
ll nwas = n;
ll p = n;
ll p;
ll pk = powmod(p, k, inf);
ll pos = wh[i].first * k + wh[i].second;
ll pos = wh[j].first * k + wh[j].second;
ll powmod(ll a, int b)
ll powmod(ll a, ll b)
ll powmod(ll a, ll b, ll mod)
ll pr = 1;
ll r = 1LL << n;
ll r = 1e15;
ll r = 2 * n + 5;
ll r = 2e18;
ll r = b[ri];
ll r = inf;
ll res[maxk][MAX];
ll s;
ll set;
ll sq = 0;
ll sq1 = p[i] * p[j];
ll sq2 = p[j] * p[i];
ll sqall = 0;
ll st1[maxn], st2[maxn];
ll st[105];
ll sum = 0;
ll sum = 1;
ll sum = a[i];
ll sum = getsum(b);
ll sum2 = (sum + 1) % mod;
ll sum;
ll sum[maxn];
ll sum[maxn][maxn];
ll suma = 0;
ll sumb = 0;
ll suml = 0;
ll sumq;
ll sx[maxn], sy[maxn];
ll t = a;
ll t = mask1 & mask2;
ll t = sqrt(x);
ll t[maxn];
ll tmp = 2;
ll tmp = a;
ll tmp = n;
ll tmp[2][2];
ll to_push;
ll to_return[maxn];
ll vp = (a - minpsort) * (b - minpsort);
ll vp = a * b;
ll vp = a.n * b.n;
ll w, h;
ll w1[MAX], w2[MAX];
ll w;
ll w[maxn];
ll wh = (ids[i] + all) >> lvl;
ll wh = a[i];
ll whother = (wh * 2 + wh * 2 + 1) - whwe;
ll whwe = (ids[i] + all) >> (lvl - 1);
ll x = p[m].x;
ll x = rand() % p;
ll x = sum - o[bo].x0;
ll x = xs[cx] + addx;
ll x, y;
ll x0, y0;
ll x;
ll x[5], y[5], xn[5], yn[5];
ll x[arrsz];
ll x[maxn], y[maxn], len[maxn];
ll x[maxn];
ll y = ys[cy] + addy;
ll y;
ll y[maxn];
ll z1 = ((c - a) * (b - a)) * ((d - a) * (b - a));
ll z2 = ((a - c) * (d - c)) * ((b - c) * (d - c));
lleft[curpl] = compress(cur->l);
log = log10(ff) + log10(fs) + log10(ft);
long double ans[maxn][maxn];
long double answer = 0;
long long answer = 0;
long long answer;
long long h[maxn], st[maxn];
long long kv = 1, answer = 0; ;
long long pr = 1;
long long x1, x2, a, b;
lp = null;
lp.push(l.pop());
lx[i] = 0;
lx[i] = y[i] - sqrt(l);
m -= n;
m /= i;
m = (stable_partition(p, p + n, cmp) - p);
m = md(a + c) / 2;
m = merge(m->l, m->r);
m = strlen(bs);
m >>= 1;
m++;
m--;
m->add = m->add + v;
m->reverse = true;
m->x = change0(cur, m->x);
m->x = change2(cur, m->x);
ma[0][0] = (a[0] + b[0]) % 2;
ma[0][n] = c[0];
ma[i][n] = c[i];
make_root(a);
make_root(b);
make_root(cur);
make_root(l);
make_tree(1, 0, treesize - 1);
make_tree(1, 0, treesize - 1, n);
make_tree(cur * 2 + 1, cm + 1, cr);
make_tree(cur * 2 + 1, cm + 1, cr, n);
make_tree(cur * 2, cl, cm);
make_tree(cur * 2, cl, cm, n);
make_with(cur * 2 + 1, add[cur]);
make_with(cur * 2, add[cur]);
make_with(cur, 1);
map<int, int> data;
map<int, int>::iterator pos = data.find(x - add);
map<int, ll> which[maxn];
map<ll, int> was;
map<ll, int> wins;
map<pos, double> poss;
map<pos, pos> poss;
map<ll, int> s;
map<ll, ll> from;
mark[T] = 1;
mask[i] |= (x << j);
match(i, k, j, last, cost);
maxX = min(minX + have / (j + 1), maxX);
maxa = (ans[j] - ans[i]) * 1.0 / (j - i);
maxa = max(maxa, i - begin + 1);
maxans += curmax;
maxans = max(maxans, curans);
maxans = max(maxans, sleep - time);
maxans[i][j] = 0;
maxc = s[i];
maxd[cur] = 0;
maxd[cur] = max(maxd[cur], maxd[gr[cur][i]] + 1);
maxf -= curflow;
maxf = _maxf;
maxf = max(max1 + max2 + h, max(maxs1, maxs2));
maxf[0] = inf;
maxj = j;
maxkv = max(kv1, kv2);
maxlvl = max(maxlvl, x + sz + 1);
maxlvl = max(x, maxlvl);
maxo = a[res][i];
maxpos = curpos;
maxr[i][n] = n;
maxr[l] = max(maxr[l], r);
maxs1 += a[i].x;
maxs2 += a[i].x;
maxsteps = 1;
maxt = max(maxt, cur);
maxtime = time[i];
maxup[0][i] = (p[0][i] == '.' ? -1 : 0);
maxv = v[i];
maxw = w[i];
maxwh = i;
me--;
memcalc[l][r] = false;
memcpy(b, a, sizeof b);
memgo[l][r][nl] = false;
memset(a, 0, sizeof a);
memset(a, 0, sizeof(a));
memset(a[m + 1], 0, sizeof(a[m + 1]));
memset(add, 0, sizeof(add));
memset(ans, 0, sizeof ans);
memset(ans, 0, sizeof(ans));
memset(ans0, 0, sizeof(ans0));
memset(ans1, 0, sizeof(ans1));
memset(ans2, 0, sizeof(ans2));
memset(ans3, 0, sizeof(ans3));
memset(ansa, 0, sizeof(ansa));
memset(ansb, 0, sizeof(ansb));
memset(ansk, 0, sizeof(ansk));
memset(answer, 0, sizeof(answer));
memset(bmax, 0, sizeof(bmax));
memset(bmin, 0, sizeof(bmin));
memset(c, 0, sizeof(c));
memset(can, 0, sizeof can);
memset(can, 0, sizeof(can));
memset(can, false, sizeof(can));
memset(canall, 0, sizeof canall);
memset(canans, 0, sizeof canans);
memset(cnt1, 0, sizeof cnt1);
memset(cnt2, 0, sizeof cnt2);
memset(curv, 0, sizeof curv);
memset(dp, 63, sizeof(dp));
memset(e, 0, sizeof(e));
memset(ex, 0, sizeof(ex));
memset(f, 0, sizeof(f));
memset(gr, 0, sizeof(gr));
memset(h, 0, sizeof(h));
memset(have, 0, sizeof have);
memset(id, 0, sizeof(id));
memset(k, 0, sizeof(k));
memset(ke, 0, sizeof(ke));
memset(kv, 0, sizeof kv);
memset(kv, 0, sizeof(kv));
memset(kvget, 0, sizeof kvget);
memset(ma, 0, sizeof(ma));
memset(mark, 0, sizeof(mark));
memset(ncan, 0, sizeof(ncan));
memset(need, false, sizeof(need));
memset(next, 0, sizeof(next));
memset(sett, 0, sizeof(sett));
memset(sub, 0, sizeof(sub));
memset(sum, 0, sizeof sum);
memset(sum, 0, sizeof(sum));
memset(sumcol, 0, sizeof sumcol);
memset(sumrow, 0, sizeof sumrow);
memset(tmp, 0, sizeof(tmp));
memset(use1, 0, sizeof(use1));
memset(use2, 0, sizeof(use2));
memset(v, 0, sizeof(v));
memset(was, 0, sizeof(was));
memset(was, false, sizeof(was));
memset(was1, 0, sizeof(was1));
memset(was2, 0, sizeof(was2));
memset(wascol, 0, sizeof wascol);
memset(wasrow, 0, sizeof wasrow);
mergeall(cur->l, to, leftsize);
mergeall(cur->r, to, leftsize + getsize(cur->l) + 1);
mergetime = intersect(i, j);
min = x;
mina = a;
mina[i][0].id = i;
minans = abs(a - m0) + abs(b - m1) + abs(c - m2);
minans = inf;
minans0 = a;
minans1 = b;
minans2 = c;
minb = a[i][n + m + 1];
minb = b;
minbl = curbl;
mind = abs(cur - curpl);
mind = abs(curl - curpl);
mind = abs(curr - curpl);
mind = curd;
mind = d(p[i] - p[j]);
mind = dist[i][j];
mind = min(mind, d[gr[cur][i]]);
mind = min(mind, t.first);
mind[cur][0] = 0;
mind[cur][0] = t0;
mind[cur][1] = 0;
mind[cur][1] = t1;
mind[cur][2] = 0;
mind[cur][2] = t2;
mind[cur][3] = 0;
mind[cur][3] = t3;
mind[cur][4] = 0;
mind[cur][4] = t4;
mindist = d[i];
mindt = dt[t];
mindx = curd;
mindy = curd;
minel[0] = 0;
minel[curans] = min(minel[curans], a[i]);
mines.pop_back();
mines.push_back(0);
mines.push_back(min(mines.back(), sums.back()));
mines.resize(0);
minf = min(min1 + min2 + h, min(mins1, mins2));
minlen = min(minlen, p[i].len);
minlen--;
mino = a[j][b] / a[j][i];
minpl = cur;
minpl = curl;
minpl = curr;
minpos = curpos;
minpsort = minp;
minr[l] = min(minr[l], r);
mins = s[i].s * 1.0 / s[i].q;
mins1 += a[i].x;
mins2 += a[i].x;
minus = !minus;
minv = v[i];
minwh = i;
minwh = j;
minx = i;
minx = min(minx, p[i].x);
miny = i;
miny = min(miny, p[i].y);
miter it = wins.find(whother);
miter my = which[cur].begin();
mod = _mod;
mod = a;
mods.resize(0);
mr1 = max(mr1, fl[c1][j]);
mr12 = max(mr12, fl[c1][i]);
mr2 = max(mr2, fl[c2][j]);
mr22 = max(mr22, fl[c2][i]);
ms[0] = 0;
msum[0] = a[0];
msum[i] = a[i];
msum[i] = msum[i - 1] + a[i];
mymap with0, without0;
n *= 2;
n += N;
n /= 2;
n /= i;
n = 0;
n = 1026;
n = 2 * k + 2;
n = 250;
n = n * m + 2;
n = n + 2;
n = n / dn;
n = n / i;
n = nextn;
n = pts.size();
n = s.length();
n = strlen(as);
n = strlen(m);
n = strlen(s);
n >>= 1;
n++;
n--;
n.id = id;
n.x /= gcd;
n.x = -v.y;
n.x = -(b.y - a.y);
n.x = -(c.y - a.y);
n.y /= gcd;
n.y = (b.x - a.x);
n.y = (c.x - a.x);
n.y = v.x;
namel[i] = name[i];
namer[i] = namel[i];
namespace std
ncan[c1][c2] = 1;
ncan[c2][c1] = 1;
ndir = 0;
ndir++;
ndir--;
near[i][j] = last;
near[i][j] = min(last, near[i][j]);
need = (answer ^ n);
need = lenx[i] - need;
need = leny[i] - need;
need |= (1LL << a);
need |= wh(i, j, k);
need[0] = true;
need[ing[gr[cur][i]][j]] = true;
next = NULL;
next = _next;
next = i * m + (j - 1) + 1;
next++;
next->make();
next[a[i]] = i;
next[ansl[i][c1]].push_back(ansr[i + 1][c2] + 1);
next[i] = last[a[i]];
next[i][s[i + 1] - 'a'] = i + 1;
next[l] = r;
next[prev[wh]] = next[wh];
next[prev[wh]] = wh;
next[ssum] = i;
next[ssum] = n;
nextdir = (nextdir + 1) % 4;
nexte = gr[cur][nextdir];
nextedge[cur] = 0;
nextedge[cur]++;
nextfr = from[mask];
nextfr.push_back(i);
nextn -= len;
nextp.wh[i].first = next;
nextp.x = cur.x + 1;
nfact = 0;
nfact++;
norm = new pt[(kv + 5)];
normsize = cnv.size() - 1;
now = deathtime;
now = mergetime;
now[x] = t;
null = new tnode(pt(0, 0), pt(0, 0));
null = new tnode;
null = tnode::null;
null->l = null;
null->r = null;
null->size = 0;
null->sum = 0;
null->x = 0;
nwas /= 2;
nwas--;
nx[i]--;
o = _o;
o.pop();
o.pop_front();
o.push(2);
o.push(a);
o.push(cur);
o.push(cur->v);
o.push(make_pair(x, y));
o.push(next);
o.push_back(make_pair(0, 0));
o.push_back(make_pair(x, y));
o.push_front(make_pair(x, y));
o1 = (h / b) % k1;
o1 = 0;
o2 = (w / a) % k2;
o2 = 0;
o[bo] = tp(-1, 0, 0);
o[eo++] = curp;
o[eo] = 0;
o[eo] = S;
o[eo] = cur + 1;
o[eo] = cur - 1;
o[eo] = i;
o[eo] = make_pair(aarr1[i], i);
o[eo] = make_pair(x, y);
o[eo] = n - 1;
o[eo] = next;
o[eo] = wh;
ob.push_back(p[0]);
ob.push_back(p[1]);
ob.push_back(p[i]);
ob.resize(0);
odd = t;
ok = check(pts[j], 2) && check2(pts[i], pts[j]);
ok = true;
on[d] = 0;
on[d] = 1;
op1();
op2();
op3();
open = t + 1;
opens[i].push_back(MAX_TIME);
opens[i].push_back(open);
opens[i].push_back(t - 1);
opp[a].push_back(gr[b].size());
opp[b].push_back(gr[a].size());
ord[i].push_back(make_pair(0, i));
order[place] = best;
osp1[i] = 1.0 / (1 + nf + ne);
osp2[i] = 1.0 / (1 + nf + ne);
ost.resize(0);
ostream& operator << (ostream &out, const pt &a)
ostream& operator << (ostream &out, const ptd &a)
ostream& operator << (ostream &out, const tv &a)
ostream& operator << (ostream &out, tedge a)
ostream& operator << (ostream& out, const pt &a)
ostream& operator <<(ostream &out, const mymap &a)
ostream& operator <<(ostream &out, const pt &a)
ostream& operator <<(ostream &out, const tmap &a)
otn[kg - 1] = (double)(cnt) / cur;
oure = i;
out << "(" << a.x << ", " << a.y << ")";
out << "(" << a.x << ' ' << a.y << ")";
out << a.x << ' ' << a.y;
out(a + b + c);
out(a + b);
out(a);
out(pt(0, 0));
out.clear();
out.push_back(make_pair(i, t));
outwrite();
outwrite(1, 0);
outwrite(a + 1, b, 0);
outwrite(a + 1, b, 1);
outwrite(a, b - 1, 0);
outwrite(a, b - 1, 1);
outwrite(cur);
outwrite(from[cur]);
outwrite(from[cur], deep + 1);
outwrite(i + 1, i, 0);
outwrite(i + 1, i, 1);
outwrite(i);
outwrite(n);
p = get(root[x], 0, maxn - 1, y) + 1;
p = new pt[(kv + 5)];
p = null;
p--;
p->l = A;
p->l = B;
p->p = cur;
p->r = B;
p->r = C;
p1 = -1;
p1 = best.second;
p1 = cur->x.second;
p1 = o[bo].first.second;
p1[n] = p1[0];
p2 = -1;
p2 = barr[i].second;
p2 = barr[id].second;
p2 = getans(m).second;
p2[m] = p2[0];
p[0] = 0;
p[0][j] = '#';
p[1] = 1;
p[2] = 2;
p[a] = b;
p[b] = a;
p[cur.x][cur.y] = 'X';
p[cur] = pr;
p[cur][0] = pr;
p[gr[cur][i]] = cur;
p[gr[i][j]] = -1;
p[i + n].id = (i + 1);
p[i + n].id = i;
p[i]--;
p[i].id = -(i + 1);
p[i].id = i + 1;
p[i].id = i;
p[i].len = p[i].r - p[i].l + 1;
p[i].newx = lower_bound(x, x + kx, p[i].x) - x;
p[i].rotate(rotalpha);
p[i].x -= xc;
p[i].x = (ll)(X * 2 + eps);
p[i].x = rand() % (2 * inf + 1) - inf;
p[i].x = x;
p[i].y -= yc;
p[i].y = (ll)(Y * 2 + eps);
p[i].y = rand() % (2 * inf + 1) - inf;
p[i].y = y;
p[i][0] = '#';
p[i][0] = i;
p[i][j] = c - 48;
p[i][j] = c;
p[i][j] = make_pair(i, j);
p[i][m + 1] = '#';
p[j].len--;
p[m] = tp(n + 1, n + 1);
p[n + 1][j] = '#';
p[n + j] = pt(X, Y);
p[n] = p[0];
p[num] = i;
p[p1.first][p1.second] = p2;
p[p2.first][p2.second] = p1;
p[pchwh[curcnt]] = pchx[curcnt];
p[x][y] = make_pair(-1, adj[0]);
p[x][y] = make_pair(-1, kv);
pair<double, double> ans[maxk];
pair<int, int> a[maxn];
pair<int, int> ans[maxnsmall][maxnsmall];
pair<int, int> answer[maxm], re[maxm];
pair<int, int> b[maxn];
pair<int, int> cur = o.front();
pair<int, int> cur = o[bo];
pair<int, int> e[2 * maxn * maxn];
pair<int, int> e[maxm];
pair<int, int> e[maxn];
pair<int, int> edges[maxm];
pair<int, int> how[27];
pair<int, int> last = q.top();
pair<int, int> o[maxn * maxn * 10];
pair<int, int> p1 = find(x1, y1);
pair<int, int> p2 = find(x2, y2);
pair<int, int> p[maxn][maxn];
pair<int, int> p[maxs][maxs];
pair<int, int> sm[maxn][maxn];
pair<int, int> t = go2(gr[cur][i], curd + 1, cur);
pair<int, int> t = intersect(l[curl], r[curr]);
pair<int, int> tmp[maxn];
pair<int, int> x, ans;
pair<ll, int> goods[maxkg];
pair<ll, int> now = q.top();
pair<ll, ll> curans = make_pair(0, 0);
pair<ll, ll> res = go(0, -1);
pair<ll, ll> t = go(gr[cur][i], cur);
pair<ll, ll> wh[maxn];
pair<ll, pt> cur = q.top();
pair<pair<int, int>, int> o[maxn * 2];
pair<pt, pt> *get_left(pnode cur)
pair<pt, pt> *res = get_left(cur->l);
pair<pt, pt> *res = upper_bound(cur->l, x);
pair<pt, pt> *upper_bound(pnode cur, pt x)
pair<pt, pt> *wh1 = upper_bound(root, v);
pair<pt, pt> *wh2 = upper_bound(root, -v);
pair<pt, pt> ansl = solve(p, m);
pair<pt, pt> ansr = solve(p + m, n - m);
pair<pt, pt> answer = ansl;
pair<pt, pt> answer;
pair<pt, pt> answers = solve(p, n);
pair<pt, pt> solve(pt *p, int n)
pair<pt, pt> v[maxn];
pair<pt, pt> x;
pair <T*, T*> *next = in->left();
pair <T*, T*> *next = in->right();
pair <T*, T*> *wh = in->left();
pair <T*, T*> *wh = in->right();
pair <T*, T*> *wh = new pair <T * , T*>;
pair <int, int> e[maxn];
pair <int, int> go2(int cur, int curd, int pr)
pair <ll, ll> ans = euclid(b, a % b);
pair <ll, ll> sums[maxx];
paired[i] = was[p[i]];
paired[was[p[i]]] = i;
parbegin++;
parse(parbegin);
pchwh[curcnt] = a;
pchwh[curcnt] = b;
pchx[curcnt] = p[a];
pchx[curcnt] = p[b];
perm[n] = perm[0];
pivot(i, minwh, n, m, b, res);
pivot(j, i, n + m + 1, m, n + m + 1, m + 1);
pivot(n + m, minwh, n + m + 1, m, n + m + 1, m + 1);
pk[num] *= i;
pk[num] = 1;
pl[cur].push(id);
pl[curpl].push(t);
pl[edges[i].first][edges[i].second] = '.';
pl[i].pop();
pl[minpl].pop();
pm[i] *= i;
pm[i] = 1;
pn[i] *= i;
pn[i] = 1;
pnode A = cur->l;
pnode A = p->l;
pnode B = cur->l;
pnode B = cur->r;
pnode C = cur->r;
pnode C = p->r;
pnode add(pnode cur, char *s, int curpos, int len)
pnode ans = &tree[++cnt];
pnode ans = new tnode(make_pair(0, cur));
pnode ans = newnode(0);
pnode change(pnode cur, int cl, int cr, int x, int y)
pnode copy(pnode cur)
pnode cur = new tnode();
pnode cur = new tnode(a[m]);
pnode cur = slink[a];
pnode cutleft(pnode cur)
pnode doerasemax(pnode cur)
pnode domax(pnode &cur)
pnode domin(pnode &cur)
pnode go(int cur, int pr, int m)
pnode i1 = new tnode(v, wh1->second);
pnode i2 = new tnode(-v, wh2->second + v);
pnode l = slink[a], r;
pnode l, m, r;
pnode l, m1, m2, r;
pnode l, r, m;
pnode l, r;
pnode m = new tnode(x);
pnode m[maxn], ver[maxn];
pnode make(int cl, int cr)
pnode make_splay(int l, int r)
pnode make_splay(int l, int r, int *a)
pnode merge(pnode l, pnode r)
pnode mymerge(pnode a, pnode b)
pnode newnode(int x)
pnode null;
pnode p = cur->p;
pnode pp = p->p;
pnode pr = cur;
pnode r = newnode(x);
pnode root = NULL, tnode::null = NULL;
pnode root = NULL;
pnode root = new tnode;
pnode root, null;
pnode root;
pnode root[maxn];
pnode slink[maxn];
pnode t = go(gr[cur][i], cur, m);
pnode t = m;
pnode t = new(tnode);
pnode tnode::null = NULL;
pnode wa = where(a);
pnode wb = where(b);
pnode wb = where(wa->up);
pnode where(int a)
pnode x = new tnode;
point.x = -(double)(a.c * b.n.y - a.n.y * b.c) / det;
point.y = -(double)(a.n.x * b.c - a.c * b.n.x) / det;
pop();
pos += (i / k) * k;
pos += x;
pos = (pos % n + n) % n;
pos ans;
pos cur = o.front();
pos cur = o.top();
pos cur = poss[nextpos];
pos last = cur;
pos make(int kv)
pos nextp = cur;
poss[a] = ver;
poss[cur] = last;
pp[a] = b;
pp[b] = a;
pp[kv] = kv;
ppow(ab, n - 1);
pq.pop();
pq.push(make_pair(0, 0));
pq.push(make_pair(curd + c[cur][i], gr[cur][i]));
pr = cur;
pr = l;
pr = pr * i;
pr = pr * p[i];
pr--;
pr[b] = a;
pr[cur] = beg;
pr[i] = i;
prep();
preparelca();
prev += cur;
prev = -1;
prev = a[0];
prev = a[cur1];
prev = a[i];
prev = b[0];
prev = b[cur2];
prev = b[i];
prev = v[0];
prev = v[i];
prev--;
prev[0] = n;
prev[next[wh]] = prev[wh];
prev[next[wh]] = wh;
prev[r] = l;
print(1, n);
print(cur, "find1 ");
print(cur->l, cur, s + '\t');
print(cur->l, t + '\t');
print(cur->l, tab + "\t");
print(cur->r, cur, s + '\t');
print(cur->r, t + '\t');
print(cur->r, tab + "\t");
print(l, r);
print(root, "");
print_me_to_array(a, left, midl, aarr1);
print_me_to_array(a, lenl - (b->size - 1), lenr, aarr1);
print_me_to_array(a, midr, right, aarr2);
print_me_to_array(b, 0, b->size, barr);
print_me_to_array(cur->l, l, r, arr);
print_me_to_array(cur->r, l - me - 1, r - me - 1, arr);
printf(" %d", cur1);
printf(" %d", n + cur2);
printf("%.10lf\n", d[1]);
printf("%.10lf\n", n * kv - answer);
printf("%.1f\n", ans);
printf("%.6f\n", (double)last);
printf("%.7Lf\n", answer);
printf("%.7lf\n", answer);
printf("%.7lf\n", get(0, S));
printf("%.8Lf %.8Lf", l, getd(l));
printf("%.8Lf", p[0].y * p[1].x);
printf("%.8Lf\n", answer);
printf("%.9Lf\n", ans[i][j]);
printf("%.9f", answer);
printf("%02d", ans[i]);
printf("%c", a[next.id]);
printf("%c", c1);
printf("%c", s[i]);
printf("%c\n", (ok ? 'Y' : 'N'));
printf("%d ", b[pos]);
printf("%d ", cur + 1);
printf("%d ", cur);
printf("%d ", cur->x);
printf("%d ", lvl);
printf("%d ", st1.size());
printf("%d ", st2.size());
printf("%d ", st3.size());
printf("%d %d %d %d\n", 0, emptyy, n - need, emptyy);
printf("%d %d %d %d\n", emptyx, 0, emptyx, m - need);
printf("%d %d %d\n", nextpos.x, nextpos.y, nextpos.z);
printf("%d %d %d\n", x, y, z);
printf("%d %d\n", (int) - 1e8, (int) - 1e8 + 3);
printf("%d %d\n", (int)1e8, (int) - 1e8 + 3);
printf("%d %d\n", 0, 0);
printf("%d %d\n", 0, 3);
printf("%d %d\n", 3, 0);
printf("%d %d\n", a.x, a.y);
printf("%d %d\n", curx, cury);
printf("%d %d\n", i + 1, gr[i][gr3[i][j]] + 1);
printf("%d %d\n", n * m + 1, empty);
printf("%d %d\n", n, m);
printf("%d %d\n", pts[0].x, pts[0].y);
printf("%d %d\n", pts[cur].x, pts[cur].y);
printf("%d %d\n", wh * m + pos + 1, empty);
printf("%d", 1);
printf("%d", ans[i]);
printf("%d", answer);
printf("%d", cnt);
printf("%d", curgr.size());
printf("%d", g[i]);
printf("%d", kcol);
printf("%d", krow);
printf("%d", n + 1);
printf("%d", sz[i]);
printf("%d+%d\n", i, j);
printf("%d-%d\n", i, j);
printf("%d/%d\n", points, n * (n - 1) / 2);
printf("%d:", i);
printf("%d<<%d\n", i, k);
printf("%d\n", (int)((sqrt(d2) - eps) / 5) + 1);
printf("%d\n", (int)ans);
printf("%d\n", (int)ans[km - 1]);
printf("%d\n", (last1 > last0 ? 1 : 0));
printf("%d\n", *st[t].x);
printf("%d\n", 0);
printf("%d\n", 1);
printf("%d\n", 2);
printf("%d\n", 3);
printf("%d\n", 4);
printf("%d\n", a + 1);
printf("%d\n", ans);
printf("%d\n", ans.first);
printf("%d\n", ans.size());
printf("%d\n", ans[0][n - 1]);
printf("%d\n", answer);
printf("%d\n", answer.size());
printf("%d\n", b + 1);
printf("%d\n", bestanswer);
printf("%d\n", calc(root));
printf("%d\n", cnt / 2 - 1);
printf("%d\n", d[i]);
printf("%d\n", d[i][j][k]);
printf("%d\n", deep + 1);
printf("%d\n", dist[a][b]);
printf("%d\n", get(1, 0, treesize - 1, l, r));
printf("%d\n", get(a, b));
printf("%d\n", getans(root));
printf("%d\n", i + 1);
printf("%d\n", k);
printf("%d\n", kv);
printf("%d\n", n);
printf("%d\n", p);
printf("%d\n", powmod(n));
printf("%d\n", q[i + 1].pop());
printf("%d\n", r);
printf("%d\n", s[workers.top()].id);
printf("%d\n", t * n);
printf("%d\n%d %d\n", answer, ansx + 1, ansy + 1);
printf("%s S%02dE%02d\n", s[cur], i + 1, j + 1);
printf("%sNULL\n", t.c_str());
printf("%s\n", (can ? "YES" : "NO"));
printf("%s\n", (ok ? "Yes" : "No"));
printf("%s\n", pl[i]);
printf("%s\n", s[wh]);
printf("%u ", answer);
printf("-1\n");
printf("0");
printf("0\n");
printf("1\n");
printf("2\n");
printf("Already off\n");
printf("Already on\n");
printf("Baba\n");
printf("Bit\n");
printf("Case #%d: ", T);
printf("Case #%d: ", i + 1);
printf("Case #%d: ", testId);
printf("Case #%d: %.1f\n", T, ((double)(answer)) / 10);
printf("Case #%d: %d\n", T, ans);
printf("Case #%d: %d\n", T, ans[n - 1][s]);
printf("Case #%d: %s in move %d\n", T, answer.c_str(), ans);
printf("Case #%d: %s\n", T, ans ? "YES" : "NO");
printf("Case #%d: Impossible\n", T);
printf("Case #%d:", T);
printf("Case #%d:", T, ans);
printf("Case #%d:\n", T);
printf("DRAW\n");
printf("FIRST\n");
printf("NO\n");
printf("No answer\n");
printf("SECOND\n");
printf("Success\n");
printf("VICTORY\n");
printf("YES ");
printf("YES\n");
printf("\n");
printf("\n%d\n", answer.size());
printf("b1-b7\n");
printf("yes\n");
printf((was ? "NO\n" : "YES\n"));
printf(LLD " " LLD "\n", ans_alw, ans_can);
printf(LLD " " LLD "\n", cur, curp);
printf(LLD " " LLD "\n", x, y);
printf(LLD " " LLD, answer / d, n / d);
printf(LLD " ", answer);
printf(LLD " ", answer1);
printf(LLD "\n", ans);
printf(LLD "\n", ans[n]);
printf(LLD "\n", answer);
printf(LLD "\n", calc(0, n - 1, n));
printf(LLD "\n", curh - h);
printf(LLD "\n", getsum(l, r));
printf(cut ? "Disconnected\n" : "Connected\n");
printtree(cur->l);
printtree(cur->r);
printtree(m);
priority_queue<inq, vector<inq>, greater<inq> > q;
priority_queue<int, vector<int>, comp> workers;
priority_queue<int> good, bad;
priority_queue<ll, vector<ll>, greater<ll> > best;
priority_queue<pair<int, int> > q;
priority_queue<pair<ll, int> > q;
priority_queue<pair<int, int> > pq;
prlast = last;
prpr = pr;
pset merge(int cur, pset a, pset b)
pt *norm;
pt *p;
pt<double> center(0, 0);
pt<double> point;
pt<ll> n;
pt<ll> p[maxn];
pt<ll> v = p2 - p1;
pt a = pt(0, 0);
pt a, b, c, d;
pt a, b, c;
pt a, b;
pt add;
pt ans;
pt b = pt(0, 0);
pt bking_b = read();
pt c = pt(0, 0);
pt cur = o[bo];
pt cur = pt(0, 0);
pt cv = v[z];
pt d = pt(0, 0);
pt first, second;
pt ij = p[j] - p[i];
pt minp = p[l];
pt minpsort;
pt n = -pt(x, y);
pt n = get_norm(a);
pt next = gr[cx][cy][i].first;
pt o[maxn * maxn];
pt obj;
pt p1, p2;
pt p1[maxn], p2[maxn];
pt p;
pt p[2 * maxn];
pt p[maxn], v[maxn], np[maxn];
pt p[maxn], v[maxn];
pt p[maxn];
pt pos0 = p[cur[1]] - p[cur[0]];
pt pos1 = pos0 + (v[cur[1]] - v[cur[0]]);
pt pts[10];
pt q1[maxn], q2[maxn], q3[maxn], q4[maxn];
pt v1 = p[b] - p[a];
pt v1 = p[getv(sortparam, a)] - p[sortparam];
pt v2 = p[c] - p[a];
pt v2 = p[getv(sortparam, b)] - p[sortparam];
pt wking, wrook1, wrook2, bking;
pt wking_b = read();
pt wrook1_b = read();
pt wrook2_b = read();
pt(int _x, int _y)
pt(ll _x, ll _y)
ptd ans;
ptd c1 = m + n * (tan(Pi / 6) * sqrt(d(b - a)) / 2);
ptd c2 = m + n * (tan(Pi / 6) * sqrt(d(c - a)) / 2);
ptd dir = ((c2 - c1) / dist) * r1;
ptd m = md(a + b) / 2;
ptd n;
ptd rr1;
ptd s = getpoint(a, b, c);
ptd s = getpoint(p[ans1], p[ans2], p[ans3]);
pts.erase(ny);
pts.insert(a[i].y);
pts.push_back(pt(x1, y1));
pts.push_back(pt(x1, y2));
pts.push_back(pt(x2, y1));
pts.push_back(pt(x2, y2));
pts.resize(2);
pts[0] = pt(0, yn[0]);
pts[1] = pt(xn[0], 0);
pts[2] = pt(pts[i].x, pts[i].y + yn[1]);
pts[3] = pt(pts[i].x + xn[1], pts[i].y);
push(&gr[0][i]);
push(&gr[cur][nextedge[cur]]);
push(0);
push(ct, cur, cl, cr);
push(cur);
push(cur, cr - cl + 1);
push(cur->p);
push(cur->p->p);
push(l);
push(r);
pushall(ct, cur * 2 + 1, cm + 1, cr);
pushall(ct, cur * 2, cl, cm);
pushone(cur->l, cur->to_push);
pushone(cur->r, cur->to_push);
pushq(0);
q.pop();
q.push(0);
q.push(gr[cur][i]);
q.push(gr[cur][i].v);
q.push(ing[gr[cur][i]][j]);
q.push(last);
q.push(make_pair(0, pt(n, 0)));
q.push(make_pair(d[next.x][next.y], next));
q.push(make_pair(getans(root[wh]), wh));
q.push(make_pair(sob[i].x, sob[i].kv));
q.push(t[i]);
q.push(x);
q[--bo] = gr[cur][i];
q[0] = tline(0, b[0], 0);
q[0] = tq();
q[eo++] = grr[cur][i];
q[eo++] = s;
q[eo] = tline(0, a, b);
q[eo] = tline(r, a, b);
q[i + 1] = q[t];
q[i + 1].push(m);
q[i] = false;
q[i] = true;
q[i].id = i;
qt.pop();
qt.push(ct);
queue<int> o;
queue<int> q;
queue<int> qx, qy, qt;
queue<pos> o;
queue<ll> o;
queue<pair<int, int> > o;
qx.pop();
qx.push(cx);
qx.push(gr[curx][i].first);
qy.pop();
qy.push(cy);
qy.push(y);
r = 1LL << n;
r = 1e9;
r = NULL;
r = _d;
r = copy(r);
r = cur;
r = d->r;
r = l->r;
r = lp;
r = new tnode(*r);
r = null;
r = wh->first;
r = x.r;
r = x;
r++;
r->add = r->add + add;
r->l = merge(l, r->l);
r->p = l;
r->p = null;
r->push();
r->up = a;
r->update();
r1--;
r1[i] = u[i];
r2--;
r= null;
r = -1;
r[ 0] = rot(rot(cube[19]));
r[ 0] = rot(rot(rot(cube[1])));
r[ 1] = rot(rot(cube[18]));
r[ 1] = rot(rot(rot(cube[3])));
r[ 2] = rot(cube[7]);
r[ 2] = rot(rot(cube[17]));
r[ 2] = rot(rot(rot(cube[0])));
r[ 2] = rot(rot(rot(cube[12])));
r[ 3] = rot(cube[5]);
r[ 3] = rot(rot(cube[16]));
r[ 3] = rot(rot(rot(cube[14])));
r[ 3] = rot(rot(rot(cube[2])));
r[ 4] = cube[16];
r[ 4] = rot(cube[6]);
r[ 5] = cube[17];
r[ 5] = rot(cube[20]);
r[ 5] = rot(cube[4]);
r[ 5] = rot(rot(rot(cube[3])));
r[ 6] = cube[18];
r[ 6] = rot(cube[7]);
r[ 7] = cube[19];
r[ 7] = rot(cube[21]);
r[ 7] = rot(cube[5]);
r[ 7] = rot(rot(rot(cube[2])));
r[ 8] = cube[0];
r[ 8] = cube[4];
r[ 8] = rot(cube[10]);
r[ 8] = rot(rot(rot(cube[ 9])));
r[ 9] = cube[1];
r[ 9] = cube[5];
r[ 9] = rot(cube[ 8]);
r[ 9] = rot(rot(rot(cube[11])));
r[10] = cube[2];
r[10] = cube[6];
r[10] = rot(cube[11]);
r[10] = rot(rot(rot(cube[ 8])));
r[11] = cube[3];
r[11] = cube[7];
r[11] = rot(cube[ 9]);
r[11] = rot(rot(rot(cube[10])));
r[12] = cube[ 8];
r[12] = rot(cube[2]);
r[12] = rot(rot(rot(cube[13])));
r[12] = rot(rot(rot(cube[21])));
r[13] = cube[ 9];
r[13] = rot(rot(rot(cube[15])));
r[14] = cube[10];
r[14] = rot(cube[3]);
r[14] = rot(rot(rot(cube[12])));
r[14] = rot(rot(rot(cube[20])));
r[15] = cube[11];
r[15] = rot(rot(rot(cube[14])));
r[16] = cube[12];
r[16] = rot(rot(cube[23]));
r[17] = cube[13];
r[17] = rot(rot(cube[22]));
r[18] = cube[14];
r[18] = rot(rot(cube[21]));
r[19] = cube[15];
r[19] = rot(rot(cube[20]));
r[1] = 1;
r[1] = 2;
r[20] = cube[ 8];
r[20] = rot(cube[14]);
r[20] = rot(cube[22]);
r[20] = rot(rot(rot(cube[5])));
r[21] = cube[ 9];
r[21] = rot(cube[12]);
r[21] = rot(cube[20]);
r[21] = rot(rot(rot(cube[7])));
r[22] = cube[10];
r[22] = rot(cube[23]);
r[23] = cube[11];
r[23] = rot(cube[21]);
r[2] = 1;
r[2] = 2;
r[i].id = i;
r[n + 1] = n + 1;
random_shuffle(a, a + n);
random_shuffle(dirs + 1, dirs + 6);
re.pop_back();
re.push_back(wh);
re[i] = make_pair(a, b);
read(a);
read(b);
read(c);
realo[x].push_back(make_pair(begin, sob[i].x));
rect[i].x2--;
rect[i].y2--;
regood.pop_back();
regood.push_back(good);
rem(*prev, *wh);
rem(*wh, *next);
rem(id);
rems(getans(0, 0, n));
rems(getans(0, a[r], r + 1));
rems(getans(a[l], 0, n - l));
rems(getans(a[l], a[r], r - l + 1));
res += "fork";
res += "ring";
res = res || move(x + 1, y, sx, sy);
res = res || move(x - 1, y, sx, sy);
res = res || move(x, y + 1, sx, sy);
res = res || move(x, y - 1, sx, sy);
res[0] = p[0];
res[i + n / 2] = (ra[i] - (rb[i] * w[j]) % mod + mod) % mod;
res[i + n / 2] = ra[i] - rb[i] * w[j];
res[i] = (ra[i] + rb[i] * w[j]) % mod;
res[i] = ra[i] + rb[i] * w[j];
return 'a' + (c - 'a' + 4) % 16;
return ((b - a) * (c - a) == 0) && ((b - a) / (c - a) > 0);
return ((ll)a * b) % MOD;
return ((ll)len * (len + 1) / 2) % MOD;
return ((x + y) * (x + y) - 1) % z == 0;
return (1 << (int)grp[cur].size()) - 1;
return (1LL << (x + y * l + z * l * w));
return (a % 2 + 2) % 2 == b;
return (a * c) % MOD;
return (a / b) + gcd(b, a % b);
return (a == '(' && b == ')') || (a == '[' && b == ']');
return (a > 0 ? 1 : -1);
return (a.m < b.m) || ((a.m == b.m) && (a.v < b.v));
return (a.n.x == b.n.x && a.n.y == b.n.y );
return (a.n.y < 0) || (a.n.y == 0 && a.n.x < 0);
return (a.t == OPEN && b.t == CLOSE);
return (a.x * b.n.x + a.y * b.n.y + b.c < eps);
return (a.x < b.x) || ((a.x == b.x) && (a.id < b.id));
return (a.x < b.x) || ((a.x == b.x) && (a.y < b.y));
return (a.x < b.x) || (a.x == b.x && a.id < b.id) ||
return (a.x < b.x) || (a.x == b.x && a.y < b.y);
return (a.y < 0) || (a.y == 0 && a.x < 0);
return (abs(a.x - b.x) < eps && abs(a.y - b.y) < eps);
return (ans[1][0] + ans[1][1]) % MOD;
return (b == 0 ? inf : (double)a / b);
return (cur == NULL ? -inf : cur->ans + cur->to_push);
return (cur == NULL ? 0 : cur->size);
return (cur >= 2 * treesize ? 0 : tree[cur].ans);
return (d(a - p[0]) < d(b - p[0]));
return (d[T] != inf);
return (double)rand() / RAND_MAX;
return (intersect(a, curx) < intersect(b, curx));
return (ll)a.x * b.x + (ll)a.y * b.y;
return (ll)a.x * b.y - (ll)a.y * b.x;
return (ll)x * x + (ll)y * y;
return (mul(a, a, n) + add) % n;
return (p & wh(x, y, z));
return (p[v] == v ? v : find(p[v]));
return (rand() % (l->size + r->size)) < r->size;
return (sum[r] - sum[l] + MOD) % MOD;
return (tin[a] <= tin[b] && tout[a] >= tout[b]);
return (x + y) % 2 == 0;
return (z1 < 0) && (z2 < 0);
return *this;
return -1;
return 0;
return 1;
return 2;
return DOWN;
return M_PI - abs(atan2(v1 * v2, v1 / v2));
return NULL;
return __builtin_popcount(a) > __builtin_popcount(b);
return a * (1 / b);
return a + (-b);
return a - (-b);
return a.a < b.a;
return a.ans < b.ans;
return a.c < b.c;
return a.d() < b.d();
return a.dir < b.dir;
return a.f0 + a.f1 + a.s0 + a.s1;
return a.id < b.id;
return a.l < b.l;
return a.lvl < b.lvl;
return a.p / a.l > b.p / b.l;
return a.r < b.r;
return a.s * b.q < a.q * b.s;
return a.s + a.t < b.s + b.t;
return a.s > b.s;
return a.second * b.first > b.second * a.first;
return a.t < b.t;
return a.t == CLOSE && b.t == OPEN;
return a.t == OPEN && b.t == CLOSE;
return a.t == PRODUCT && b.t == QUERY;
return a.v > b.v;
return a.x * a.x + a.y * a.y;
return a.x * b.x + a.y * b.y;
return a.x * b.y - a.y * b.x;
return a.x + xn[i] <= A && a.y + yn[i] <= B;
return a.x < b.x;
return a.x == b.x && a.y == b.y;
return a.y < b.y;
return a.y > 0 || (a.y == 0 && a.x > 0);
return a;
return a[m + 1][n + m + 1];
return ans;
return ans[l][r][whmax];
return ans[norm(a)][norm(b)][c];
return answer;
return answer[cur];
return atan2(a * b, a / b);
return b;
return change0(cur->r, x );
return change2(cur->r, x);
return chinese(ans, pk, kp);
return chone(x, y, z) && chone(y, z, x) && chone(z, x, y);
return colored[cx][cy];
return cur + 1;
return cur->ans;
return cur->is0;
return cur->is1;
return cur->is2;
return cur->size;
return cur.maxf - cur.f >= MINF;
return cur;
return curans;
return curkv > 0;
return curpl;
return curt;
return d(a - s) + d(b - s) + d(c - s);
return da;
return data.size();
return e[cure].first + e[cure].second - curv;
return false;
return find(p[a][b].second);
return fs * ft * ff;
return ft * fs * ff;
return get(cur->r, cm + 1, cr, k - cur->l->sum);
return get(cur->r, m + 1, cr, x);
return get_ith(tree[cur], cl - l);
return get_right(cur->r, x - cur->l->size - 1);
return getbest((me + 1) / 2, tot / 2);
return getmax(1, 1, size, a + 1, b + 1);
return go(cur + 1, curans);
return go(x, y, sx, sy);
return good;
return gr[norm(a)][norm(b)];
return h;
return h[a] < h[b];
return hash[r] - hash[l - 1] * st2[r - l + 1];
return have == '*' || have == need;
return kar[kar.size() - 1].first;
return kv > 1;
return l;
return last + 1;
return len / 2 + isgood(xs[cx] - 1, ys[cy] - 1);
return m;
return make_pair(mind, sz);
return mask[t - 1][y][x] == 'X';
return max(get1(cur * 2, cl, cm, x),
return max(get2(cur * 2, cl, cm, l, r),
return maxpos - minpos;
return maxv - minv;
return memcalc[l][r];
return memgo[l][r][nl];
return mfl;
return minh;
return n;
return nextv;
return ok;
return otn[a] > otn[b];
return out;
return p[a][0];
return p[x][y];
return point;
return pp[a];
return pr[a];
return pr[cur];
return pt(-a.x, -a.y);
return pt(-a.y, a.x);
return pt(a.x + b.x, a.y + b.y);
return pt(a.x - b.x, a.y - b.y);
return pt(abs(a.x), abs(a.y));
return pt(k * a.x, k * a.y);
return r + 2;
return r - l + min(abs(wh - l), abs(wh - r)) <= t;
return r;
return res;
return rot(cur);
return rot(rot(cur));
return rot(rot(rot(cur)));
return s[a].q < s[b].q;
return sqr(a.x - X) <= D;
return sqrt((double)(dx * dx + dy * dy));
return sqrt((ll)a.x * a.x + (ll)a.y * a.y);
return sqrt((ll)x * x + (ll)y * y);
return sqrt((x - a.x) * (x - a.x) + (y - a.y) * (y - a.y));
return sqrt(a.x * a.x + a.y * a.y);
return sum >= m;
return sum[a + 1] > sum[b + 1];
return sz[cur];
return t + getsize(cur->l) + 1;
return t3 + k;
return t;
return tf((a.mod * b.mod) % MOD, a.st2 + b.st2);
return tin[a] <= tin[b] && tout[a] >= tout[b];
return tot / 2 + getworst((me - 1) / 2, tot / 2);
return tpair(
return tree1[cur];
return tree2[cur];
return tree[ct][cur].sum;
return true;
return tv(a.f0 * b, a.f1 * b, a.s0 * b, a.s1 * b);
return up[a][0];
return v1 * v2 > 0;
return v[x];
return with0.size() + without0.size();
return x * x + y * y;
return x * y - (t * (t + 1) / 2);
return x;
return x[a] + y[a] < x[b] + y[b];
return zna < znb + eps;
return;
reverse = false;
reverse(a, a + n);
reverse(as, as + n);
reverse(b, b + (n - 1));
reverse(b, b + m);
reverse(bs, bs + m);
reverse(kar.begin(), kar.end());
reverse(name[i].begin(), name[i].end());
reverse(namer[i].begin(), namer[i].end());
reverse(p, p + n);
reverse(r, r + n);
reverse(s, s + n);
reverse(t.begin(), t.end());
right--;
right\n";
right\n\
rmq *next = new rmq;
rmq *root[maxn];
root = &tree[0];
root = NULL;
root = add(root, s, 0, strlen(s));
root = cutleft(root);
root = doerasemax(root);
root = make_splay(0, n);
root = merge(l, merge(i1, merge(m, merge(i2, r))));
root = merge(l, merge(m, r));
root = merge(l, merge(new tnode(x), r));
root = merge(m[i], root);
root = merge(merge(l, m), r);
root = merge(merge(l, m1), r);
root = merge(root, m);
root = merge(root, new tnode(p.first, p.second));
root = merge(root, r);
root = merge(ver[i * 2 - 1], root);
root = merge(ver[i * 2 - 2], root);
root = new tnode(*root);
root = newnode();
root = null;
root->ok = false;
root->to_push += t;
root[0] = NULL;
root[0] = make(0, maxn - 1);
root[a]->change(a, h);
root[cur] = currmq;
root[i + 1] = change(root[i + 1], 0, maxn - 1, i, 0);
root[i + 1] = change(root[i + 1], 0, maxn - 1, next[i], 1);
root[i + 1] = root[i];
rotate(c, c + 1, c + 3);
rotate(cur);
rotate(cur->p);
rotated = false;
rotated = true;
rp = null;
rp.push(r.pop());
rr1.x = dir.x * cosa - dir.y * (-sina);
rr1.x = dir.x * cosa - dir.y * sina;
rr1.y = dir.x * (-sina) + dir.y * cosa;
rr1.y = dir.x * sina + dir.y * cosa;
rright[curpl] = compress(cur->r);
rright[i][j] = cur;
rx[i] = 0;
rx[i] = y[i] + sqrt(l);
rx[ky] = ys[i].lvl;
ry[kx] = xs[i].lvl;
s = ' ' + s;
s = null;
s++;
s.push_back(make_pair(powmod(a, k * i), i));
s.resize(0);
s[0] = ' ';
s[2] = 0;
s[i + 1] = sgm(p[i], p[i + n], i + 1);
s[i] = 0;
s[i].id = i + 1;
s[i][j] = 0;
s[i][len] = 'Z' + 1;
s[m] = s[0];
s[next] = acur + 1;
s[schwh[curcnt]] = schx[curcnt];
s[wh ^ 1][nextn++] = s[wh][i];
s[wh][n] = '\0';
scanf("%Lf%Lf", &X, &Y);
scanf("%Lf%Lf", &Y, &X);
scanf("%Lf%d%d", &p1[i], &nf, &ne);
scanf("%Lf%d%d", &p2[i], &nf, &ne);
scanf("%c", &c);
scanf("%c", &c1);
scanf("%c%c\n", &c1, &c2);
scanf("%c%d\n", &ch, &d);
scanf("%d %c", &x, &dir);
scanf("%d" LLD , &n, &k);
scanf("%d" LLD, &n, &MOD);
scanf("%d" LLD, &n, &k);
scanf("%d" LLD, &n, &m);
scanf("%d" LLD, &n, &p);
scanf("%d" LLD, &n, &w);
scanf("%d", &A);
scanf("%d", &D);
scanf("%d", &K);
scanf("%d", &MOD);
scanf("%d", &N);
scanf("%d", &NT);
scanf("%d", &R);
scanf("%d", &T);
scanf("%d", &a), a--;
scanf("%d", &a);
scanf("%d", &a[i + n].first);
scanf("%d", &a[i]);
scanf("%d", &a[i].first);
scanf("%d", &a[i].x);
scanf("%d", &a[i][j]);
scanf("%d", &b[i]);
scanf("%d", &build[i].s);
scanf("%d", &c);
scanf("%d", &c[i][j]);
scanf("%d", &comp[i].v);
scanf("%d", &d);
scanf("%d", &f[i][j]);
scanf("%d", &id);
scanf("%d", &ju[i]);
scanf("%d", &k);
scanf("%d", &kv[i]);
scanf("%d", &m);
scanf("%d", &maxw);
scanf("%d", &n);
scanf("%d", &nq);
scanf("%d", &nx[i]);
scanf("%d", &p);
scanf("%d", &p[i]);
scanf("%d", &q);
scanf("%d", &q[i].x);
scanf("%d", &r[i].r);
scanf("%d", &t);
scanf("%d", &t[i]);
scanf("%d", &t[i].p);
scanf("%d", &t[i][j]);
scanf("%d", &timed[j][t][i]);
scanf("%d", &w[i].x);
scanf("%d", &x), x--;
scanf("%d", &x);
scanf("%d", &x[0]);
scanf("%d%d", &A, &B);
scanf("%d%d", &C, &T);
scanf("%d%d", &M, &n);
scanf("%d%d", &S, &T);
scanf("%d%d", &X, &Y);
scanf("%d%d", &a, &b), a--, b--;
scanf("%d%d", &a, &b);
scanf("%d%d", &c[i][j], &k);
scanf("%d%d", &e[i].first, &e[i].second);
scanf("%d%d", &edges[ke].first, &edges[ke].second);
scanf("%d%d", &k, &n);
scanf("%d%d", &l, &r), l--, r--;
scanf("%d%d", &l, &r);
scanf("%d%d", &m, &k);
scanf("%d%d", &m, &n);
scanf("%d%d", &n, &h);
scanf("%d%d", &n, &k);
scanf("%d%d", &n, &m);
scanf("%d%d", &n, &me);
scanf("%d%d", &n, &mr);
scanf("%d%d", &n, &r);
scanf("%d%d", &n, &width);
scanf("%d%d", &p[i].l, &p[i].r), p[i].l--, p[i].r--;
scanf("%d%d", &p[i].x, &p[i].y);
scanf("%d%d", &p[i][j], &p[i][j + 1]);
scanf("%d%d", &s, &m);
scanf("%d%d", &t, &m);
scanf("%d%d", &t, &v);
scanf("%d%d", &t, &x);
scanf("%d%d", &t[i], &kv[i]);
scanf("%d%d", &t[i].a, &t[i].b);
scanf("%d%d", &w, &h);
scanf("%d%d", &wh, &kv), wh--;
scanf("%d%d", &x, &y), x--;
scanf("%d%d", &x, &y);
scanf("%d%d", &x[i], &y[i]), x[i]--, y[i]--;
scanf("%d%d", &x[i], &y[i]);
scanf("%d%d", &xc, &yc);
scanf("%d%d%*c%c", &a, &b, &c);
scanf("%d%d%d", &A, &B, &C);
scanf("%d%d%d", &H, &n, &m);
scanf("%d%d%d", &a, &b, &c), a--, b--;
scanf("%d%d%d", &a, &b, &c);
scanf("%d%d%d", &a, &b, &l);
scanf("%d%d%d", &a, &b, &t), a--, b--;
scanf("%d%d%d", &a, &b, &w), a--, b--;
scanf("%d%d%d", &a, &c, &b);
scanf("%d%d%d", &c, &a, &b);
scanf("%d%d%d", &c[0], &c[1], &c[2]);
scanf("%d%d%d", &i, &j, &k);
scanf("%d%d%d", &k, &m, &n);
scanf("%d%d%d", &l, &r, &b);
scanf("%d%d%d", &m, &n, &k);
scanf("%d%d%d", &n, &X, &Y);
scanf("%d%d%d", &n, &a, &b);
scanf("%d%d%d", &n, &c1, &c2), c1--, c2--;
scanf("%d%d%d", &n, &k, &MOD);
scanf("%d%d%d", &n, &k, &m);
scanf("%d%d%d", &n, &lenl, &lenr);
scanf("%d%d%d", &n, &m, &c);
scanf("%d%d%d", &n, &m, &k);
scanf("%d%d%d", &n, &m, &kc);
scanf("%d%d%d", &n, &m, &nt);
scanf("%d%d%d", &n, &m, &p), p--;
scanf("%d%d%d", &n, &m, &r);
scanf("%d%d%d", &n, &maxr, &maxtime);
scanf("%d%d%d", &n, &s, &p);
scanf("%d%d%d", &n, &w, &l);
scanf("%d%d%d", &t, &l, &r), l--, r--;
scanf("%d%d%d%d", &l, &w, &h, &n);
scanf("%d%d%d%d", &n, &L, &S, &v[0]);
scanf("%d%d%d%d", &n, &k, &l, &r);
scanf("%d%d%d%d", &n, &m, &a, &b);
scanf("%d%d%d%d", &n, &m, &x, &y);
scanf("%d%d%d%d", &p1.x, &p1.y, &p2.x, &p2.y);
scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
scanf("%d%d%d%d", &x1[i], &y1[i], &x2[i], &y2[i]);
scanf("%d%d%u", &a, &b, &res), a--, b--;
scanf("%d%d\n", &n, &k);
scanf("%d%d\n", &n, &m);
scanf("%d%s", &d1[i], side1[i]);
scanf("%d%s", &d2[i], side2[i]);
scanf("%d\n", &NT);
scanf("%d\n", &k);
scanf("%d\n", &n);
scanf("%s", a);
scanf("%s", b);
scanf("%s", m);
scanf("%s", name);
scanf("%s", pl[i]);
scanf("%s", s + 1);
scanf("%s", s);
scanf("%s", s[0]);
scanf("%s", s[i]);
scanf("%s", t + last);
scanf("%s", t);
scanf("%s%d", s, &c);
scanf("%s%d%d", p[i], &l[i], &r[i]);
scanf("%s%s", a, b);
scanf("%s%s", as, bs);
scanf("\n");
scanf(LLD "%d", &B, &n);
scanf(LLD "%d", &s[i].s, &s[i].q);
scanf(LLD LLD "%s" LLD, &x[i], &y[i], dir, &len[i]);
scanf(LLD LLD LLD LLD, &n, &x, &y, &need);
scanf(LLD LLD LLD, &A, &B, &C);
scanf(LLD LLD LLD, &A, &B, &M);
scanf(LLD LLD LLD, &n, &m, &p);
scanf(LLD LLD, &A, &B);
scanf(LLD LLD, &a[i], &b[i]);
scanf(LLD LLD, &l, &r);
scanf(LLD LLD, &p[i].x, &p[i].y);
scanf(LLD, &a);
scanf(LLD, &a[i]);
scanf(LLD, &maxsum);
scanf(LLD, &n);
scanf(LLD, &x);
schwh[curcnt] = a;
schwh[curcnt] = b;
schx[curcnt] = s[a];
schx[curcnt] = s[b];
second = 0;
second = l;
second = m1;
second = m2;
second = s - first;
segments.erase(it);
segments.insert(s[-p[i].id]);
set<int> curs;
set<int> pts;
set<int> was;
set<int>::iterator next = wh;
set<int>::iterator ny = pts.lower_bound(a[i].y);
set<int>::iterator prev = wh;
set<int>::iterator wh = was.lower_bound(x);
set<ll> allcheaters;
set<sgm, cmpsgm> segments(curx);
set<sgm, cmpsgm>::iterator itnext = it;
set<sgm, cmpsgm>::iterator itprev = it;
set(1, 0, treesize - 1, a, b);
set(ct, 1, l + kvl, l + kvl + kvm - 1, 0, treesz - 1, 1);
set(ct, 1, l, r, 0, treesz - 1, 0);
set(ct, 1, r - kvl - kvm + 1, r - kvl, 0, treesz - 1, 1);
set(ct, cur * 2 + 1, l, r, cm + 1, cr, t);
set(ct, cur * 2, l, r, cl, cm, t);
set(cur * 2 + 1, cm + 1, cr, l, r, t);
set(cur * 2 + 1, cm + 1, cr, x, t);
set(cur * 2, cl, cm, l, r, t);
set(cur * 2, cl, cm, x, t);
set(cur->l, cl, m, l, r, newy);
set(cur->l, x, t);
set(cur->r, m + 1, cr, l, r, newy);
set(cx, cy, d[i]);
set(gr[edges[ke].first], edges[ke].second);
set(gr[edges[ke].second], edges[ke].first);
set(to, curlen, cur->x);
set1(cur * 2 + 1, cm + 1, cr, l, r, t);
set1(cur * 2, cl, cm, l, r, t);
set2(cur * 2 + 1, cm + 1, cr, x, t);
set2(cur * 2, cl, cm, x, t);
setall(b, a, 0);
setall(cur->l, to, leftsize);
setall(cur->r, to, leftsize + getsize(cur->l) + 1);
setpal(t, l, r, sum / 2, kv[t] / 2);
setpalcenter(odd, l, r, sum / 2, kv[odd]);
sett[cur] += t;
sett[cur] = true;
sgm s[maxn];
sgn((a - c) * (d - c)) * sgn((b - c) * (d - c)) < 0;
sh[a].push_back(make_pair(shift[a], shift[b]));
sh[b].push_back(make_pair(shift[b], shift[a]));
shift[wh] = (shift[wh] - kv + 32) % 32;
sint id;
sint st[maxn];
siter it = curs.upper_bound(a[i].second);
siter next = wh;
siter prev = wh;
siter wh = curpts.find(sob[i].obj);
size = 0;
size = 1 + l->size + r->size;
size = 1;
size = v.size();
size++;
size--;
sk = min(sk, a);
sm[x][y] = make_pair(sx, sy);
sob.push_back(make_pair(l, 1));
sob.push_back(make_pair(r, -1));
sob.push_back(tsob(a, PRODUCT, b, c, -1));
sob.push_back(tsob(a, QUERY, b, c, i));
sob.push_back(tsob(a, c, OPEN));
sob.push_back(tsob(b, c, CLOSE));
sob.push_back(tsob(cur.x1, OPEN, cur.y1, cur.y2 + 1));
sob.push_back(tsob(cur.x2 + 1, CLOSE, cur.y1, cur.y2 + 1));
sob.push_back(tsob(l, 0, OPEN));
sob.push_back(tsob(l, 1, CLOSE));
sob.push_back(tsob(r, 0, CLOSE));
sob.push_back(tsob(r, 1, OPEN));
sob.push_back(tsob(votr[x][i].first, OPEN));
sob.push_back(tsob(votr[x][i].second, CLOSE));
sob.push_back(tsob(x + k, CLOSE, pt(x, y)));
sob.push_back(tsob(x - k, OPEN, pt(x, y)));
sob.resize(0);
sobx[kx - 1].push_back(tsob(xs[i].x1, OPEN));
sobx[kx - 1].push_back(tsob(xs[i].x2, CLOSE));
sobx[kx].push_back(tsob(xs[i].x1, OPEN));
sobx[kx].push_back(tsob(xs[i].x2, CLOSE));
sobx[kx].resize(0);
soby[ky - 1].push_back(tsob(ys[i].x1, OPEN));
soby[ky - 1].push_back(tsob(ys[i].x2, CLOSE));
soby[ky].push_back(tsob(ys[i].x1, OPEN));
soby[ky].push_back(tsob(ys[i].x2, CLOSE));
soby[ky].resize(0);
solve();
solve(np[i], np[j], np[k], xc, yc);
son->with0.add += c[cur][i];
son->without0.add += c[cur][i];
sort(a, a + 12);
sort(a, a + 2 * n, cmp);
sort(a, a + kv);
sort(a, a + n);
sort(a, a + n, cmpx);
sort(a, a + n, greater<int>());
sort(a.begin(), a.end());
sort(a.wh.begin(), a.wh.end());
sort(ans.begin(), ans.end());
sort(answer.begin(), answer.end());
sort(answer[i].begin(), answer[i].end());
sort(arrsum[0][dir], arrsum[0][dir] + n);
sort(arrsum[1][dir], arrsum[1][dir] + n);
sort(b + beg, b + beg + KB, cmpr);
sort(b, b + (n - 1));
sort(b, b + n);
sort(bord, bord + m, cmpminx);
sort(build, build + n);
sort(c + i, c + i + KSMB, cmplen);
sort(comp, comp + m);
sort(connect_e.begin(), connect_e.end());
sort(costs, costs + n - 1);
sort(d.begin(), d.end());
sort(e, e + m);
sort(ev, ev + k);
sort(f, f + n);
sort(forks.begin(), forks.end());
sort(gr[i].begin(), gr[i].end(), cmpparam);
sort(grcomp[i].begin(), grcomp[i].end());
sort(h + 1, h + n + 1);
sort(hs.begin(), hs.end());
sort(id, id + k, cmpsum);
sort(ids.begin(), ids.end());
sort(job, job + n + 2);
sort(kar.begin(), kar.end());
sort(l, l + n);
sort(lines.begin() + upmid, lines.end());
sort(lines.begin(), lines.begin() + upmid);
sort(name[i].begin(), name[i].end());
sort(namel, namel + n);
sort(namel[i].begin(), namel[i].end());
sort(namer, namer + n);
sort(out.begin(), out.end());
sort(p + 1, p + n, cmp);
sort(p + l, p + r, cmp);
sort(p, p + 2 * n, cmpx);
sort(p, p + kg, cmpp);
sort(p, p + km, cmpbits);
sort(p, p + m, cmpl);
sort(p, p + n);
sort(p, p + n, cmpsum);
sort(p, p + n, cmpx);
sort(p, p + n, cmpy);
sort(q, q + n);
sort(r, r + n);
sort(s, s + n);
sort(s.begin(), s.end());
sort(sob, sob + ksob);
sort(sob.begin(), sob.end());
sort(sobx[i].begin(), sobx[i].end());
sort(soby[i].begin(), soby[i].end());
sort(sums, sums + nm);
sort(t, t + n);
sort(t.begin(), t.end());
sort(tmp, tmp + tree[cur].size());
sort(v, v + n);
sort(w, w + n + 2);
sort(x, x + maxn);
sort(x, x + n);
sort(xs.begin(), xs.end());
sort(y[0].begin(), y[0].end());
sort(y[1].begin(), y[1].end());
sort(y[2].begin(), y[2].end());
sort(ys.begin(), ys.end());
sortparam = i;
splay(cur);
splay(l);
split(a, midr - 1, l, r);
split(cur, l, r, 0);
split(cur, l, r, mid + 1);
split(cur, l, r, min1 + 1);
split(cur->l, l, cur->l, x);
split(cur->l, x, l, cur->l);
split(cur->r, cur->r, r, x - getsize(cur->l) - 1);
split(cur->r, x - cur->l->size - 1, cur->r, r);
split(cur->r, x - getsize(cur->l) - 1, cur->r, r);
split(cur->r, x, cur->r, r);
split(l, l, m, mid);
split(l, l, m, min1);
split(l, l1 - 1, l, m1);
split(l, l2 - 1, l, m2);
split(l, lx - 1, l, m);
split(l, midl, l, m);
split(l, needlenl - 1, l, m);
split(l, x, l, m);
split(r, -v, m, r);
split(root, r1, l, r);
split(root, r2, l, r);
split(root, rx, l, r);
split(root, v, l, r);
split(root, x + 1, l, r);
split(to, needlenr, l, r);
splitv(a);
splitv(wa->up);
sprintf(s[cur], "%dACV%02d", i + 1, j + 1);
sq = abs(sq);
sqall = abs(sqall);
srand(1235);
srand(201);
sscanf(buf, "%d", &testNum);
ssout = fopen("sample.out", "r");
ssum += a[i];
st *= 10;
st /= 10;
st w[maxn];
st.pop();
st.push(cur);
st1.push_back(a[i]);
st1.resize(0);
st1[0] = 1;
st2 = 0;
st2++;
st2.push_back(a[i]);
st2.resize(0);
st2[0] = 1;
st3.push_back(a[i]);
st3.resize(0);
st[0] = 1;
st[0] = tst();
st[1] = 0;
st[a]++;
st[gr[best][i]]--;
st[i + 1] = *st[t].next;
st[i + 1] = tst(m, &st[t]);
st[i] = st[i - 1];
st[i]++;
st[sts] = i;
stable_sort(norm + upmid, norm + normsize, cmp0);
stable_sort(norm, norm + upmid, cmp0);
stable_sort(p + 1, p + n, cmp0);
stack<int> st;
stack<pos> o;
static tnode* null;
steps++;
steps--;
str.clear();
str[hash] = cur;
string answer = calcans();
string bestmatchans, bestmatchcube;
string calcans()
string command;
string curans = answer;
string dir[maxdir];
string faceto(int side, string cube)
string facetoleft(string cube)
string facetoup(string cube)
string got = "";
string last;
string name[maxn], namel[maxn], namer[maxn];
string name[maxn];
string r = cube;
string res = "";
string rotleft(string cube)
string rotright(string cube)
string s, t;
string s;
string t, s;
string wking, wrook1, wrook2, bking;
string& t = dic[str];
struct Worker
struct cmpsgm
struct comp
struct cont
struct convex
struct cyph
struct deque
struct deque <T, 0>
struct lem
struct line
struct mymap
struct pos
struct pt
struct ptd
struct rmq
struct sgm
struct st
struct tans
struct tb
struct tc
struct te
struct tedge
struct tel
struct tevent
struct tf
struct tfish
struct tjob
struct tline
struct tmap
struct tnode
struct tp
struct tpair
struct tq
struct tr
struct trect
struct ts
struct tsob
struct tst
struct tsum
struct tt
struct ttree
struct tv
struct tvertex
struct tx
sts = 0;
sts++;
sts--;
sub[(i - j + n) % n]++;
sub[(i - j + n) % n]--;
sub[(j - i + n) % n]++;
sub[(j - i + n) % n]--;
sum += a[cur];
sum += a[i];
sum += c;
sum += goods[p[i]].first;
sum += k;
sum += kv[t];
sum += w[j];
sum += x;
sum = 1;
sum = l->sum + r->sum + x;
sum = x.sum;
sum[0] = 0;
sum[0] = b[0].first;
sum[cur] += tmp[i].first * tmp[i].second;
sum[cur] = 0;
sum[cur] = a[cl];
sum[i + 1] = sum[i] + len[i];
sum[i] = sum[i - 1] + b[i].first;
sum[i] = sum[i - 1];
suma += a[i];
suma += t[i].a;
sumb += b[i];
sumb -= t[i].b;
sumcol[j] *= -1;
sumcol[j] += 2 * a[i][j];
suml += a[j];
sumq += s[i].q;
sumq -= s[i].q;
sumq = 0;
sumrow[i] *= -1;
sumrow[i] += 2 * a[i][j];
sums.pop_back();
sums.push_back(0);
sums.push_back(sums.back() + c);
sums.resize(0);
sums[mask - 1].first = sum;
sums[mask - 1].second = mask;
swap(addx, addy);
swap(b[x], b[y]);
swap(cur->l, cur->r);
swap(cx, cy);
swap(dirs[0], dirs[i]);
swap(gr3[cur][i], gr3[cur][2]);
swap(n, m);
swap(v2, v1);
switch (k)
sx++;
sx--;
sy++;
sy--;
sz += t.second;
sz++;
sz[cur] += getsize(gr[cur][i], cur, curh + 1);
sz[cur] += sz[gr[cur][i]];
sz[cur] = 1;
sz[cur]++;
sz[curpl]++;
sz[curpl]--;
sz[i][j] = 0;
sz[minpl]--;
sz[x][y] = 1;
t *= 2;
t /= 10;
t = ' ' + t;
t = (n + 31) / 32;
t = (t * t) % MOD;
t = (t * t) % mod;
t = -100;
t = 100;
t = ans[i] / 100;
t = find(cur->r, x);
t = i;
t = max(t, T);
t = mul(t, t);
t = mul(t, t, mod);
t = t * 2;
t = t * t;
t = t + sqrt(2 * d / a);
t = t + v / a + (d - s) / v;
t = t / 10 + last * st;
t = x + y - 1 - t;
t++;
t->l = NULL;
t->r = NULL;
t->set = true;
t->y = 0;
t.resize(0);
t0 = max(t0, mind[gr[cur][i]][1] + 1 + mind[cur][1]);
t2 = max(t2, mind[gr[cur][i]][1] + 1 + mind[cur][1]);
t3 = max(t3, mind[gr[cur][i]][0] + mind[cur][1]);
t3 = max(t3, mind[gr[cur][i]][1] + 1 + mind[cur][0]);
t3 = max(t3, mind[gr[cur][i]][1] + 1 + mind[cur][2]);
t3 = max(t3, mind[gr[cur][i]][2] + mind[cur][1]);
t4 = max(t4, mind[gr[cur][i]][0] + mind[cur][0]);
t4 = max(t4, mind[gr[cur][i]][1] + 1 + mind[cur][3]);
t4 = max(t4, mind[gr[cur][i]][2] + mind[cur][2]);
t4 = max(t4, mind[gr[cur][i]][3] + 1 + mind[cur][1]);
t[i]--;
t[i].id = i;
t[mask] = 0;
t[mask] = time;
take[answer[i]] = true;
taked[cur] = m;
taked[cur] = t;
tans ans[maxn];
tb build[maxn];
tc comp[maxn];
te e[maxn * maxn];
tedge *e = new tedge[ke];
tedge edges[maxn];
tedge(int _a, int _b, int _c, int _d)
tedge(int _u, int _v, ll _maxf, ll _f, int _o)
tedge(int _v, int _e)
tel *back;
tel *next;
tel()
tel(tel *_next, int _x)
template <typename T, int n>
template <typename T>
template <typename T> struct pt
tevent ev[maxk];
tf ans = tf(1, 0);
tf f[maxn];
tf(ll a)
tfish f[maxn];
third = 0;
third = s - first - second;
third = s - first;
time[i] = div0(s[i], comp[i].v);
timer = 0;
timer++;
tin[cur] = timer++;
tin[cur] = timer;
tjob job[maxn];
tline q[maxn];
tmap *ans = NULL;
tmap *son = go(gr[cur][i], cur);
tmap e;
tmap* go(int cur, int pr)
tmap* merge(tmap *a, tmap *b)
tmp /= b;
tmp = (tmp * tmp) % MOD;
tmp[++last] = tmp[i];
tmp[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD;
tmp[0][0] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD;
tmp[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD;
tmp[0][1] = 1;
tmp[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD;
tmp[1][0] = 1;
tmp[1][1] = 1;
tmp[cur++] = a[w1++];
tmp[cur] = a[w1];
tmp[cur].second += b[w2].second;
tmp[curpl] = *cur;
tmp[i] = make_pair(t, tree[cur][i].second);
tmp[kv++] = a % 10;
tnode *l, *r, *p;
tnode *l, *r;
tnode *next[27];
tnode mem[maxmem];
tnode tmp[maxn];
tnode tree[treesize * 2 + 5];
tnode tree[treesize * 2];
tnode tree[treesize];
tnode()
tnode(int _x)
tnode(int x): x(x)
tnode(ll x): x(x)
tnode(pair<int, int> x): x(x)
tnode(pt a, pt b)
tnode(tnode &x)
tnode* link[26];
tnode::null = new tnode;
tnode::null->l = tnode::null;
tnode::null->min = inf;
tnode::null->p = tnode::null;
tnode::null->r = tnode::null;
tnode::null->reverse = false;
tnode::null->size = 0;
tnode::null->x = inf;
to = merge(l, merge(m, r));
to_del.push_back(next[cur]);
to_del.resize(0);
to_push = 0;
to_return[kret++] = cur.top();
to_sqr(cur * 2 + 1, cm + 1, cr, l, r);
to_sqr(cur * 2, cl, cm, l, r);
tout[cur] = timer - 1;
tout[cur] = timer++;
tout[cur] = timer;
tp a[2 * maxn];
tp curp = tp(-1, sum, ans[i + 1]);
tp o[maxn];
tp p[maxn];
tp t[maxn];
tpair ab(rand() % n, rand() % n, n);
tpair(int _a, int _b, int _mod)
tpos curpos = q.top();
tq *e = new tq[ke];
tq ed[maxn];
tq q[maxn];
tq()
tr r[maxn];
trect cur = rect[i];
trect rect[maxn];
tree1[cur * 2 + 1] = max(tree1[cur], tree1[cur * 2 + 1]);
tree1[cur * 2] = max(tree1[cur], tree1[cur * 2]);
tree1[cur] = max(tree1[cur], t);
tree2[cur] = max(tree2[cur], t);
tree[ct][cur * 2 + 1].set = tree[ct][cur].set;
tree[ct][cur * 2 + 1].sum = tree[ct][cur].set * (cr - cm);
tree[ct][cur * 2].set = tree[ct][cur].set;
tree[ct][cur * 2].sum = tree[ct][cur].set * (cm - cl + 1);
tree[ct][cur].set = -1;
tree[ct][cur].set = t;
tree[ct][cur].sum = t * (cr - cl + 1);
tree[cur] = (tree[cur * 2] * tree[cur * 2 + 1]) % MOD;
tree[cur]++;
tree[cur].f0 = t;
tree[cur].f1 = t;
tree[cur].kset += t;
tree[cur].push = (tree[cur].push + t) % MOD;
tree[cur].push = 0;
tree[cur].push_back(make_pair(a[cl], 1));
tree[cur].push_back(tmp[i]);
tree[cur].resize(0);
tree[i + treesize].arr = new int[1];
tree[i + treesize].arr[0] = p[i];
tree[i + treesize].size = 1;
tree[i] = tmp[i];
tree[i].arr = new int[tree[i].size];
tree[i].size = tree[i * 2].size + tree[i * 2 + 1].size;
tree[s[i] - 'a'][treesz + i].set = 1;
tree[s[i] - 'a'][treesz + i].sum = 1;
tree[t][i].set = -1;
tree[treesize + i].f0 = a[i];
tree[treesize + i].f1 = a[i];
ts ch[maxn * maxn * 2];
ts ch[maxn * maxn];
ts cur = ch[--last];
tset curpts;
tsob sob[maxn];
tst *next;
tst l, r, lp, rp, f, s;
tst null;
tst st[maxn];
tst()
tst(int _x, tst *_next)
tsum arrsum[2][4][maxn];
tt t[maxn];
ttree tree[26][treesz * 2];
tv allv1 = tv(0, 0, 0, 0);
tv allv2 = tv(0, 0, 0, 0);
tv v1[maxt][maxn], v2[maxt][maxn];
tvertex v[maxn];
tx a[maxn];
typedef complex<double> comp;
typedef long double ld;
typedef long long ll;
typedef map<int, ll>::iterator miter;
typedef map<ll, int>::iterator miter;
typedef map<pair<int, int>, int> tmap;
typedef pair<ll, pt> inq;
typedef set<int>::iterator siter;
typedef set<pt> tset;
typedef short int sint;
typedef struct tnode* pnode;
typedef tnode* pnode;
typedef tset::iterator siter;
typedef unsigned int uint;
typedef unsigned long long ll;
typedef unsigned long long ull;
u = _u;
u[i] = 0;
uint answer = 0;
uint can[2 * maxkv], canall[2 * maxkv], canans[2 * maxkv];
uint gr[maxn][maxt];
uint mod = (((uint)1) << kvdown) - 1;
uint mod = (((uint)1) << kvup) - (uint)1;
uint mod = (((uint)1) << kvup) - 1;
uint res;
uint t = can[k];
uint t = canall[k];
uint t = canans[cup];
uint t = canans[k];
ull a = rand();
ull ans = 0;
ull b = a;
ull d = __gcd(max(a, b) - min(a, b), n);
ull mul(ull a, ull b, ull mod)
ull n;
ull t = a;
umn(tmp, tmp);
union_(a, b);
union_(edges[i].a, edges[i].b);
unite(3 * i + 2, 3 * j - 1, 3 * i + 2, 3 * j);
unite(3 * i - 1, 3 * j + 2, 3 * i, 3 * j + 2);
unite(3 * i - 1, 3 * j, 3 * i, 3 * j);
unite(3 * i, 3 * j - 1, 3 * i, 3 * j);
unite(connect_e[i].a, connect_e[i].b);
up = -1;
up++;
up[a] = min(up[a], height[c]);
up[cur] = min(up[cur], up[grc[cur][i].v]);
up[cur][0] = max(0, pr);
up[i] = height[i];
upd(ans[i], curmax + ans[j - 1]);
upd(ans[i][next[j][t]], ans[i][j] + 2);
upd(answer, ans1[i][c].x + j - laste + sum[j] - sum[laste]);
upd(cur);
upd(l);
upd(minh[l][i], curh);
upd(r);
upd(tree[cur], tree[cur * 2], tree[cur * 2 + 1], cr - cm);
update(ct, cur);
update(cur);
update(l);
update(p);
update(r);
update(ver[i]);
updateans(*prev, *wh);
updateans(*wh, *next);
updold(ans[i][next[j][t]], ans[i][j] + 2);
upupdate(p, cur);
used = true;
used[j] = true;
used[s[i] - 'A'] = true;
used[x][y] = false;
used[x][y] = true;
using namespace std;
v = _v;
v--;
v.push_back(prev);
v.push_back(x);
v.resize(0);
v1[t][i] = tv(0, 0, 0, 0);
v1[t][i] = v1[t][i] + v1[t - 1][f1[i][j]] * osp1[i];
v2[t][i] = tv(0, 0, 0, 0);
v[0][j + 300][ll] = v[1][j + 300][ll];
v[0][k + 300][0] = 1;
v[1][j + 300][ll] += (100 - p[i]) * v[0][j + 300][ll] / 100;
v[1][j + 300][ll] = 0;
v[1][knew + 300][ll + 1] += p[i] * v[0][j + 300][ll] / 100;
v[i] = r[i];
v[n].p = -inf;
vector<bool> c[maxn];
vector<bool> regood;
vector<int> adj;
vector<int> answer;
vector<int> answer[maxn];
vector<int> builds[maxn];
vector<int> c[maxn];
vector<int> can[maxn];
vector<int> ch[30];
vector<int> comps[maxn];
vector<int> cost[maxn];
vector<int> cur;
vector<int> curgr;
vector<int> curpath;
vector<int> d;
vector<int> dicsz;
vector<int> ends[maxn];
vector<int> f1[maxn], f2[maxn], e1[maxn], e2[maxn];
vector<int> from[maxmask];
vector<int> gr[maxm];
vector<int> gr[maxn * 2];
vector<int> gr[maxn * maxn];
vector<int> gr[maxn], c[maxn], opens[maxn];
vector<int> gr[maxn], fl[maxn];
vector<int> gr[maxn], grp[maxn];
vector<int> gr[maxn], grr[maxn];
vector<int> gr[maxn], ing[maxm];
vector<int> gr[maxn];
vector<int> grr[maxn];
vector<int> h;
vector<int> hs;
vector<int> kv[maxn][maxn];
vector<int> len[maxn];
vector<int> mines;
vector<int> mods;
vector<int> near[maxk];
vector<int> next[maxn];
vector<int> nextfr;
vector<int> opp[maxn];
vector<int> ost;
vector<int> re;
vector<int> sums;
vector<int> to_del;
vector<int> v, answer;
vector<int> v;
vector<int> vmax;
vector<int> wascol[maxn];
vector<int> willgood[maxn], willbad[maxn];
vector<int> xs, ys;
vector<int> ys;
vector<line> answer;
vector<line> in;
vector<line> lines;
vector<ll> goods;
vector<ll> ids;
vector<ll> xs, ys;
vector<pair<int, int> > out;
vector<pair<int, int> > a;
vector<pair<int, int> > ans;
vector<pair<int, int> > answer;
vector<pair<int, int> > edges;
vector<pair<int, int> > gr[maxn][maxn];
vector<pair<int, int> > realo[maxn], votr[maxn];
vector<pair<int, int> > sh[maxn];
vector<pair<int, int> > sob;
vector<pair<int, int> > tree[maxn];
vector<pair<int, int> > ur, ul, dr, dl;
vector<pair<int, int> > wh;
vector<pair<int, int> >forks;
vector<pair<int, tnode*> > link;
vector<pair<int, uint> > gr[maxn];
vector<pair<ll, int> > w;
vector<pair<pt, int> > gr[maxn][maxn];
vector<pt> cnv;
vector<pt> pts;
vector<string> dic;
vector<tans> ans;
vector<tans> answer;
vector<tb> bounds;
vector<tedge> connect_e;
vector<tedge> edges, es[maxn];
vector<tedge> gr[maxk];
vector<tedge> gr[maxn], grc[maxn];
vector<tedge> gr[maxn];
vector<tedge> gr[maxv];
vector<tline> xlines, ylines;
vector<tsob> sob;
vector<tsob> sobx[maxn], soby[maxn];
vector<tt> xs, ys;
vector<ull> answer;
vector<int> from[maxn];
vector<int> gr[maxn];
vector<int> grt[maxn], grf[maxn];
vector<int> st1, st2, st3;
vector<int> y[3];
vector<pair<int, int> > t, kar;
vector<pair<int, ll> > gr[maxn];
vector<pair<int, int> > ans;
vector<pt> ob;
vector<pair<int, int> > gr[maxn];
vector<pair<ll, ll> > s;
ver = ncount - 1;
ver[i] = new tnode;
ver[i]->l = NULL;
ver[i]->r = NULL;
ver[i]->x = w[i];
ver[i]->y = (rand() << 16) + rand();
vmax = vector<int>(2 * size);
vmax[cur] = h;
vmax[cur] = max(vmax[2 * cur], vmax[2 * cur + 1]);
void add(char x)
void add(int c)
void add(int cur, int cl, int cr, int l, int r, int t)
void add(int cur, int cl, int cr, int x)
void add(int id)
void add(int l, int r)
void add(int x)
void add(int x, int y, int lastd, char last)
void add(ll a, ll b)
void add(pair<pt, pt> p)
void add(pnode cur, char *s, int curc, int len)
void add(pnode cur, int curstr, int curp, int maxp)
void add(pos a, double ver)
void add(pt p)
void addd(int x, int t)
void adds(int x)
void addto(pnode &cur, int t, int v)
void bad()
void bfs()
void build(int beg)
void calc(pnode cur)
void calcans()
void calct(int cur, int pr)
void change(int a, int h)
void check()
void check(int a, int b, int c)
void check(int cur)
void check(int wh)
void check(int x, int y)
void check(pnode cur, char *s, int curc, int len)
void check_bounds(int x, int y)
void check_cycles(int x, int y)
void color(int x, int y)
void copy(int l1, int r1, int l2, int r2)
void cut(int a, int b)
void decompose(int cur, int pr, rmq *currmq)
void dinic()
void dinitc()
void discharge(int cur)
void doall(int cur)
void donext(double T)
void dowith(int x, int y)
void dowith(pos &a)
void dowith(pt v)
void dowith(tmap *ans)
void dowith(vector<pair<int, int> > &a)
void erase(int wh, bool good)
void expose(int a)
void fact(int n)
void fact(ull n)
void fft(comp *p, int n, int k, comp *w, comp *res)
void fft(ll *p, ll n, ll k, ll *w, ll *res)
void getsizes(int cur, int pr)
void go()
void go(int cur)
void go(int cur, int beg)
void go(int cur, int curc)
void go(int cur, int curh, int was, int wash)
void go(int cur, int maxc)
void go(int cur, int pr)
void go(int cur, int pr, int kvrev, int nowdown, int nowup)
void go(int cur, int pr, int l, int r)
void go(int cur, ll curdf)
void go(int cx, int cy, bool now, int *minneed)
void go(int cx, int cy, int ct)
void go(int i, int j, int cur)
void go(int l, int r, tedge *edges, int ke)
void go(int l, int r, tq *pp, int ke)
void go(int x, int y)
void go(int x, int y, int cur)
void go(string cube)
void go1(int cur, int curv)
void go1(int cur, int pr)
void go1(int x, int y)
void go2()
void go2(int cur, int pr)
void goall(pnode cur, int l, int r)
void goc(int cur, int pr, int curh)
void gothrought(int cur, int pr, int kvrev)
void incomp(int cur, int pr, int c)
void lift(int cur)
void link(int a, int b)
void make()
void make_root(int a)
void make_tree(int cur, int cl, int cr)
void make_tree(int cur, int cl, int cr, int n)
void make_with(int cur, int st)
void mergeall(pnode cur, pnode to, int leftsize)
void op1()
void op2()
void op3()
void outwrite()
void outwrite(int a, int b, int c)
void outwrite(int cur)
void outwrite(int cur, int deep)
void outwrite(ll nnext)
void outwrite(pos nextpos)
void parse(int parbegin)
void pivot(int x, int y, int n, int m, int b, int res)
void pop()
void prep()
void preparelca()
void print()
void print(int lx, int rx)
void print(int n, int m, int b, int res)
void print(pnode cur, string t = "")
void print(pnode cur, string t)
void print(pnode cur, string tab)
void print(uint a, int beg)
void printfall()
void printsolution()
void printtree(pnode cur)
void push(int cur)
void push(tedge *cur)
void pushall(int ct, int cur, int cl, int cr)
void read(int *a)
void rebuild()
void rem(int beg, int x)
void rem(int id)
void rem(int l, int r)
void rems(int x)
void set(int cur, int cl, int cr, int l, int r, int t)
void set(int cur, int cl, int cr, int x, int t)
void set(int cx, int cy, int dir)
void set(int x, bool t)
void set(pnode cur, int x, pair<int, int> t)
void set(pnode cur, ll cl, ll cr, ll l, ll r, ll newy)
void set1(int cur, int cl, int cr, int l, int r, int t)
void set2(int cur, int cl, int cr, int x, int t)
void setall(pnode cur, pnode to, int leftsize)
void solve()
void solve(pt a, pt b, pt c, double &xc, double &yc)
void split(pnode cur, int x, pnode &l, pnode &r)
void split(pnode cur, pnode &l, pnode &r, int x)
void split(pnode cur, pt x, pnode &l, pnode &r)
void splitv(int a)
void to_sqr(int cur, int cl, int cr, int l, int r)
void umn(ll &a[][], ll &b[2][2])
void undo()
void union_(int a, int b)
void upd(int &a, int b)
void update()
void update(int cur)
void updold(int &a, int b)
void write(ld time)
void writebit(ll x)
votr[x1[i]].push_back(make_pair(y1[i], y2[i]));
w1++;
w1[0] = 1;
w1[0] = comp(1, 0);
w2++;
w2[0] = 1;
w2[0] = comp(1, 0);
w[beg * 2] = 1;
w[i] += gr[cur][i];
w[i] = 0;
wa = gr[cur].size();
wa = merge(wb, wa);
wa->reverse ^= true;
wa->up = waup;
wa.x /= da;
wa.y /= da;
was = false;
was = true;
was++;
was.clear();
was.erase(*wh);
was.insert(-1);
was.insert(get_num(cube));
was.insert(n);
was.insert(x);
was1 = 0, was2 = 0;
was1 = j;
was1++;
was1[i] = 1;
was2++;
was2[curx][cury] = true;
was2[i] = 1;
was[0][0] = true;
was[cur->v] = true;
was[cur] = 1;
was[cur] = 2;
was[cur] = false;
was[cur] = kwas;
was[cur] = true;
was[cure] = true;
was[curx][cury] = 1;
was[cx][cy] = true;
was[get_num(cube)] = steps;
was[gr[cur][i]] = true;
was[i] = 1;
was[i] = false;
was[i] = inf;
was[i]++;
was[i]--;
was[in[i].id] = true;
was[j] = 1;
was[j] = i;
was[ke - 1] = false;
was[l][r][whmax] = true;
was[near[p[cur]][i]] = -1;
was[near[p[cur]][i]] = cur;
was[p[answer[i]]] = true;
was[pp[i].id] = wascnt;
was[x][y] = 1;
was[x][y] = true;
wascalc[l][r] = true;
wascnt++;
wascol[curv].push_back(curcolor);
wascol[j] ^= 1;
wascur = true;
wasgo[l][r][nl] = true;
wasi = i;
wasmax = max(wasmax, cur);
wasmin = min(wasmin, cur);
wasq[a] = -1;
wasq[a] = i;
wasq[i] = -1;
wasrow[i] ^= 1;
wb = gr[next].size();
wb->up = -1;
wb->up = a;
wh = cur->link.size();
wh = i;
wh = j + 1;
wh = p[j].id;
wh ^= 1;
wh->first = r;
wh->first = x;
wh->second = l;
wh->second = x;
wh1 = j;
wh2 = i;
wh[b[0].second] = 0;
wh[b[i].second] = i;
wh[cur] = NULL;
wh[cur] = merge(wh[cur], wh[gr[cur][i]]);
wh[cury] = i;
wh[i] = j;
wh[i] = make_pair(pos / k, pos % k);
wh[i].first--;
wh[i].second += k;
wh[i].second = ((wh[i].second + x) % k + k) % k;
wh[id] = cur;
wh[id] = -1;
wh[t] = curpl;
whb = cur;
whcnv = norm[0].id;
whcnv = norm[normsize - 1].id;
whcnv = norm[wh - 1].id;
whcnv = norm[wh].id;
whdeath = i;
when[cure] = i;
whgo = i;
which[i].clear();
which[t[i]][t[i]] = 1;
while (!bad.empty()) bad.pop();
while (!cur.empty() && sum[i + 1] - cur.top() > best.top())
while (!good.empty()) good.pop();
while (!isdigit(c)) scanf("%c", &c);
while (!o.empty())
while (!o.empty()) o.pop();
while (!pl[i].empty())
while (!pq.empty())
while (!q.empty())
while (!q.empty()) q.pop();
while (!qx.empty())
while (!workers.empty())
while (!workers.empty()) workers.pop();
while ((c1 >= 'a' && c1 <= 'z') || (c1 == ' '))
while ((int)re.size() > back) undo();
while ((l & ALL) != 0 && l <= r)
while ((n & 1) == 0)
while ((size & (size - 1)) > 0) size++;
while (MINF)
while (a % 2 == 0)
while (a)
while (a[0] != 0)
while (a[cur] < a[i] * k) cur++;
while (a[currid] < x) currid++;
while (ans.st2 > 0)
while (b != 0)
while (b)
while (bo != eo)
while (bo < eo)
while (buf[len - 1] == '\n' || buf[len - 1] == '\r')
while (c != '#' && c != '.' && c != 'S') scanf("%c", &c);
while (c != '+' && c != '-') scanf("%c", &c);
while (c != '0' && c != '1') scanf("%c", &c);
while (c1 != cur && p[c1] != cur)
while (c1 != cur && p[c1] != cur) c1 = p[c1];
while (c1 < 'a' || c1 > 'z')
while (c1 < 'a' || c2 > 'z')
while (c2 != cur && p[c2] != cur)
while (c2 != cur && p[c2] != cur) c2 = p[c2];
while (clock() < end_time)
while (cnt > 0)
while (cnt > back) undo();
while (conv[cur]->n != 0)
while (cur != -1)
while (cur != 0)
while (cur < K)
while (cur < i)
while (cur < n && a[cur] + y < b[i]) cur++;
while (cur < n && b[cur] != a[i]) cur++;
while (cur < n && q[cur].x <= next)
while (cur < n && t[cur + 1] < time)
while (cur < prcur) cur += m;
while (cur <= n)
while (cur > C)
while (cur >= 1)
while (cur >= m)
while (cur != -1)
while (cur->p != null)
while (cur->p != null) cur = cur->p;
while (cur1 < n || cur2 < m)
while (cur == -1 && begin < n) begin++, cur = wh[a[begin]];
while (curfrom != fromb || curto != tob)
while (curgo > 0)
while (curl < (int)l.size() && curr < (int)r.size())
while (curl < 2 * l)
while (curst < w)
while (curx != -1)
while (cy != ey || cx != ex)
while (eo != bo)
while (eo - bo > 0 && o[eo - 1].first > aarr1[i]) eo--;
while (eo - bo > 0)
while (eo - bo > 1 && o[bo + 1].x < sum) bo++;
while (eo - bo > 1 && q[bo + 1].begin <= a[i]) bo++;
while (eo - bo >= 1 && bad(o[eo - 1], curp)) eo--;
while (eo > bo)
while (ex[cur] > 0 && nextedge[cur] < (int)gr[cur].size())
while (f[cur].l * 2 <= f[i].l)
while (found)
while (from[cur] != -1)
while (h[a] > h[c])
while (h[b] > h[c])
while (j > 0)
while (k < n)
while (ko > 0)
while (kv < n)
while (l + BSZ - 1 <= r)
while (l + BSZ <= r)
while (l < r && (l & MASK))
while (l < r)
while (l <= r)
while (last < prlast) last += m;
while (last > back) undo();
while (last >= cur + m)
while (last == -1 && i <= n + bbegin) i++, last = wh[a[i]];
while (m % KB != 0)
while (m % i == 0)
while (m > 0 && b[m - 1] == 1) m--;
while (m)
while (mins * sumq > w + eps) del();
while (n % i == 0)
while (n % i == 0) n = n / i;
while (n > 0)
while (parbegin < len && s[parbegin] != '/') parbegin++;
while (parbegin < len)
while (r - l > 1)
while (r - l > 1e - 9)
while (r / dmax - (l - 1) / dmax < k)
while (s != "$")
while (s[parbegin] == ' ') parbegin++;
while (scanf("%c", &c) == 1 && leninp < 50)
while (sum < suml)
while (t > 0)
while (tmp)
while (true)
while (true);
while (w1 < n && w2 < m)
while (w1 < n) tmp[cur++] = a[w1++];
while (w2 < m) tmp[cur++] = b[w2++];
while (wa->up != -1)
while (was[cur] == 0)
while (was[cur] == 2)
while (x % i == 0)
while (x < 100)
while (x)
while (x[cur]) cur++;
while (y != x)
while (y)
whmax = i;
whme = cnt;
whmerge1 = i;
whmerge2 = j;
willbad[r[1]].push_back(0);
willbad[r[i + 1]].push_back(ans[i]);
willgood[1].push_back(0);
willgood[l[i] + 1].push_back(ans[i]);
willun(a, b, i);
wins.erase(wins.lower_bound(maxcurlvl), wins.end());
wins[ids[i] + all] = 1;
wins[wh]++;
workers.pop();
workers.push(i);
write(r);
x += a.x;
x += ju[i];
x -= 2;
x /= i;
x = (x + p) % n;
x = (x - (a * a) % (pk * p) + pk * p) % (pk * p);
x = -1;
x = 0;
x = 1;
x = NULL;
x = _x;
x = make_pair(a, b);
x = n - 1;
x = new int;
x = nx;
x = p[x];
x = powmod(x, 2, p);
x = powmod(x, n, p);
x = x + step;
x = x / 2;
x >>= 1;
x--, y--;
x--;
x->how[s[cur->how[curch].first][i] - 'A'] = cur->how[curch];
x->how[s[curstr][i] - 'A'] = make_pair(curstr, maxp);
x->next[s[curstr][i] - 'A'] = new tnode;
x.second = x.second + add;
x1 = nx1;
x2 = nx2;
x[0] = 0;
x[i] = p[i].x;
x[mask] = p[cur[0]].x;
x[mask] = xc;
x[maxn] = inf;
xc = dx / dd;
xc = x1 + (x2 - x1) * t;
xn[i] = x[p[i]], yn[i] = y[p[i]];
xs.push_back(-1);
xs.push_back(ex);
xs.push_back(tt(y1, x1, x2));
xs.push_back(x1);
xs.push_back(x1[i]);
xs.push_back(x2);
xs.push_back(x2[i]);
xs.push_back(x[i] + 1);
xs.push_back(x[i] - 1);
xs.push_back(x[i]);
xs.resize(unique(xs.begin(), xs.end()) - xs.begin());
y += a.y;
y = (rand() << 16) + rand();
y = (y + p) % m + 1;
y = 0;
y = _y;
y = m - 1;
y = ny;
y = p[y];
y = rand();
y >>= 1;
y[0].resize(0);
y[1].resize(0);
y[2].resize(0);
y[Y - 1994].push_back(B);
y[mask] = p[cur[0]].y;
y[mask] = yc;
yc = dy / dd;
yc = y1 + (y2 - y1) * t;
ys.push_back(-1);
ys.push_back(cur.y1);
ys.push_back(cur.y2 + 1);
ys.push_back(ey);
ys.push_back(tt(x1, y1, y2));
ys.push_back(y1);
ys.push_back(y1[i]);
ys.push_back(y2);
ys.push_back(y2[i]);
ys.push_back(y[i] + 1);
ys.push_back(y[i] - 1);
ys.push_back(y[i]);
ys.resize(0);
ys.resize(unique(ys.begin(), ys.end()) - ys.begin());
